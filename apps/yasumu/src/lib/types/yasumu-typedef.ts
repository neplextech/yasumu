/* eslint-disable */
// @ts-nocheck

// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY.
// Run `pnpm generate-typedef` to regenerate.
import denoTypes from './env-types/deno.ts.txt' with { type: 'text' };

export const YASUMU_TYPE_DEFINITIONS = [
  {
    content: "// Yasumu Runtime Type Definitions\n// Auto-generated from src-tauri/src/tanxium/runtime\n\n// Type Aliases\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS' | 'CONNECT' | 'TRACE';\n\n// Interfaces\ninterface CreateYasumuNotification {\n    /**\n     * The title of the notification\n     */\n    title: string;\n    /**\n     * The message of the notification\n     */\n    message: string;\n    /**\n     * The variant of the notification\n     */\n    variant?: 'default' | 'success' | 'warning' | 'info' | 'error';\n    /**\n     * The link to open when the notification is clicked\n     */\n    link?: string;\n}\n\ninterface TabularPair {\n    key: string;\n    value: string;\n    enabled: boolean;\n}\n\ninterface EnvironmentData {\n    id: string;\n    name: string;\n    variables: TabularPair[];\n    secrets: TabularPair[];\n}\n\ninterface RestRequestContextData {\n    url: string;\n    method: HttpMethod;\n    headers: Record<string, string>;\n    body: unknown;\n    parameters: Record<string, string>;\n}\n\ninterface RestResponseContextData {\n    status: number;\n    statusText: string;\n    headers: Record<string, string>;\n    body: unknown;\n}\n\ninterface RestScriptContext {\n    environment: EnvironmentData | null;\n    request: RestRequestContextData;\n    response: RestResponseContextData | null;\n}\n\ninterface YasumuResponseInit {\n    status?: number;\n    statusText?: string;\n    headers?: Record<string, string> | YasumuHeaders;\n    body?: unknown;\n}\n\n// Classes\ndeclare class YasumuUI {\n    /**\n     * Show a toast notification in the ui\n     * @param notification The notification to show\n     */\n    static showNotification(notification: CreateYasumuNotification): Promise<void>;\n}\n\ndeclare class YasumuWorkspaceEnvironment {\n    constructor(data: EnvironmentData | null);\n    get id(): string | null;\n    get name(): string | null;\n    get isActive(): boolean;\n    getVariable(key: string): string | null;\n    setVariable(key: string, value: string): void;\n    deleteVariable(key: string): boolean;\n    hasVariable(key: string): boolean;\n    getSecret(key: string): string | null;\n    setSecret(key: string, value: string): void;\n    deleteSecret(key: string): boolean;\n    hasSecret(key: string): boolean;\n    getAllVariables(): Record<string, string>;\n    getAllSecrets(): Record<string, string>;\n    get modified(): boolean;\n    toData(): EnvironmentData | null;\n}\n\ndeclare class YasumuHeaders {\n    constructor(init?: Record<string, string> | YasumuHeaders);\n    get(name: string): string | null;\n    set(name: string, value: string): void;\n    append(name: string, value: string): void;\n    delete(name: string): void;\n    has(name: string): boolean;\n    keys(): IterableIterator<string>;\n    values(): IterableIterator<string>;\n    entries(): IterableIterator<[string, string]>;\n    forEach(callback: (value: string, key: string, parent: YasumuHeaders) => void): void;\n    [Symbol.iterator](): IterableIterator<[string, string]>;\n    toObject(): Record<string, string>;\n}\n\ndeclare class YasumuURLSearchParams {\n    constructor(init?: Record<string, string> | string | YasumuURLSearchParams);\n    get(name: string): string | null;\n    getAll(name: string): string[];\n    set(name: string, value: string): void;\n    append(name: string, value: string): void;\n    delete(name: string): void;\n    has(name: string): boolean;\n    keys(): IterableIterator<string>;\n    values(): IterableIterator<string>;\n    entries(): IterableIterator<[string, string]>;\n    forEach(callback: (value: string, key: string, parent: YasumuURLSearchParams) => void): void;\n    [Symbol.iterator](): IterableIterator<[string, string]>;\n    toString(): string;\n    toObject(): Record<string, string>;\n}\n\ndeclare class YasumuRequest {\n    constructor(context: RestScriptContext, env?: YasumuWorkspaceEnvironment);\n    get url(): string;\n    set url(value: string);\n    get method(): HttpMethod;\n    set method(value: HttpMethod);\n    get headers(): YasumuHeaders;\n    get body(): unknown;\n    set body(value: unknown);\n    get params(): YasumuURLSearchParams;\n    get env(): YasumuWorkspaceEnvironment;\n    json<T = unknown>(): T;\n    text(): string;\n    clone(): YasumuRequest;\n    toContext(): RestScriptContext;\n}\n\ndeclare class YasumuResponse {\n    constructor(body?: unknown, init?: YasumuResponseInit, env?: YasumuWorkspaceEnvironment);\n    static fromContext(context: RestScriptContext, env?: YasumuWorkspaceEnvironment): YasumuResponse | null;\n    get status(): number;\n    get statusText(): string;\n    get ok(): boolean;\n    get headers(): YasumuHeaders;\n    get body(): unknown;\n    get env(): YasumuWorkspaceEnvironment;\n    json<T = unknown>(): T;\n    text(): string;\n    clone(): YasumuResponse;\n    toContextData(): RestResponseContextData;\n}\n\n// Yasumu Runtime API\ndeclare class Yasumu {\n  static readonly ui: typeof YasumuUI;\n  static readonly version: string;\n  static readonly isDevMode: boolean;\n  static cuid(): string;\n  static postMessage(message: unknown): void;\n  static isReady(): boolean;\n  static onReady(listener: () => unknown): () => void;\n  static onEvent(listener: (event: string) => unknown): () => void;\n  static registerVirtualModule(name: string, code: string): void;\n  static unregisterVirtualModule(name: string): void;\n  static getResourcesDir(): string;\n  static getAppDataDir(): string;\n}",
    filePath: 'ts:yasumu/globals.d.ts',
  },
  {
    content: "// Copyright 2018-2025 the Deno authors. MIT license.\n\n/** The global namespace where Deno specific, non-standard APIs are located. */\ndeclare namespace Deno {\n  /** A set of error constructors that are raised by Deno APIs.\n   *\n   * Can be used to provide more specific handling of failures within code\n   * which is using Deno APIs. For example, handling attempting to open a file\n   * which does not exist:\n   *\n   * ```ts\n   * try {\n   *   const file = await Deno.open(\"./some/file.txt\");\n   * } catch (error) {\n   *   if (error instanceof Deno.errors.NotFound) {\n   *     console.error(\"the file was not found\");\n   *   } else {\n   *     // otherwise re-throw\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @category Errors\n   */\n  export namespace errors {\n    /**\n     * Raised when the underlying operating system indicates that the file\n     * was not found.\n     *\n     * @category Errors */\n    export class NotFound extends Error {}\n    /**\n     * Raised when the underlying operating system indicates the current user\n     * which the Deno process is running under does not have the appropriate\n     * permissions to a file or resource.\n     *\n     * Before Deno 2.0, this error was raised when the user _did not_ provide\n     * required `--allow-*` flag. As of Deno 2.0, that case is now handled by\n     * the {@link NotCapable} error.\n     *\n     * @category Errors */\n    export class PermissionDenied extends Error {}\n    /**\n     * Raised when the underlying operating system reports that a connection to\n     * a resource is refused.\n     *\n     * @category Errors */\n    export class ConnectionRefused extends Error {}\n    /**\n     * Raised when the underlying operating system reports that a connection has\n     * been reset. With network servers, it can be a _normal_ occurrence where a\n     * client will abort a connection instead of properly shutting it down.\n     *\n     * @category Errors */\n    export class ConnectionReset extends Error {}\n    /**\n     * Raised when the underlying operating system reports an `ECONNABORTED`\n     * error.\n     *\n     * @category Errors */\n    export class ConnectionAborted extends Error {}\n    /**\n     * Raised when the underlying operating system reports an `ENOTCONN` error.\n     *\n     * @category Errors */\n    export class NotConnected extends Error {}\n    /**\n     * Raised when attempting to open a server listener on an address and port\n     * that already has a listener.\n     *\n     * @category Errors */\n    export class AddrInUse extends Error {}\n    /**\n     * Raised when the underlying operating system reports an `EADDRNOTAVAIL`\n     * error.\n     *\n     * @category Errors */\n    export class AddrNotAvailable extends Error {}\n    /**\n     * Raised when trying to write to a resource and a broken pipe error occurs.\n     * This can happen when trying to write directly to `stdout` or `stderr`\n     * and the operating system is unable to pipe the output for a reason\n     * external to the Deno runtime.\n     *\n     * @category Errors */\n    export class BrokenPipe extends Error {}\n    /**\n     * Raised when trying to create a resource, like a file, that already\n     * exits.\n     *\n     * @category Errors */\n    export class AlreadyExists extends Error {}\n    /**\n     * Raised when an operation returns data that is invalid for the\n     * operation being performed.\n     *\n     * @category Errors */\n    export class InvalidData extends Error {}\n    /**\n     * Raised when the underlying operating system reports that an I/O operation\n     * has timed out (`ETIMEDOUT`).\n     *\n     * @category Errors */\n    export class TimedOut extends Error {}\n    /**\n     * Raised when the underlying operating system reports an `EINTR` error. In\n     * many cases, this underlying IO error will be handled internally within\n     * Deno, or result in an {@link BadResource} error instead.\n     *\n     * @category Errors */\n    export class Interrupted extends Error {}\n    /**\n     * Raised when the underlying operating system would need to block to\n     * complete but an asynchronous (non-blocking) API is used.\n     *\n     * @category Errors */\n    export class WouldBlock extends Error {}\n    /**\n     * Raised when expecting to write to a IO buffer resulted in zero bytes\n     * being written.\n     *\n     * @category Errors */\n    export class WriteZero extends Error {}\n    /**\n     * Raised when attempting to read bytes from a resource, but the EOF was\n     * unexpectedly encountered.\n     *\n     * @category Errors */\n    export class UnexpectedEof extends Error {}\n    /**\n     * The underlying IO resource is invalid or closed, and so the operation\n     * could not be performed.\n     *\n     * @category Errors */\n    export class BadResource extends Error {}\n    /**\n     * Raised in situations where when attempting to load a dynamic import,\n     * too many redirects were encountered.\n     *\n     * @category Errors */\n    export class Http extends Error {}\n    /**\n     * Raised when the underlying IO resource is not available because it is\n     * being awaited on in another block of code.\n     *\n     * @category Errors */\n    export class Busy extends Error {}\n    /**\n     * Raised when the underlying Deno API is asked to perform a function that\n     * is not currently supported.\n     *\n     * @category Errors */\n    export class NotSupported extends Error {}\n    /**\n     * Raised when too many symbolic links were encountered when resolving the\n     * filename.\n     *\n     * @category Errors */\n    export class FilesystemLoop extends Error {}\n    /**\n     * Raised when trying to open, create or write to a directory.\n     *\n     * @category Errors */\n    export class IsADirectory extends Error {}\n    /**\n     * Raised when performing a socket operation but the remote host is\n     * not reachable.\n     *\n     * @category Errors */\n    export class NetworkUnreachable extends Error {}\n    /**\n     * Raised when trying to perform an operation on a path that is not a\n     * directory, when directory is required.\n     *\n     * @category Errors */\n    export class NotADirectory extends Error {}\n\n    /**\n     * Raised when trying to perform an operation while the relevant Deno\n     * permission (like `--allow-read`) has not been granted.\n     *\n     * Before Deno 2.0, this condition was covered by the {@link PermissionDenied}\n     * error.\n     *\n     * @category Errors */\n    export class NotCapable extends Error {}\n\n    export {}; // only export exports\n  }\n\n  /** The current process ID of this instance of the Deno CLI.\n   *\n   * ```ts\n   * console.log(Deno.pid);\n   * ```\n   *\n   * @category Runtime\n   */\n  export const pid: number;\n\n  /**\n   * The process ID of parent process of this instance of the Deno CLI.\n   *\n   * ```ts\n   * console.log(Deno.ppid);\n   * ```\n   *\n   * @category Runtime\n   */\n  export const ppid: number;\n\n  /** @category Runtime */\n  export interface MemoryUsage {\n    /** The number of bytes of the current Deno's process resident set size,\n     * which is the amount of memory occupied in main memory (RAM). */\n    rss: number;\n    /** The total size of the heap for V8, in bytes. */\n    heapTotal: number;\n    /** The amount of the heap used for V8, in bytes. */\n    heapUsed: number;\n    /** Memory, in bytes, associated with JavaScript objects outside of the\n     * JavaScript isolate. */\n    external: number;\n  }\n\n  /**\n   * Returns an object describing the memory usage of the Deno process and the\n   * V8 subsystem measured in bytes.\n   *\n   * @category Runtime\n   */\n  export function memoryUsage(): MemoryUsage;\n\n  /**\n   * Get the `hostname` of the machine the Deno process is running on.\n   *\n   * ```ts\n   * console.log(Deno.hostname());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function hostname(): string;\n\n  /**\n   * Returns an array containing the 1, 5, and 15 minute load averages. The\n   * load average is a measure of CPU and IO utilization of the last one, five,\n   * and 15 minute periods expressed as a fractional number.  Zero means there\n   * is no load. On Windows, the three values are always the same and represent\n   * the current load, not the 1, 5 and 15 minute load averages.\n   *\n   * ```ts\n   * console.log(Deno.loadavg());  // e.g. [ 0.71, 0.44, 0.44 ]\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * On Windows there is no API available to retrieve this information and this method returns `[ 0, 0, 0 ]`.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function loadavg(): number[];\n\n  /**\n   * The information for a network interface returned from a call to\n   * {@linkcode Deno.networkInterfaces}.\n   *\n   * @category Network\n   */\n  export interface NetworkInterfaceInfo {\n    /** The network interface name. */\n    name: string;\n    /** The IP protocol version. */\n    family: 'IPv4' | 'IPv6';\n    /** The IP address bound to the interface. */\n    address: string;\n    /** The netmask applied to the interface. */\n    netmask: string;\n    /** The IPv6 scope id or `null`. */\n    scopeid: number | null;\n    /** The CIDR range. */\n    cidr: string;\n    /** The MAC address. */\n    mac: string;\n  }\n\n  /**\n   * Returns an array of the network interface information.\n   *\n   * ```ts\n   * console.log(Deno.networkInterfaces());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * @tags allow-sys\n   * @category Network\n   */\n  export function networkInterfaces(): NetworkInterfaceInfo[];\n\n  /**\n   * Displays the total amount of free and used physical and swap memory in the\n   * system, as well as the buffers and caches used by the kernel.\n   *\n   * This is similar to the `free` command in Linux\n   *\n   * ```ts\n   * console.log(Deno.systemMemoryInfo());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function systemMemoryInfo(): SystemMemoryInfo;\n\n  /**\n   * Information returned from a call to {@linkcode Deno.systemMemoryInfo}.\n   *\n   * @category Runtime\n   */\n  export interface SystemMemoryInfo {\n    /** Total installed memory in bytes. */\n    total: number;\n    /** Unused memory in bytes. */\n    free: number;\n    /** Estimation of how much memory, in bytes, is available for starting new\n     * applications, without swapping. Unlike the data provided by the cache or\n     * free fields, this field takes into account page cache and also that not\n     * all reclaimable memory will be reclaimed due to items being in use.\n     */\n    available: number;\n    /** Memory used by kernel buffers. */\n    buffers: number;\n    /** Memory used by the page cache and slabs. */\n    cached: number;\n    /** Total swap memory. */\n    swapTotal: number;\n    /** Unused swap memory. */\n    swapFree: number;\n  }\n\n  /** Reflects the `NO_COLOR` environment variable at program start.\n   *\n   * When the value is `true`, the Deno CLI will attempt to not send color codes\n   * to `stderr` or `stdout` and other command line programs should also attempt\n   * to respect this value.\n   *\n   * See: https://no-color.org/\n   *\n   * @category Runtime\n   */\n  export const noColor: boolean;\n\n  /**\n   * Returns the release version of the Operating System.\n   *\n   * ```ts\n   * console.log(Deno.osRelease());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   * Under consideration to possibly move to Deno.build or Deno.versions and if\n   * it should depend sys-info, which may not be desirable.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function osRelease(): string;\n\n  /**\n   * Returns the Operating System uptime in number of seconds.\n   *\n   * ```ts\n   * console.log(Deno.osUptime());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function osUptime(): number;\n\n  /**\n   * Options which define the permissions within a test or worker context.\n   *\n   * `\"inherit\"` ensures that all permissions of the parent process will be\n   * applied to the test context. `\"none\"` ensures the test context has no\n   * permissions. A `PermissionOptionsObject` provides a more specific\n   * set of permissions to the test context.\n   *\n   * @category Permissions */\n  export type PermissionOptions = 'inherit' | 'none' | PermissionOptionsObject;\n\n  /**\n   * A set of options which can define the permissions within a test or worker\n   * context at a highly specific level.\n   *\n   * @category Permissions */\n  export interface PermissionOptionsObject {\n    /** Specifies if the `env` permission should be requested or revoked.\n     * If set to `\"inherit\"`, the current `env` permission will be inherited.\n     * If set to `true`, the global `env` permission will be requested.\n     * If set to `false`, the global `env` permission will be revoked.\n     *\n     * @default {false}\n     */\n    env?: 'inherit' | boolean | string[];\n\n    /** Specifies if the `ffi` permission should be requested or revoked.\n     * If set to `\"inherit\"`, the current `ffi` permission will be inherited.\n     * If set to `true`, the global `ffi` permission will be requested.\n     * If set to `false`, the global `ffi` permission will be revoked.\n     *\n     * @default {false}\n     */\n    ffi?: 'inherit' | boolean | Array<string | URL>;\n\n    /** Specifies if the `import` permission should be requested or revoked.\n     * If set to `\"inherit\"` the current `import` permission will be inherited.\n     * If set to `true`, the global `import` permission will be requested.\n     * If set to `false`, the global `import` permission will be revoked.\n     * If set to `Array<string>`, the `import` permissions will be requested with the\n     * specified domains.\n     */\n    import?: 'inherit' | boolean | Array<string>;\n\n    /** Specifies if the `net` permission should be requested or revoked.\n     * if set to `\"inherit\"`, the current `net` permission will be inherited.\n     * if set to `true`, the global `net` permission will be requested.\n     * if set to `false`, the global `net` permission will be revoked.\n     * if set to `string[]`, the `net` permission will be requested with the\n     * specified host strings with the format `\"<host>[:<port>]`.\n     *\n     * @default {false}\n     *\n     * Examples:\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test({\n     *   name: \"inherit\",\n     *   permissions: {\n     *     net: \"inherit\",\n     *   },\n     *   async fn() {\n     *     const status = await Deno.permissions.query({ name: \"net\" })\n     *     assertEquals(status.state, \"granted\");\n     *   },\n     * });\n     * ```\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test({\n     *   name: \"true\",\n     *   permissions: {\n     *     net: true,\n     *   },\n     *   async fn() {\n     *     const status = await Deno.permissions.query({ name: \"net\" });\n     *     assertEquals(status.state, \"granted\");\n     *   },\n     * });\n     * ```\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test({\n     *   name: \"false\",\n     *   permissions: {\n     *     net: false,\n     *   },\n     *   async fn() {\n     *     const status = await Deno.permissions.query({ name: \"net\" });\n     *     assertEquals(status.state, \"denied\");\n     *   },\n     * });\n     * ```\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test({\n     *   name: \"localhost:8080\",\n     *   permissions: {\n     *     net: [\"localhost:8080\"],\n     *   },\n     *   async fn() {\n     *     const status = await Deno.permissions.query({ name: \"net\", host: \"localhost:8080\" });\n     *     assertEquals(status.state, \"granted\");\n     *   },\n     * });\n     * ```\n     */\n    net?: 'inherit' | boolean | string[];\n\n    /** Specifies if the `read` permission should be requested or revoked.\n     * If set to `\"inherit\"`, the current `read` permission will be inherited.\n     * If set to `true`, the global `read` permission will be requested.\n     * If set to `false`, the global `read` permission will be revoked.\n     * If set to `Array<string | URL>`, the `read` permission will be requested with the\n     * specified file paths.\n     *\n     * @default {false}\n     */\n    read?: 'inherit' | boolean | Array<string | URL>;\n\n    /** Specifies if the `run` permission should be requested or revoked.\n     * If set to `\"inherit\"`, the current `run` permission will be inherited.\n     * If set to `true`, the global `run` permission will be requested.\n     * If set to `false`, the global `run` permission will be revoked.\n     *\n     * @default {false}\n     */\n    run?: 'inherit' | boolean | Array<string | URL>;\n\n    /** Specifies if the `sys` permission should be requested or revoked.\n     * If set to `\"inherit\"`, the current `sys` permission will be inherited.\n     * If set to `true`, the global `sys` permission will be requested.\n     * If set to `false`, the global `sys` permission will be revoked.\n     *\n     * @default {false}\n     */\n    sys?: 'inherit' | boolean | string[];\n\n    /** Specifies if the `write` permission should be requested or revoked.\n     * If set to `\"inherit\"`, the current `write` permission will be inherited.\n     * If set to `true`, the global `write` permission will be requested.\n     * If set to `false`, the global `write` permission will be revoked.\n     * If set to `Array<string | URL>`, the `write` permission will be requested with the\n     * specified file paths.\n     *\n     * @default {false}\n     */\n    write?: 'inherit' | boolean | Array<string | URL>;\n  }\n\n  /**\n   * Context that is passed to a testing function, which can be used to either\n   * gain information about the current test, or register additional test\n   * steps within the current test.\n   *\n   * @category Testing */\n  export interface TestContext {\n    /** The current test name. */\n    name: string;\n    /** The string URL of the current test. */\n    origin: string;\n    /** If the current test is a step of another test, the parent test context\n     * will be set here. */\n    parent?: TestContext;\n\n    /** Run a sub step of the parent test or step. Returns a promise\n     * that resolves to a boolean signifying if the step completed successfully.\n     *\n     * The returned promise never rejects unless the arguments are invalid.\n     *\n     * If the test was ignored the promise returns `false`.\n     *\n     * ```ts\n     * Deno.test({\n     *   name: \"a parent test\",\n     *   async fn(t) {\n     *     console.log(\"before the step\");\n     *     await t.step({\n     *       name: \"step 1\",\n     *       fn(t) {\n     *         console.log(\"current step:\", t.name);\n     *       }\n     *     });\n     *     console.log(\"after the step\");\n     *   }\n     * });\n     * ```\n     */\n    step(definition: TestStepDefinition): Promise<boolean>;\n\n    /** Run a sub step of the parent test or step. Returns a promise\n     * that resolves to a boolean signifying if the step completed successfully.\n     *\n     * The returned promise never rejects unless the arguments are invalid.\n     *\n     * If the test was ignored the promise returns `false`.\n     *\n     * ```ts\n     * Deno.test(\n     *   \"a parent test\",\n     *   async (t) => {\n     *     console.log(\"before the step\");\n     *     await t.step(\n     *       \"step 1\",\n     *       (t) => {\n     *         console.log(\"current step:\", t.name);\n     *       }\n     *     );\n     *     console.log(\"after the step\");\n     *   }\n     * );\n     * ```\n     */\n    step(\n      name: string,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): Promise<boolean>;\n\n    /** Run a sub step of the parent test or step. Returns a promise\n     * that resolves to a boolean signifying if the step completed successfully.\n     *\n     * The returned promise never rejects unless the arguments are invalid.\n     *\n     * If the test was ignored the promise returns `false`.\n     *\n     * ```ts\n     * Deno.test(async function aParentTest(t) {\n     *   console.log(\"before the step\");\n     *   await t.step(function step1(t) {\n     *     console.log(\"current step:\", t.name);\n     *   });\n     *   console.log(\"after the step\");\n     * });\n     * ```\n     */\n    step(fn: (t: TestContext) => void | Promise<void>): Promise<boolean>;\n  }\n\n  /** @category Testing */\n  export interface TestStepDefinition {\n    /** The test function that will be tested when this step is executed. The\n     * function can take an argument which will provide information about the\n     * current step's context. */\n    fn: (t: TestContext) => void | Promise<void>;\n    /** The name of the step. */\n    name: string;\n    /** If truthy the current test step will be ignored.\n     *\n     * This is a quick way to skip over a step, but also can be used for\n     * conditional logic, like determining if an environment feature is present.\n     */\n    ignore?: boolean;\n    /** Check that the number of async completed operations after the test step\n     * is the same as number of dispatched operations. This ensures that the\n     * code tested does not start async operations which it then does\n     * not await. This helps in preventing logic errors and memory leaks\n     * in the application code.\n     *\n     * Defaults to the parent test or step's value. */\n    sanitizeOps?: boolean;\n    /** Ensure the test step does not \"leak\" resources - like open files or\n     * network connections - by ensuring the open resources at the start of the\n     * step match the open resources at the end of the step.\n     *\n     * Defaults to the parent test or step's value. */\n    sanitizeResources?: boolean;\n    /** Ensure the test step does not prematurely cause the process to exit,\n     * for example via a call to {@linkcode Deno.exit}.\n     *\n     * Defaults to the parent test or step's value. */\n    sanitizeExit?: boolean;\n  }\n\n  /** @category Testing */\n  export interface TestDefinition {\n    fn: (t: TestContext) => void | Promise<void>;\n    /** The name of the test. */\n    name: string;\n    /** If truthy the current test step will be ignored.\n     *\n     * It is a quick way to skip over a step, but also can be used for\n     * conditional logic, like determining if an environment feature is present.\n     */\n    ignore?: boolean;\n    /** If at least one test has `only` set to `true`, only run tests that have\n     * `only` set to `true` and fail the test suite. */\n    only?: boolean;\n    /** Check that the number of async completed operations after the test step\n     * is the same as number of dispatched operations. This ensures that the\n     * code tested does not start async operations which it then does\n     * not await. This helps in preventing logic errors and memory leaks\n     * in the application code.\n     *\n     * @default {true} */\n    sanitizeOps?: boolean;\n    /** Ensure the test step does not \"leak\" resources - like open files or\n     * network connections - by ensuring the open resources at the start of the\n     * test match the open resources at the end of the test.\n     *\n     * @default {true} */\n    sanitizeResources?: boolean;\n    /** Ensure the test case does not prematurely cause the process to exit,\n     * for example via a call to {@linkcode Deno.exit}.\n     *\n     * @default {true} */\n    sanitizeExit?: boolean;\n    /** Specifies the permissions that should be used to run the test.\n     *\n     * Set this to \"inherit\" to keep the calling runtime permissions, set this\n     * to \"none\" to revoke all permissions, or set a more specific set of\n     * permissions using a {@linkcode PermissionOptionsObject}.\n     *\n     * @default {\"inherit\"} */\n    permissions?: PermissionOptions;\n  }\n\n  /** Register a test which will be run when `deno test` is used on the command\n   * line and the containing module looks like a test module.\n   *\n   * `fn` can be async if required.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.test({\n   *   name: \"example test\",\n   *   fn() {\n   *     assertEquals(\"world\", \"world\");\n   *   },\n   * });\n   *\n   * Deno.test({\n   *   name: \"example ignored test\",\n   *   ignore: Deno.build.os === \"windows\",\n   *   fn() {\n   *     // This test is ignored only on Windows machines\n   *   },\n   * });\n   *\n   * Deno.test({\n   *   name: \"example async test\",\n   *   async fn() {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * });\n   * ```\n   *\n   * @category Testing\n   */\n  export const test: DenoTest;\n\n  /**\n   * @category Testing\n   */\n  export interface DenoTest {\n    /** Register a test which will be run when `deno test` is used on the command\n     * line and the containing module looks like a test module.\n     *\n     * `fn` can be async if required.\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test({\n     *   name: \"example test\",\n     *   fn() {\n     *     assertEquals(\"world\", \"world\");\n     *   },\n     * });\n     *\n     * Deno.test({\n     *   name: \"example ignored test\",\n     *   ignore: Deno.build.os === \"windows\",\n     *   fn() {\n     *     // This test is ignored only on Windows machines\n     *   },\n     * });\n     *\n     * Deno.test({\n     *   name: \"example async test\",\n     *   async fn() {\n     *     const decoder = new TextDecoder(\"utf-8\");\n     *     const data = await Deno.readFile(\"hello_world.txt\");\n     *     assertEquals(decoder.decode(data), \"Hello world\");\n     *   }\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    (t: TestDefinition): void;\n\n    /** Register a test which will be run when `deno test` is used on the command\n     * line and the containing module looks like a test module.\n     *\n     * `fn` can be async if required.\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test(\"My test description\", () => {\n     *   assertEquals(\"hello\", \"hello\");\n     * });\n     *\n     * Deno.test(\"My async test description\", async () => {\n     *   const decoder = new TextDecoder(\"utf-8\");\n     *   const data = await Deno.readFile(\"hello_world.txt\");\n     *   assertEquals(decoder.decode(data), \"Hello world\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    (name: string, fn: (t: TestContext) => void | Promise<void>): void;\n\n    /** Register a test which will be run when `deno test` is used on the command\n     * line and the containing module looks like a test module.\n     *\n     * `fn` can be async if required. Declared function must have a name.\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test(function myTestName() {\n     *   assertEquals(\"hello\", \"hello\");\n     * });\n     *\n     * Deno.test(async function myOtherTestName() {\n     *   const decoder = new TextDecoder(\"utf-8\");\n     *   const data = await Deno.readFile(\"hello_world.txt\");\n     *   assertEquals(decoder.decode(data), \"Hello world\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    (fn: (t: TestContext) => void | Promise<void>): void;\n\n    /** Register a test which will be run when `deno test` is used on the command\n     * line and the containing module looks like a test module.\n     *\n     * `fn` can be async if required.\n     *\n     * ```ts\n     * import { assert, fail, assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test(\"My test description\", { permissions: { read: true } }, (): void => {\n     *   assertEquals(\"hello\", \"hello\");\n     * });\n     *\n     * Deno.test(\"My async test description\", { permissions: { read: false } }, async (): Promise<void> => {\n     *   const decoder = new TextDecoder(\"utf-8\");\n     *   const data = await Deno.readFile(\"hello_world.txt\");\n     *   assertEquals(decoder.decode(data), \"Hello world\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    (\n      name: string,\n      options: Omit<TestDefinition, 'fn' | 'name'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Register a test which will be run when `deno test` is used on the command\n     * line and the containing module looks like a test module.\n     *\n     * `fn` can be async if required.\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test(\n     *   {\n     *     name: \"My test description\",\n     *     permissions: { read: true },\n     *   },\n     *   () => {\n     *     assertEquals(\"hello\", \"hello\");\n     *   },\n     * );\n     *\n     * Deno.test(\n     *   {\n     *     name: \"My async test description\",\n     *     permissions: { read: false },\n     *   },\n     *   async () => {\n     *     const decoder = new TextDecoder(\"utf-8\");\n     *     const data = await Deno.readFile(\"hello_world.txt\");\n     *     assertEquals(decoder.decode(data), \"Hello world\");\n     *   },\n     * );\n     * ```\n     *\n     * @category Testing\n     */\n    (\n      options: Omit<TestDefinition, 'fn' | 'name'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Register a test which will be run when `deno test` is used on the command\n     * line and the containing module looks like a test module.\n     *\n     * `fn` can be async if required. Declared function must have a name.\n     *\n     * ```ts\n     * import { assertEquals } from \"jsr:@std/assert\";\n     *\n     * Deno.test(\n     *   { permissions: { read: true } },\n     *   function myTestName() {\n     *     assertEquals(\"hello\", \"hello\");\n     *   },\n     * );\n     *\n     * Deno.test(\n     *   { permissions: { read: false } },\n     *   async function myOtherTestName() {\n     *     const decoder = new TextDecoder(\"utf-8\");\n     *     const data = await Deno.readFile(\"hello_world.txt\");\n     *     assertEquals(decoder.decode(data), \"Hello world\");\n     *   },\n     * );\n     * ```\n     *\n     * @category Testing\n     */\n    (\n      options: Omit<TestDefinition, 'fn'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Shorthand property for ignoring a particular test case.\n     *\n     * @category Testing\n     */\n    ignore(t: Omit<TestDefinition, 'ignore'>): void;\n\n    /** Shorthand property for ignoring a particular test case.\n     *\n     * @category Testing\n     */\n    ignore(name: string, fn: (t: TestContext) => void | Promise<void>): void;\n\n    /** Shorthand property for ignoring a particular test case.\n     *\n     * @category Testing\n     */\n    ignore(fn: (t: TestContext) => void | Promise<void>): void;\n\n    /** Shorthand property for ignoring a particular test case.\n     *\n     * @category Testing\n     */\n    ignore(\n      name: string,\n      options: Omit<TestDefinition, 'fn' | 'name' | 'ignore'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Shorthand property for ignoring a particular test case.\n     *\n     * @category Testing\n     */\n    ignore(\n      options: Omit<TestDefinition, 'fn' | 'name' | 'ignore'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Shorthand property for ignoring a particular test case.\n     *\n     * @category Testing\n     */\n    ignore(\n      options: Omit<TestDefinition, 'fn' | 'ignore'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Shorthand property for focusing a particular test case.\n     *\n     * @category Testing\n     */\n    only(t: Omit<TestDefinition, 'only'>): void;\n\n    /** Shorthand property for focusing a particular test case.\n     *\n     * @category Testing\n     */\n    only(name: string, fn: (t: TestContext) => void | Promise<void>): void;\n\n    /** Shorthand property for focusing a particular test case.\n     *\n     * @category Testing\n     */\n    only(fn: (t: TestContext) => void | Promise<void>): void;\n\n    /** Shorthand property for focusing a particular test case.\n     *\n     * @category Testing\n     */\n    only(\n      name: string,\n      options: Omit<TestDefinition, 'fn' | 'name' | 'only'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Shorthand property for focusing a particular test case.\n     *\n     * @category Testing\n     */\n    only(\n      options: Omit<TestDefinition, 'fn' | 'name' | 'only'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Shorthand property for focusing a particular test case.\n     *\n     * @category Testing\n     */\n    only(\n      options: Omit<TestDefinition, 'fn' | 'only'>,\n      fn: (t: TestContext) => void | Promise<void>,\n    ): void;\n\n    /** Register a function to be called before all tests in the current scope.\n     *\n     * These functions are run in FIFO order (first in, first out).\n     *\n     * If an exception is raised during execution of this hook, the remaining `beforeAll` hooks will not be run.\n     *\n     * ```ts\n     * Deno.test.beforeAll(() => {\n     *   // Setup code that runs once before all tests\n     *   console.log(\"Setting up test suite\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    beforeAll(fn: () => void | Promise<void>): void;\n\n    /** Register a function to be called before each test in the current scope.\n     *\n     * These functions are run in FIFO order (first in, first out).\n     *\n     * If an exception is raised during execution of this hook, the remaining hooks will not be run and the currently running\n     * test case will be marked as failed.\n     *\n     * ```ts\n     * Deno.test.beforeEach(() => {\n     *   // Setup code that runs before each test\n     *   console.log(\"Setting up test\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    beforeEach(fn: () => void | Promise<void>): void;\n\n    /** Register a function to be called after each test in the current scope.\n     *\n     * These functions are run in LIFO order (last in, first out).\n     *\n     * If an exception is raised during execution of this hook, the remaining hooks will not be run and the currently running\n     * test case will be marked as failed.\n     *\n     * ```ts\n     * Deno.test.afterEach(() => {\n     *   // Cleanup code that runs after each test\n     *   console.log(\"Cleaning up test\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    afterEach(fn: () => void | Promise<void>): void;\n\n    /** Register a function to be called after all tests in the current scope have finished running.\n     *\n     * These functions are run in the LIFO order (last in, first out).\n     *\n     * If an exception is raised during execution of this hook, the remaining `afterAll` hooks will not be run.\n     *\n     * ```ts\n     * Deno.test.afterAll(() => {\n     *   // Cleanup code that runs once after all tests\n     *   console.log(\"Cleaning up test suite\");\n     * });\n     * ```\n     *\n     * @category Testing\n     */\n    afterAll(fn: () => void | Promise<void>): void;\n  }\n\n  /**\n   * Context that is passed to a benchmarked function. The instance is shared\n   * between iterations of the benchmark. Its methods can be used for example\n   * to override of the measured portion of the function.\n   *\n   * @category Testing\n   */\n  export interface BenchContext {\n    /** The current benchmark name. */\n    name: string;\n    /** The string URL of the current benchmark. */\n    origin: string;\n\n    /** Restarts the timer for the bench measurement. This should be called\n     * after doing setup work which should not be measured.\n     *\n     * Warning: This method should not be used for benchmarks averaging less\n     * than 10μs per iteration. In such cases it will be disabled but the call\n     * will still have noticeable overhead, resulting in a warning.\n     *\n     * ```ts\n     * Deno.bench(\"foo\", async (t) => {\n     *   const data = await Deno.readFile(\"data.txt\");\n     *   t.start();\n     *   // some operation on `data`...\n     * });\n     * ```\n     */\n    start(): void;\n\n    /** End the timer early for the bench measurement. This should be called\n     * before doing teardown work which should not be measured.\n     *\n     * Warning: This method should not be used for benchmarks averaging less\n     * than 10μs per iteration. In such cases it will be disabled but the call\n     * will still have noticeable overhead, resulting in a warning.\n     *\n     * ```ts\n     * Deno.bench(\"foo\", async (t) => {\n     *   using file = await Deno.open(\"data.txt\");\n     *   t.start();\n     *   // some operation on `file`...\n     *   t.end();\n     * });\n     * ```\n     */\n    end(): void;\n  }\n\n  /**\n   * The interface for defining a benchmark test using {@linkcode Deno.bench}.\n   *\n   * @category Testing\n   */\n  export interface BenchDefinition {\n    /** The test function which will be benchmarked. */\n    fn: (b: BenchContext) => void | Promise<void>;\n    /** The name of the test, which will be used in displaying the results. */\n    name: string;\n    /** If truthy, the benchmark test will be ignored/skipped. */\n    ignore?: boolean;\n    /** Group name for the benchmark.\n     *\n     * Grouped benchmarks produce a group time summary, where the difference\n     * in performance between each test of the group is compared. */\n    group?: string;\n    /** Benchmark should be used as the baseline for other benchmarks.\n     *\n     * If there are multiple baselines in a group, the first one is used as the\n     * baseline. */\n    baseline?: boolean;\n    /** If at least one bench has `only` set to true, only run benches that have\n     * `only` set to `true` and fail the bench suite. */\n    only?: boolean;\n    /** Number of iterations to perform.\n     * @remarks When the benchmark is very fast, this will only be used as a\n     * suggestion in order to get a more accurate measurement.\n     */\n    n?: number;\n    /** Number of warmups to do before running the benchmark.\n     * @remarks A warmup will always be performed even if this is `0` in order to\n     * determine the speed of the benchmark in order to improve the measurement. When\n     * the benchmark is very fast, this will be used as a suggestion.\n     */\n    warmup?: number;\n    /** Ensure the bench case does not prematurely cause the process to exit,\n     * for example via a call to {@linkcode Deno.exit}.\n     *\n     * @default {true} */\n    sanitizeExit?: boolean;\n    /** Specifies the permissions that should be used to run the bench.\n     *\n     * Set this to `\"inherit\"` to keep the calling thread's permissions.\n     *\n     * Set this to `\"none\"` to revoke all permissions.\n     *\n     * @default {\"inherit\"}\n     */\n    permissions?: PermissionOptions;\n  }\n\n  /**\n   * Register a benchmark test which will be run when `deno bench` is used on\n   * the command line and the containing module looks like a bench module.\n   *\n   * If the test function (`fn`) returns a promise or is async, the test runner\n   * will await resolution to consider the test complete.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.bench({\n   *   name: \"example test\",\n   *   fn() {\n   *     assertEquals(\"world\", \"world\");\n   *   },\n   * });\n   *\n   * Deno.bench({\n   *   name: \"example ignored test\",\n   *   ignore: Deno.build.os === \"windows\",\n   *   fn() {\n   *     // This test is ignored only on Windows machines\n   *   },\n   * });\n   *\n   * Deno.bench({\n   *   name: \"example async test\",\n   *   async fn() {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * });\n   * ```\n   *\n   * @category Testing\n   */\n  export function bench(b: BenchDefinition): void;\n\n  /**\n   * Register a benchmark test which will be run when `deno bench` is used on\n   * the command line and the containing module looks like a bench module.\n   *\n   * If the test function (`fn`) returns a promise or is async, the test runner\n   * will await resolution to consider the test complete.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.bench(\"My test description\", () => {\n   *   assertEquals(\"hello\", \"hello\");\n   * });\n   *\n   * Deno.bench(\"My async test description\", async () => {\n   *   const decoder = new TextDecoder(\"utf-8\");\n   *   const data = await Deno.readFile(\"hello_world.txt\");\n   *   assertEquals(decoder.decode(data), \"Hello world\");\n   * });\n   * ```\n   *\n   * @category Testing\n   */\n  export function bench(\n    name: string,\n    fn: (b: BenchContext) => void | Promise<void>,\n  ): void;\n\n  /**\n   * Register a benchmark test which will be run when `deno bench` is used on\n   * the command line and the containing module looks like a bench module.\n   *\n   * If the test function (`fn`) returns a promise or is async, the test runner\n   * will await resolution to consider the test complete.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.bench(function myTestName() {\n   *   assertEquals(\"hello\", \"hello\");\n   * });\n   *\n   * Deno.bench(async function myOtherTestName() {\n   *   const decoder = new TextDecoder(\"utf-8\");\n   *   const data = await Deno.readFile(\"hello_world.txt\");\n   *   assertEquals(decoder.decode(data), \"Hello world\");\n   * });\n   * ```\n   *\n   * @category Testing\n   */\n  export function bench(fn: (b: BenchContext) => void | Promise<void>): void;\n\n  /**\n   * Register a benchmark test which will be run when `deno bench` is used on\n   * the command line and the containing module looks like a bench module.\n   *\n   * If the test function (`fn`) returns a promise or is async, the test runner\n   * will await resolution to consider the test complete.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.bench(\n   *   \"My test description\",\n   *   { permissions: { read: true } },\n   *   () => {\n   *    assertEquals(\"hello\", \"hello\");\n   *   }\n   * );\n   *\n   * Deno.bench(\n   *   \"My async test description\",\n   *   { permissions: { read: false } },\n   *   async () => {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * );\n   * ```\n   *\n   * @category Testing\n   */\n  export function bench(\n    name: string,\n    options: Omit<BenchDefinition, 'fn' | 'name'>,\n    fn: (b: BenchContext) => void | Promise<void>,\n  ): void;\n\n  /**\n   * Register a benchmark test which will be run when `deno bench` is used on\n   * the command line and the containing module looks like a bench module.\n   *\n   * If the test function (`fn`) returns a promise or is async, the test runner\n   * will await resolution to consider the test complete.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.bench(\n   *   { name: \"My test description\", permissions: { read: true } },\n   *   () => {\n   *     assertEquals(\"hello\", \"hello\");\n   *   }\n   * );\n   *\n   * Deno.bench(\n   *   { name: \"My async test description\", permissions: { read: false } },\n   *   async () => {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * );\n   * ```\n   *\n   * @category Testing\n   */\n  export function bench(\n    options: Omit<BenchDefinition, 'fn'>,\n    fn: (b: BenchContext) => void | Promise<void>,\n  ): void;\n\n  /**\n   * Register a benchmark test which will be run when `deno bench` is used on\n   * the command line and the containing module looks like a bench module.\n   *\n   * If the test function (`fn`) returns a promise or is async, the test runner\n   * will await resolution to consider the test complete.\n   *\n   * ```ts\n   * import { assertEquals } from \"jsr:@std/assert\";\n   *\n   * Deno.bench(\n   *   { permissions: { read: true } },\n   *   function myTestName() {\n   *     assertEquals(\"hello\", \"hello\");\n   *   }\n   * );\n   *\n   * Deno.bench(\n   *   { permissions: { read: false } },\n   *   async function myOtherTestName() {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * );\n   * ```\n   *\n   * @category Testing\n   */\n  export function bench(\n    options: Omit<BenchDefinition, 'fn' | 'name'>,\n    fn: (b: BenchContext) => void | Promise<void>,\n  ): void;\n\n  /** Exit the Deno process with optional exit code.\n   *\n   * If no exit code is supplied then Deno will exit with return code of `0`.\n   *\n   * In worker contexts this is an alias to `self.close();`.\n   *\n   * ```ts\n   * Deno.exit(5);\n   * ```\n   *\n   * @category Runtime\n   */\n  export function exit(code?: number): never;\n\n  /** The exit code for the Deno process.\n   *\n   * If no exit code has been supplied, then Deno will assume a return code of `0`.\n   *\n   * When setting an exit code value, a number or non-NaN string must be provided,\n   * otherwise a TypeError will be thrown.\n   *\n   * ```ts\n   * console.log(Deno.exitCode); //-> 0\n   * Deno.exitCode = 1;\n   * console.log(Deno.exitCode); //-> 1\n   * ```\n   *\n   * @category Runtime\n   */\n  export var exitCode: number;\n\n  /** An interface containing methods to interact with the process environment\n   * variables.\n   *\n   * @tags allow-env\n   * @category Runtime\n   */\n  export interface Env {\n    /** Retrieve the value of an environment variable.\n     *\n     * Returns `undefined` if the supplied environment variable is not defined.\n     *\n     * ```ts\n     * console.log(Deno.env.get(\"HOME\"));  // e.g. outputs \"/home/alice\"\n     * console.log(Deno.env.get(\"MADE_UP_VAR\"));  // outputs undefined\n     * ```\n     *\n     * Requires `allow-env` permission.\n     *\n     * @tags allow-env\n     */\n    get(key: string): string | undefined;\n\n    /** Set the value of an environment variable.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\");\n     * Deno.env.get(\"SOME_VAR\");  // outputs \"Value\"\n     * ```\n     *\n     * Requires `allow-env` permission.\n     *\n     * @tags allow-env\n     */\n    set(key: string, value: string): void;\n\n    /** Delete the value of an environment variable.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\");\n     * Deno.env.delete(\"SOME_VAR\");  // outputs \"undefined\"\n     * ```\n     *\n     * Requires `allow-env` permission.\n     *\n     * @tags allow-env\n     */\n    delete(key: string): void;\n\n    /** Check whether an environment variable is present or not.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\");\n     * Deno.env.has(\"SOME_VAR\");  // outputs true\n     * ```\n     *\n     * Requires `allow-env` permission.\n     *\n     * @tags allow-env\n     */\n    has(key: string): boolean;\n\n    /** Returns a snapshot of the environment variables at invocation as a\n     * simple object of keys and values.\n     *\n     * ```ts\n     * Deno.env.set(\"TEST_VAR\", \"A\");\n     * const myEnv = Deno.env.toObject();\n     * console.log(myEnv.SHELL);\n     * Deno.env.set(\"TEST_VAR\", \"B\");\n     * console.log(myEnv.TEST_VAR);  // outputs \"A\"\n     * ```\n     *\n     * Requires `allow-env` permission.\n     *\n     * @tags allow-env\n     */\n    toObject(): { [index: string]: string };\n  }\n\n  /** An interface containing methods to interact with the process environment\n   * variables.\n   *\n   * @tags allow-env\n   * @category Runtime\n   */\n  export const env: Env;\n\n  /**\n   * Returns the path to the current deno executable.\n   *\n   * ```ts\n   * console.log(Deno.execPath());  // e.g. \"/home/alice/.local/bin/deno\"\n   * ```\n   *\n   * @category Runtime\n   */\n  export function execPath(): string;\n\n  /**\n   * Change the current working directory to the specified path.\n   *\n   * ```ts\n   * Deno.chdir(\"/home/userA\");\n   * Deno.chdir(\"../userB\");\n   * Deno.chdir(\"C:\\\\Program Files (x86)\\\\Java\");\n   * ```\n   *\n   * Throws {@linkcode Deno.errors.NotFound} if directory not found.\n   *\n   * Throws {@linkcode Deno.errors.PermissionDenied} if the user does not have\n   * operating system file access rights.\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category Runtime\n   */\n  export function chdir(directory: string | URL): void;\n\n  /**\n   * Return a string representing the current working directory.\n   *\n   * If the current directory can be reached via multiple paths (due to symbolic\n   * links), `cwd()` may return any one of them.\n   *\n   * ```ts\n   * const currentWorkingDirectory = Deno.cwd();\n   * ```\n   *\n   * Throws {@linkcode Deno.errors.NotFound} if directory not available.\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category Runtime\n   */\n  export function cwd(): string;\n\n  /**\n   * Creates `newpath` as a hard link to `oldpath`.\n   *\n   * ```ts\n   * await Deno.link(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function link(oldpath: string, newpath: string): Promise<void>;\n\n  /**\n   * Synchronously creates `newpath` as a hard link to `oldpath`.\n   *\n   * ```ts\n   * Deno.linkSync(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function linkSync(oldpath: string, newpath: string): void;\n\n  /**\n   * A enum which defines the seek mode for IO related APIs that support\n   * seeking.\n   *\n   * @category I/O */\n  export enum SeekMode {\n    /* Seek from the start of the file/resource. */\n    Start = 0,\n    /* Seek from the current position within the file/resource. */\n    Current = 1,\n    /* Seek from the end of the current file/resource. */\n    End = 2,\n  }\n\n  /** Open a file and resolve to an instance of {@linkcode Deno.FsFile}. The\n   * file does not need to previously exist if using the `create` or `createNew`\n   * open options. The caller may have the resulting file automatically closed\n   * by the runtime once it's out of scope by declaring the file variable with\n   * the `using` keyword.\n   *\n   * ```ts\n   * using file = await Deno.open(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * ```\n   *\n   * Alternatively, the caller may manually close the resource when finished with\n   * it.\n   *\n   * ```ts\n   * const file = await Deno.open(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * file.close();\n   * ```\n   *\n   * Requires `allow-read` and/or `allow-write` permissions depending on\n   * options.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function open(\n    path: string | URL,\n    options?: OpenOptions,\n  ): Promise<FsFile>;\n\n  /** Synchronously open a file and return an instance of\n   * {@linkcode Deno.FsFile}. The file does not need to previously exist if\n   * using the `create` or `createNew` open options. The caller may have the\n   * resulting file automatically closed by the runtime once it's out of scope\n   * by declaring the file variable with the `using` keyword.\n   *\n   * ```ts\n   * using file = Deno.openSync(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * ```\n   *\n   * Alternatively, the caller may manually close the resource when finished with\n   * it.\n   *\n   * ```ts\n   * const file = Deno.openSync(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * file.close();\n   * ```\n   *\n   * Requires `allow-read` and/or `allow-write` permissions depending on\n   * options.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function openSync(path: string | URL, options?: OpenOptions): FsFile;\n\n  /** Creates a file if none exists or truncates an existing file and resolves to\n   *  an instance of {@linkcode Deno.FsFile}.\n   *\n   * ```ts\n   * const file = await Deno.create(\"/foo/bar.txt\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function create(path: string | URL): Promise<FsFile>;\n\n  /** Creates a file if none exists or truncates an existing file and returns\n   *  an instance of {@linkcode Deno.FsFile}.\n   *\n   * ```ts\n   * const file = Deno.createSync(\"/foo/bar.txt\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function createSync(path: string | URL): FsFile;\n\n  /** The Deno abstraction for reading and writing files.\n   *\n   * This is the most straight forward way of handling files within Deno and is\n   * recommended over using the discrete functions within the `Deno` namespace.\n   *\n   * ```ts\n   * using file = await Deno.open(\"/foo/bar.txt\", { read: true });\n   * const fileInfo = await file.stat();\n   * if (fileInfo.isFile) {\n   *   const buf = new Uint8Array(100);\n   *   const numberOfBytesRead = await file.read(buf); // 11 bytes\n   *   const text = new TextDecoder().decode(buf);  // \"hello world\"\n   * }\n   * ```\n   *\n   * @category File System\n   */\n  export class FsFile implements Disposable {\n    /** A {@linkcode ReadableStream} instance representing to the byte contents\n     * of the file. This makes it easy to interoperate with other web streams\n     * based APIs.\n     *\n     * ```ts\n     * using file = await Deno.open(\"my_file.txt\", { read: true });\n     * const decoder = new TextDecoder();\n     * for await (const chunk of file.readable) {\n     *   console.log(decoder.decode(chunk));\n     * }\n     * ```\n     */\n    readonly readable: ReadableStream<Uint8Array<ArrayBuffer>>;\n    /** A {@linkcode WritableStream} instance to write the contents of the\n     * file. This makes it easy to interoperate with other web streams based\n     * APIs.\n     *\n     * ```ts\n     * const items = [\"hello\", \"world\"];\n     * using file = await Deno.open(\"my_file.txt\", { write: true });\n     * const encoder = new TextEncoder();\n     * const writer = file.writable.getWriter();\n     * for (const item of items) {\n     *   await writer.write(encoder.encode(item));\n     * }\n     * ```\n     */\n    readonly writable: WritableStream<Uint8Array<ArrayBufferLike>>;\n    /** Write the contents of the array buffer (`p`) to the file.\n     *\n     * Resolves to the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * using file = await Deno.open(\"/foo/bar.txt\", { write: true });\n     * const bytesWritten = await file.write(data); // 11\n     * ```\n     *\n     * @category I/O\n     */\n    write(p: Uint8Array): Promise<number>;\n    /** Synchronously write the contents of the array buffer (`p`) to the file.\n     *\n     * Returns the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * using file = Deno.openSync(\"/foo/bar.txt\", { write: true });\n     * const bytesWritten = file.writeSync(data); // 11\n     * ```\n     */\n    writeSync(p: Uint8Array): number;\n    /** Truncates (or extends) the file to reach the specified `len`. If `len`\n     * is not specified, then the entire file contents are truncated.\n     *\n     * ### Truncate the entire file\n     *\n     * ```ts\n     * using file = await Deno.open(\"my_file.txt\", { write: true });\n     * await file.truncate();\n     * ```\n     *\n     * ### Truncate part of the file\n     *\n     * ```ts\n     * // if \"my_file.txt\" contains the text \"hello world\":\n     * using file = await Deno.open(\"my_file.txt\", { write: true });\n     * await file.truncate(7);\n     * const buf = new Uint8Array(100);\n     * await file.read(buf);\n     * const text = new TextDecoder().decode(buf); // \"hello w\"\n     * ```\n     */\n    truncate(len?: number): Promise<void>;\n    /** Synchronously truncates (or extends) the file to reach the specified\n     * `len`. If `len` is not specified, then the entire file contents are\n     * truncated.\n     *\n     * ### Truncate the entire file\n     *\n     * ```ts\n     * using file = Deno.openSync(\"my_file.txt\", { write: true });\n     * file.truncateSync();\n     * ```\n     *\n     * ### Truncate part of the file\n     *\n     * ```ts\n     * // if \"my_file.txt\" contains the text \"hello world\":\n     * using file = Deno.openSync(\"my_file.txt\", { write: true });\n     * file.truncateSync(7);\n     * const buf = new Uint8Array(100);\n     * file.readSync(buf);\n     * const text = new TextDecoder().decode(buf); // \"hello w\"\n     * ```\n     */\n    truncateSync(len?: number): void;\n    /** Read the file into an array buffer (`p`).\n     *\n     * Resolves to either the number of bytes read during the operation or EOF\n     * (`null`) if there was nothing more to read.\n     *\n     * It is possible for a read to successfully return with `0` bytes. This\n     * does not indicate EOF.\n     *\n     * **It is not guaranteed that the full buffer will be read in a single\n     * call.**\n     *\n     * ```ts\n     * // if \"/foo/bar.txt\" contains the text \"hello world\":\n     * using file = await Deno.open(\"/foo/bar.txt\");\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * ```\n     */\n    read(p: Uint8Array): Promise<number | null>;\n    /** Synchronously read from the file into an array buffer (`p`).\n     *\n     * Returns either the number of bytes read during the operation or EOF\n     * (`null`) if there was nothing more to read.\n     *\n     * It is possible for a read to successfully return with `0` bytes. This\n     * does not indicate EOF.\n     *\n     * **It is not guaranteed that the full buffer will be read in a single\n     * call.**\n     *\n     * ```ts\n     * // if \"/foo/bar.txt\" contains the text \"hello world\":\n     * using file = Deno.openSync(\"/foo/bar.txt\");\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = file.readSync(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * ```\n     */\n    readSync(p: Uint8Array): number | null;\n    /** Seek to the given `offset` under mode given by `whence`. The call\n     * resolves to the new position within the resource (bytes from the start).\n     *\n     * ```ts\n     * // Given the file contains \"Hello world\" text, which is 11 bytes long:\n     * using file = await Deno.open(\n     *   \"hello.txt\",\n     *   { read: true, write: true, truncate: true, create: true },\n     * );\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // advance cursor 6 bytes\n     * const cursorPosition = await file.seek(6, Deno.SeekMode.Start);\n     * console.log(cursorPosition);  // 6\n     * const buf = new Uint8Array(100);\n     * await file.read(buf);\n     * console.log(new TextDecoder().decode(buf)); // \"world\"\n     * ```\n     *\n     * The seek modes work as follows:\n     *\n     * ```ts\n     * // Given the file contains \"Hello world\" text, which is 11 bytes long:\n     * const file = await Deno.open(\n     *   \"hello.txt\",\n     *   { read: true, write: true, truncate: true, create: true },\n     * );\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(await file.seek(6, Deno.SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(await file.seek(2, Deno.SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(await file.seek(-2, Deno.SeekMode.End)); // \"9\" (i.e. 11-2)\n     * ```\n     */\n    seek(offset: number | bigint, whence: SeekMode): Promise<number>;\n    /** Synchronously seek to the given `offset` under mode given by `whence`.\n     * The new position within the resource (bytes from the start) is returned.\n     *\n     * ```ts\n     * using file = Deno.openSync(\n     *   \"hello.txt\",\n     *   { read: true, write: true, truncate: true, create: true },\n     * );\n     * file.writeSync(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // advance cursor 6 bytes\n     * const cursorPosition = file.seekSync(6, Deno.SeekMode.Start);\n     * console.log(cursorPosition);  // 6\n     * const buf = new Uint8Array(100);\n     * file.readSync(buf);\n     * console.log(new TextDecoder().decode(buf)); // \"world\"\n     * ```\n     *\n     * The seek modes work as follows:\n     *\n     * ```ts\n     * // Given the file contains \"Hello world\" text, which is 11 bytes long:\n     * using file = Deno.openSync(\n     *   \"hello.txt\",\n     *   { read: true, write: true, truncate: true, create: true },\n     * );\n     * file.writeSync(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(file.seekSync(6, Deno.SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(file.seekSync(2, Deno.SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(file.seekSync(-2, Deno.SeekMode.End)); // \"9\" (i.e. 11-2)\n     * ```\n     */\n    seekSync(offset: number | bigint, whence: SeekMode): number;\n    /** Resolves to a {@linkcode Deno.FileInfo} for the file.\n     *\n     * ```ts\n     * import { assert } from \"jsr:@std/assert\";\n     *\n     * using file = await Deno.open(\"hello.txt\");\n     * const fileInfo = await file.stat();\n     * assert(fileInfo.isFile);\n     * ```\n     */\n    stat(): Promise<FileInfo>;\n    /** Synchronously returns a {@linkcode Deno.FileInfo} for the file.\n     *\n     * ```ts\n     * import { assert } from \"jsr:@std/assert\";\n     *\n     * using file = Deno.openSync(\"hello.txt\")\n     * const fileInfo = file.statSync();\n     * assert(fileInfo.isFile);\n     * ```\n     */\n    statSync(): FileInfo;\n    /**\n     * Flushes any pending data and metadata operations of the given file\n     * stream to disk.\n     *\n     * ```ts\n     * const file = await Deno.open(\n     *   \"my_file.txt\",\n     *   { read: true, write: true, create: true },\n     * );\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.truncate(1);\n     * await file.sync();\n     * console.log(await Deno.readTextFile(\"my_file.txt\")); // H\n     * ```\n     *\n     * @category I/O\n     */\n    sync(): Promise<void>;\n    /**\n     * Synchronously flushes any pending data and metadata operations of the given\n     * file stream to disk.\n     *\n     * ```ts\n     * const file = Deno.openSync(\n     *   \"my_file.txt\",\n     *   { read: true, write: true, create: true },\n     * );\n     * file.writeSync(new TextEncoder().encode(\"Hello World\"));\n     * file.truncateSync(1);\n     * file.syncSync();\n     * console.log(Deno.readTextFileSync(\"my_file.txt\")); // H\n     * ```\n     *\n     * @category I/O\n     */\n    syncSync(): void;\n    /**\n     * Flushes any pending data operations of the given file stream to disk.\n     *  ```ts\n     * using file = await Deno.open(\n     *   \"my_file.txt\",\n     *   { read: true, write: true, create: true },\n     * );\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.syncData();\n     * console.log(await Deno.readTextFile(\"my_file.txt\")); // Hello World\n     * ```\n     *\n     * @category I/O\n     */\n    syncData(): Promise<void>;\n    /**\n     * Synchronously flushes any pending data operations of the given file stream\n     * to disk.\n     *\n     *  ```ts\n     * using file = Deno.openSync(\n     *   \"my_file.txt\",\n     *   { read: true, write: true, create: true },\n     * );\n     * file.writeSync(new TextEncoder().encode(\"Hello World\"));\n     * file.syncDataSync();\n     * console.log(Deno.readTextFileSync(\"my_file.txt\")); // Hello World\n     * ```\n     *\n     * @category I/O\n     */\n    syncDataSync(): void;\n    /**\n     * Changes the access (`atime`) and modification (`mtime`) times of the\n     * file stream resource. Given times are either in seconds (UNIX epoch\n     * time) or as `Date` objects.\n     *\n     * ```ts\n     * using file = await Deno.open(\"file.txt\", { create: true, write: true });\n     * await file.utime(1556495550, new Date());\n     * ```\n     *\n     * @category File System\n     */\n    utime(atime: number | Date, mtime: number | Date): Promise<void>;\n    /**\n     * Synchronously changes the access (`atime`) and modification (`mtime`)\n     * times of the file stream resource. Given times are either in seconds\n     * (UNIX epoch time) or as `Date` objects.\n     *\n     * ```ts\n     * using file = Deno.openSync(\"file.txt\", { create: true, write: true });\n     * file.utime(1556495550, new Date());\n     * ```\n     *\n     * @category File System\n     */\n    utimeSync(atime: number | Date, mtime: number | Date): void;\n    /**\n     * Checks if the file resource is a TTY (terminal).\n     *\n     * ```ts\n     * // This example is system and context specific\n     * using file = await Deno.open(\"/dev/tty6\");\n     * file.isTerminal(); // true\n     * ```\n     */\n    isTerminal(): boolean;\n    /**\n     * Set TTY to be under raw mode or not. In raw mode, characters are read and\n     * returned as is, without being processed. All special processing of\n     * characters by the terminal is disabled, including echoing input\n     * characters. Reading from a TTY device in raw mode is faster than reading\n     * from a TTY device in canonical mode.\n     *\n     * ```ts\n     * using file = await Deno.open(\"/dev/tty6\");\n     * file.setRaw(true, { cbreak: true });\n     * ```\n     */\n    setRaw(mode: boolean, options?: SetRawOptions): void;\n    /**\n     * Acquire an advisory file-system lock for the file.\n     *\n     * @param [exclusive=false]\n     */\n    lock(exclusive?: boolean): Promise<void>;\n    /**\n     * Synchronously acquire an advisory file-system lock synchronously for the file.\n     *\n     * @param [exclusive=false]\n     */\n    lockSync(exclusive?: boolean): void;\n    /**\n     * Release an advisory file-system lock for the file.\n     */\n    unlock(): Promise<void>;\n    /**\n     * Synchronously release an advisory file-system lock for the file.\n     */\n    unlockSync(): void;\n    /** Close the file. Closing a file when you are finished with it is\n     * important to avoid leaking resources.\n     *\n     * ```ts\n     * using file = await Deno.open(\"my_file.txt\");\n     * // do work with \"file\" object\n     * ```\n     */\n    close(): void;\n\n    [Symbol.dispose](): void;\n  }\n\n  /** Gets the size of the console as columns/rows.\n   *\n   * ```ts\n   * const { columns, rows } = Deno.consoleSize();\n   * ```\n   *\n   * This returns the size of the console window as reported by the operating\n   * system. It's not a reflection of how many characters will fit within the\n   * console window, but can be used as part of that calculation.\n   *\n   * @category I/O\n   */\n  export function consoleSize(): {\n    columns: number;\n    rows: number;\n  };\n\n  /** @category I/O */\n  export interface SetRawOptions {\n    /**\n     * The `cbreak` option can be used to indicate that characters that\n     * correspond to a signal should still be generated. When disabling raw\n     * mode, this option is ignored. This functionality currently only works on\n     * Linux and Mac OS.\n     */\n    cbreak: boolean;\n  }\n\n  /** A reference to `stdin` which can be used to read directly from `stdin`.\n   *\n   * It implements the Deno specific\n   * {@linkcode https://jsr.io/@std/io/doc/types/~/Reader | Reader},\n   * {@linkcode https://jsr.io/@std/io/doc/types/~/ReaderSync | ReaderSync},\n   * and {@linkcode https://jsr.io/@std/io/doc/types/~/Closer | Closer}\n   * interfaces as well as provides a {@linkcode ReadableStream} interface.\n   *\n   * ### Reading chunks from the readable stream\n   *\n   * ```ts\n   * const decoder = new TextDecoder();\n   * for await (const chunk of Deno.stdin.readable) {\n   *   const text = decoder.decode(chunk);\n   *   // do something with the text\n   * }\n   * ```\n   *\n   * @category I/O\n   */\n  export const stdin: {\n    /** Read the incoming data from `stdin` into an array buffer (`p`).\n     *\n     * Resolves to either the number of bytes read during the operation or EOF\n     * (`null`) if there was nothing more to read.\n     *\n     * It is possible for a read to successfully return with `0` bytes. This\n     * does not indicate EOF.\n     *\n     * **It is not guaranteed that the full buffer will be read in a single\n     * call.**\n     *\n     * ```ts\n     * // If the text \"hello world\" is piped into the script:\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await Deno.stdin.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * ```\n     *\n     * @category I/O\n     */\n    read(p: Uint8Array): Promise<number | null>;\n    /** Synchronously read from the incoming data from `stdin` into an array\n     * buffer (`p`).\n     *\n     * Returns either the number of bytes read during the operation or EOF\n     * (`null`) if there was nothing more to read.\n     *\n     * It is possible for a read to successfully return with `0` bytes. This\n     * does not indicate EOF.\n     *\n     * **It is not guaranteed that the full buffer will be read in a single\n     * call.**\n     *\n     * ```ts\n     * // If the text \"hello world\" is piped into the script:\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = Deno.stdin.readSync(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * ```\n     *\n     * @category I/O\n     */\n    readSync(p: Uint8Array): number | null;\n    /** Closes `stdin`, freeing the resource.\n     *\n     * ```ts\n     * Deno.stdin.close();\n     * ```\n     */\n    close(): void;\n    /** A readable stream interface to `stdin`. */\n    readonly readable: ReadableStream<Uint8Array<ArrayBuffer>>;\n    /**\n     * Set TTY to be under raw mode or not. In raw mode, characters are read and\n     * returned as is, without being processed. All special processing of\n     * characters by the terminal is disabled, including echoing input\n     * characters. Reading from a TTY device in raw mode is faster than reading\n     * from a TTY device in canonical mode.\n     *\n     * ```ts\n     * Deno.stdin.setRaw(true, { cbreak: true });\n     * ```\n     *\n     * @category I/O\n     */\n    setRaw(mode: boolean, options?: SetRawOptions): void;\n    /**\n     * Checks if `stdin` is a TTY (terminal).\n     *\n     * ```ts\n     * // This example is system and context specific\n     * Deno.stdin.isTerminal(); // true\n     * ```\n     *\n     * @category I/O\n     */\n    isTerminal(): boolean;\n  };\n  /** A reference to `stdout` which can be used to write directly to `stdout`.\n   * It implements the Deno specific\n   * {@linkcode https://jsr.io/@std/io/doc/types/~/Writer | Writer},\n   * {@linkcode https://jsr.io/@std/io/doc/types/~/WriterSync | WriterSync},\n   * and {@linkcode https://jsr.io/@std/io/doc/types/~/Closer | Closer} interfaces as well as provides a\n   * {@linkcode WritableStream} interface.\n   *\n   * These are low level constructs, and the {@linkcode console} interface is a\n   * more straight forward way to interact with `stdout` and `stderr`.\n   *\n   * @category I/O\n   */\n  export const stdout: {\n    /** Write the contents of the array buffer (`p`) to `stdout`.\n     *\n     * Resolves to the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const bytesWritten = await Deno.stdout.write(data); // 11\n     * ```\n     *\n     * @category I/O\n     */\n    write(p: Uint8Array): Promise<number>;\n    /** Synchronously write the contents of the array buffer (`p`) to `stdout`.\n     *\n     * Returns the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const bytesWritten = Deno.stdout.writeSync(data); // 11\n     * ```\n     */\n    writeSync(p: Uint8Array): number;\n    /** Closes `stdout`, freeing the resource.\n     *\n     * ```ts\n     * Deno.stdout.close();\n     * ```\n     */\n    close(): void;\n    /** A writable stream interface to `stdout`. */\n    readonly writable: WritableStream<Uint8Array<ArrayBufferLike>>;\n    /**\n     * Checks if `stdout` is a TTY (terminal).\n     *\n     * ```ts\n     * // This example is system and context specific\n     * Deno.stdout.isTerminal(); // true\n     * ```\n     *\n     * @category I/O\n     */\n    isTerminal(): boolean;\n  };\n  /** A reference to `stderr` which can be used to write directly to `stderr`.\n   * It implements the Deno specific\n   * {@linkcode https://jsr.io/@std/io/doc/types/~/Writer | Writer},\n   * {@linkcode https://jsr.io/@std/io/doc/types/~/WriterSync | WriterSync},\n   * and {@linkcode https://jsr.io/@std/io/doc/types/~/Closer | Closer} interfaces as well as provides a\n   * {@linkcode WritableStream} interface.\n   *\n   * These are low level constructs, and the {@linkcode console} interface is a\n   * more straight forward way to interact with `stdout` and `stderr`.\n   *\n   * @category I/O\n   */\n  export const stderr: {\n    /** Write the contents of the array buffer (`p`) to `stderr`.\n     *\n     * Resolves to the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const bytesWritten = await Deno.stderr.write(data); // 11\n     * ```\n     *\n     * @category I/O\n     */\n    write(p: Uint8Array): Promise<number>;\n    /** Synchronously write the contents of the array buffer (`p`) to `stderr`.\n     *\n     * Returns the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const bytesWritten = Deno.stderr.writeSync(data); // 11\n     * ```\n     */\n    writeSync(p: Uint8Array): number;\n    /** Closes `stderr`, freeing the resource.\n     *\n     * ```ts\n     * Deno.stderr.close();\n     * ```\n     */\n    close(): void;\n    /** A writable stream interface to `stderr`. */\n    readonly writable: WritableStream<Uint8Array<ArrayBufferLike>>;\n    /**\n     * Checks if `stderr` is a TTY (terminal).\n     *\n     * ```ts\n     * // This example is system and context specific\n     * Deno.stderr.isTerminal(); // true\n     * ```\n     *\n     * @category I/O\n     */\n    isTerminal(): boolean;\n  };\n\n  /**\n   * Options which can be set when doing {@linkcode Deno.open} and\n   * {@linkcode Deno.openSync}.\n   *\n   * @category File System */\n  export interface OpenOptions {\n    /** Sets the option for read access. This option, when `true`, means that\n     * the file should be read-able if opened.\n     *\n     * @default {true} */\n    read?: boolean;\n    /** Sets the option for write access. This option, when `true`, means that\n     * the file should be write-able if opened. If the file already exists,\n     * any write calls on it will overwrite its contents, by default without\n     * truncating it.\n     *\n     * @default {false} */\n    write?: boolean;\n    /** Sets the option for the append mode. This option, when `true`, means\n     * that writes will append to a file instead of overwriting previous\n     * contents.\n     *\n     * Note that setting `{ write: true, append: true }` has the same effect as\n     * setting only `{ append: true }`.\n     *\n     * @default {false} */\n    append?: boolean;\n    /** Sets the option for truncating a previous file. If a file is\n     * successfully opened with this option set it will truncate the file to `0`\n     * size if it already exists. The file must be opened with write access\n     * for truncate to work.\n     *\n     * @default {false} */\n    truncate?: boolean;\n    /** Sets the option to allow creating a new file, if one doesn't already\n     * exist at the specified path. Requires write or append access to be\n     * used.\n     *\n     * @default {false} */\n    create?: boolean;\n    /** If set to `true`, no file, directory, or symlink is allowed to exist at\n     * the target location. Requires write or append access to be used. When\n     * createNew is set to `true`, create and truncate are ignored.\n     *\n     * @default {false} */\n    createNew?: boolean;\n    /** Permissions to use if creating the file (defaults to `0o666`, before\n     * the process's umask).\n     *\n     * Ignored on Windows. */\n    mode?: number;\n  }\n\n  /**\n   * Options which can be set when using {@linkcode Deno.readFile} or\n   * {@linkcode Deno.readFileSync}.\n   *\n   * @category File System */\n  export interface ReadFileOptions {\n    /**\n     * An abort signal to allow cancellation of the file read operation.\n     * If the signal becomes aborted the readFile operation will be stopped\n     * and the promise returned will be rejected with an AbortError.\n     */\n    signal?: AbortSignal;\n  }\n\n  /**\n   * Options which can be set when using {@linkcode Deno.mkdir} and\n   * {@linkcode Deno.mkdirSync}.\n   *\n   * @category File System */\n  export interface MkdirOptions {\n    /** If set to `true`, means that any intermediate directories will also be\n     * created (as with the shell command `mkdir -p`).\n     *\n     * Intermediate directories are created with the same permissions.\n     *\n     * When recursive is set to `true`, succeeds silently (without changing any\n     * permissions) if a directory already exists at the path, or if the path\n     * is a symlink to an existing directory.\n     *\n     * @default {false} */\n    recursive?: boolean;\n    /** Permissions to use when creating the directory (defaults to `0o777`,\n     * before the process's umask).\n     *\n     * Ignored on Windows. */\n    mode?: number;\n  }\n\n  /** Creates a new directory with the specified path.\n   *\n   * ```ts\n   * await Deno.mkdir(\"new_dir\");\n   * await Deno.mkdir(\"nested/directories\", { recursive: true });\n   * await Deno.mkdir(\"restricted_access_dir\", { mode: 0o700 });\n   * ```\n   *\n   * Defaults to throwing error if the directory already exists.\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function mkdir(\n    path: string | URL,\n    options?: MkdirOptions,\n  ): Promise<void>;\n\n  /** Synchronously creates a new directory with the specified path.\n   *\n   * ```ts\n   * Deno.mkdirSync(\"new_dir\");\n   * Deno.mkdirSync(\"nested/directories\", { recursive: true });\n   * Deno.mkdirSync(\"restricted_access_dir\", { mode: 0o700 });\n   * ```\n   *\n   * Defaults to throwing error if the directory already exists.\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function mkdirSync(path: string | URL, options?: MkdirOptions): void;\n\n  /**\n   * Options which can be set when using {@linkcode Deno.makeTempDir},\n   * {@linkcode Deno.makeTempDirSync}, {@linkcode Deno.makeTempFile}, and\n   * {@linkcode Deno.makeTempFileSync}.\n   *\n   * @category File System */\n  export interface MakeTempOptions {\n    /** Directory where the temporary directory should be created (defaults to\n     * the env variable `TMPDIR`, or the system's default, usually `/tmp`).\n     *\n     * Note that if the passed `dir` is relative, the path returned by\n     * `makeTempFile()` and `makeTempDir()` will also be relative. Be mindful of\n     * this when changing working directory. */\n    dir?: string;\n    /** String that should precede the random portion of the temporary\n     * directory's name. */\n    prefix?: string;\n    /** String that should follow the random portion of the temporary\n     * directory's name. */\n    suffix?: string;\n  }\n\n  /** Creates a new temporary directory in the default directory for temporary\n   * files, unless `dir` is specified. Other optional options include\n   * prefixing and suffixing the directory name with `prefix` and `suffix`\n   * respectively.\n   *\n   * This call resolves to the full path to the newly created directory.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * directories. It is the caller's responsibility to remove the directory when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempDirName0 = await Deno.makeTempDir();  // e.g. /tmp/2894ea76\n   * const tempDirName1 = await Deno.makeTempDir({ prefix: 'my_temp' }); // e.g. /tmp/my_temp339c944d\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  // TODO(ry) Doesn't check permissions.\n  export function makeTempDir(options?: MakeTempOptions): Promise<string>;\n\n  /** Synchronously creates a new temporary directory in the default directory\n   * for temporary files, unless `dir` is specified. Other optional options\n   * include prefixing and suffixing the directory name with `prefix` and\n   * `suffix` respectively.\n   *\n   * The full path to the newly created directory is returned.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * directories. It is the caller's responsibility to remove the directory when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempDirName0 = Deno.makeTempDirSync();  // e.g. /tmp/2894ea76\n   * const tempDirName1 = Deno.makeTempDirSync({ prefix: 'my_temp' });  // e.g. /tmp/my_temp339c944d\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  // TODO(ry) Doesn't check permissions.\n  export function makeTempDirSync(options?: MakeTempOptions): string;\n\n  /** Creates a new temporary file in the default directory for temporary\n   * files, unless `dir` is specified.\n   *\n   * Other options include prefixing and suffixing the directory name with\n   * `prefix` and `suffix` respectively.\n   *\n   * This call resolves to the full path to the newly created file.\n   *\n   * Multiple programs calling this function simultaneously will create\n   * different files. It is the caller's responsibility to remove the file when\n   * no longer needed.\n   *\n   * ```ts\n   * const tmpFileName0 = await Deno.makeTempFile();  // e.g. /tmp/419e0bf2\n   * const tmpFileName1 = await Deno.makeTempFile({ prefix: 'my_temp' });  // e.g. /tmp/my_temp754d3098\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function makeTempFile(options?: MakeTempOptions): Promise<string>;\n\n  /** Synchronously creates a new temporary file in the default directory for\n   * temporary files, unless `dir` is specified.\n   *\n   * Other options include prefixing and suffixing the directory name with\n   * `prefix` and `suffix` respectively.\n   *\n   * The full path to the newly created file is returned.\n   *\n   * Multiple programs calling this function simultaneously will create\n   * different files. It is the caller's responsibility to remove the file when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempFileName0 = Deno.makeTempFileSync(); // e.g. /tmp/419e0bf2\n   * const tempFileName1 = Deno.makeTempFileSync({ prefix: 'my_temp' });  // e.g. /tmp/my_temp754d3098\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function makeTempFileSync(options?: MakeTempOptions): string;\n\n  /** Changes the permission of a specific file/directory of specified path.\n   * Ignores the process's umask.\n   *\n   * ```ts\n   * await Deno.chmod(\"/path/to/file\", 0o666);\n   * ```\n   *\n   * The mode is a sequence of 3 octal numbers. The first/left-most number\n   * specifies the permissions for the owner. The second number specifies the\n   * permissions for the group. The last/right-most number specifies the\n   * permissions for others. For example, with a mode of 0o764, the owner (7)\n   * can read/write/execute, the group (6) can read/write and everyone else (4)\n   * can read only.\n   *\n   * | Number | Description |\n   * | ------ | ----------- |\n   * | 7      | read, write, and execute |\n   * | 6      | read and write |\n   * | 5      | read and execute |\n   * | 4      | read only |\n   * | 3      | write and execute |\n   * | 2      | write only |\n   * | 1      | execute only |\n   * | 0      | no permission |\n   *\n   * Note: On Windows, only the read and write permissions can be modified.\n   * Distinctions between owner, group, and others are not supported.\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function chmod(path: string | URL, mode: number): Promise<void>;\n\n  /** Synchronously changes the permission of a specific file/directory of\n   * specified path. Ignores the process's umask.\n   *\n   * ```ts\n   * Deno.chmodSync(\"/path/to/file\", 0o666);\n   * ```\n   *\n   * For a full description, see {@linkcode Deno.chmod}.\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function chmodSync(path: string | URL, mode: number): void;\n\n  /** Change owner of a regular file or directory.\n   *\n   * This functionality is not available on Windows.\n   *\n   * ```ts\n   * await Deno.chown(\"myFile.txt\", 1000, 1002);\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * Throws Error (not implemented) if executed on Windows.\n   *\n   * @tags allow-write\n   * @category File System\n   *\n   * @param path path to the file\n   * @param uid user id (UID) of the new owner, or `null` for no change\n   * @param gid group id (GID) of the new owner, or `null` for no change\n   */\n  export function chown(\n    path: string | URL,\n    uid: number | null,\n    gid: number | null,\n  ): Promise<void>;\n\n  /** Synchronously change owner of a regular file or directory.\n   *\n   * This functionality is not available on Windows.\n   *\n   * ```ts\n   * Deno.chownSync(\"myFile.txt\", 1000, 1002);\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * Throws Error (not implemented) if executed on Windows.\n   *\n   * @tags allow-write\n   * @category File System\n   *\n   * @param path path to the file\n   * @param uid user id (UID) of the new owner, or `null` for no change\n   * @param gid group id (GID) of the new owner, or `null` for no change\n   */\n  export function chownSync(\n    path: string | URL,\n    uid: number | null,\n    gid: number | null,\n  ): void;\n\n  /**\n   * Options which can be set when using {@linkcode Deno.remove} and\n   * {@linkcode Deno.removeSync}.\n   *\n   * @category File System */\n  export interface RemoveOptions {\n    /** If set to `true`, path will be removed even if it's a non-empty directory.\n     *\n     * @default {false} */\n    recursive?: boolean;\n  }\n\n  /** Removes the named file or directory.\n   *\n   * ```ts\n   * await Deno.remove(\"/path/to/empty_dir/or/file\");\n   * await Deno.remove(\"/path/to/populated_dir/or/file\", { recursive: true });\n   * ```\n   *\n   * Throws error if permission denied, path not found, or path is a non-empty\n   * directory and the `recursive` option isn't set to `true`.\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function remove(\n    path: string | URL,\n    options?: RemoveOptions,\n  ): Promise<void>;\n\n  /** Synchronously removes the named file or directory.\n   *\n   * ```ts\n   * Deno.removeSync(\"/path/to/empty_dir/or/file\");\n   * Deno.removeSync(\"/path/to/populated_dir/or/file\", { recursive: true });\n   * ```\n   *\n   * Throws error if permission denied, path not found, or path is a non-empty\n   * directory and the `recursive` option isn't set to `true`.\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function removeSync(path: string | URL, options?: RemoveOptions): void;\n\n  /** Synchronously renames (moves) `oldpath` to `newpath`. Paths may be files or\n   * directories. If `newpath` already exists and is not a directory,\n   * `renameSync()` replaces it. OS-specific restrictions may apply when\n   * `oldpath` and `newpath` are in different directories.\n   *\n   * ```ts\n   * Deno.renameSync(\"old/path\", \"new/path\");\n   * ```\n   *\n   * On Unix-like OSes, this operation does not follow symlinks at either path.\n   *\n   * It varies between platforms when the operation throws errors, and if so what\n   * they are. It's always an error to rename anything to a non-empty directory.\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function renameSync(\n    oldpath: string | URL,\n    newpath: string | URL,\n  ): void;\n\n  /** Renames (moves) `oldpath` to `newpath`. Paths may be files or directories.\n   * If `newpath` already exists and is not a directory, `rename()` replaces it.\n   * OS-specific restrictions may apply when `oldpath` and `newpath` are in\n   * different directories.\n   *\n   * ```ts\n   * await Deno.rename(\"old/path\", \"new/path\");\n   * ```\n   *\n   * On Unix-like OSes, this operation does not follow symlinks at either path.\n   *\n   * It varies between platforms when the operation throws errors, and if so\n   * what they are. It's always an error to rename anything to a non-empty\n   * directory.\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function rename(\n    oldpath: string | URL,\n    newpath: string | URL,\n  ): Promise<void>;\n\n  /** Asynchronously reads and returns the entire contents of a file as an UTF-8\n   *  decoded string. Reading a directory throws an error.\n   *\n   * ```ts\n   * const data = await Deno.readTextFile(\"hello.txt\");\n   * console.log(data);\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readTextFile(\n    path: string | URL,\n    options?: ReadFileOptions,\n  ): Promise<string>;\n\n  /** Synchronously reads and returns the entire contents of a file as an UTF-8\n   *  decoded string. Reading a directory throws an error.\n   *\n   * ```ts\n   * const data = Deno.readTextFileSync(\"hello.txt\");\n   * console.log(data);\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readTextFileSync(path: string | URL): string;\n\n  /** Reads and resolves to the entire contents of a file as an array of bytes.\n   * `TextDecoder` can be used to transform the bytes to string if required.\n   * Rejects with an error when reading a directory.\n   *\n   * ```ts\n   * const decoder = new TextDecoder(\"utf-8\");\n   * const data = await Deno.readFile(\"hello.txt\");\n   * console.log(decoder.decode(data));\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readFile(\n    path: string | URL,\n    options?: ReadFileOptions,\n  ): Promise<Uint8Array<ArrayBuffer>>;\n\n  /** Synchronously reads and returns the entire contents of a file as an array\n   * of bytes. `TextDecoder` can be used to transform the bytes to string if\n   * required. Throws an error when reading a directory.\n   *\n   * ```ts\n   * const decoder = new TextDecoder(\"utf-8\");\n   * const data = Deno.readFileSync(\"hello.txt\");\n   * console.log(decoder.decode(data));\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readFileSync(path: string | URL): Uint8Array<ArrayBuffer>;\n\n  /** Provides information about a file and is returned by\n   * {@linkcode Deno.stat}, {@linkcode Deno.lstat}, {@linkcode Deno.statSync},\n   * and {@linkcode Deno.lstatSync} or from calling `stat()` and `statSync()`\n   * on an {@linkcode Deno.FsFile} instance.\n   *\n   * @category File System\n   */\n  export interface FileInfo {\n    /** True if this is info for a regular file. Mutually exclusive to\n     * `FileInfo.isDirectory` and `FileInfo.isSymlink`. */\n    isFile: boolean;\n    /** True if this is info for a regular directory. Mutually exclusive to\n     * `FileInfo.isFile` and `FileInfo.isSymlink`. */\n    isDirectory: boolean;\n    /** True if this is info for a symlink. Mutually exclusive to\n     * `FileInfo.isFile` and `FileInfo.isDirectory`. */\n    isSymlink: boolean;\n    /** The size of the file, in bytes. */\n    size: number;\n    /** The last modification time of the file. This corresponds to the `mtime`\n     * field from `stat` on Linux/Mac OS and `ftLastWriteTime` on Windows. This\n     * may not be available on all platforms. */\n    mtime: Date | null;\n    /** The last access time of the file. This corresponds to the `atime`\n     * field from `stat` on Unix and `ftLastAccessTime` on Windows. This may not\n     * be available on all platforms. */\n    atime: Date | null;\n    /** The creation time of the file. This corresponds to the `birthtime`\n     * field from `stat` on Mac/BSD and `ftCreationTime` on Windows. This may\n     * not be available on all platforms. */\n    birthtime: Date | null;\n    /** The last change time of the file. This corresponds to the `ctime`\n     * field from `stat` on Mac/BSD and `ChangeTime` on Windows. This may\n     * not be available on all platforms. */\n    ctime: Date | null;\n    /** ID of the device containing the file. */\n    dev: number;\n    /** Inode number.\n     *\n     * _Linux/Mac OS only._ */\n    ino: number | null;\n    /** The underlying raw `st_mode` bits that contain the standard Unix\n     * permissions for this file/directory.\n     */\n    mode: number | null;\n    /** Number of hard links pointing to this file.\n     *\n     * _Linux/Mac OS only._ */\n    nlink: number | null;\n    /** User ID of the owner of this file.\n     *\n     * _Linux/Mac OS only._ */\n    uid: number | null;\n    /** Group ID of the owner of this file.\n     *\n     * _Linux/Mac OS only._ */\n    gid: number | null;\n    /** Device ID of this file.\n     *\n     * _Linux/Mac OS only._ */\n    rdev: number | null;\n    /** Blocksize for filesystem I/O.\n     *\n     * _Linux/Mac OS only._ */\n    blksize: number | null;\n    /** Number of blocks allocated to the file, in 512-byte units.\n     *\n     * _Linux/Mac OS only._ */\n    blocks: number | null;\n    /**  True if this is info for a block device.\n     *\n     * _Linux/Mac OS only._ */\n    isBlockDevice: boolean | null;\n    /**  True if this is info for a char device.\n     *\n     * _Linux/Mac OS only._ */\n    isCharDevice: boolean | null;\n    /**  True if this is info for a fifo.\n     *\n     * _Linux/Mac OS only._ */\n    isFifo: boolean | null;\n    /**  True if this is info for a socket.\n     *\n     * _Linux/Mac OS only._ */\n    isSocket: boolean | null;\n  }\n\n  /** Resolves to the absolute normalized path, with symbolic links resolved.\n   *\n   * ```ts\n   * // e.g. given /home/alice/file.txt and current directory /home/alice\n   * await Deno.symlink(\"file.txt\", \"symlink_file.txt\");\n   * const realPath = await Deno.realPath(\"./file.txt\");\n   * const realSymLinkPath = await Deno.realPath(\"./symlink_file.txt\");\n   * console.log(realPath);  // outputs \"/home/alice/file.txt\"\n   * console.log(realSymLinkPath);  // outputs \"/home/alice/file.txt\"\n   * ```\n   *\n   * Requires `allow-read` permission for the target path.\n   *\n   * Also requires `allow-read` permission for the `CWD` if the target path is\n   * relative.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function realPath(path: string | URL): Promise<string>;\n\n  /** Synchronously returns absolute normalized path, with symbolic links\n   * resolved.\n   *\n   * ```ts\n   * // e.g. given /home/alice/file.txt and current directory /home/alice\n   * Deno.symlinkSync(\"file.txt\", \"symlink_file.txt\");\n   * const realPath = Deno.realPathSync(\"./file.txt\");\n   * const realSymLinkPath = Deno.realPathSync(\"./symlink_file.txt\");\n   * console.log(realPath);  // outputs \"/home/alice/file.txt\"\n   * console.log(realSymLinkPath);  // outputs \"/home/alice/file.txt\"\n   * ```\n   *\n   * Requires `allow-read` permission for the target path.\n   *\n   * Also requires `allow-read` permission for the `CWD` if the target path is\n   * relative.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function realPathSync(path: string | URL): string;\n\n  /**\n   * Information about a directory entry returned from {@linkcode Deno.readDir}\n   * and {@linkcode Deno.readDirSync}.\n   *\n   * @category File System */\n  export interface DirEntry {\n    /** The file name of the entry. It is just the entity name and does not\n     * include the full path. */\n    name: string;\n    /** True if this is info for a regular file. Mutually exclusive to\n     * `DirEntry.isDirectory` and `DirEntry.isSymlink`. */\n    isFile: boolean;\n    /** True if this is info for a regular directory. Mutually exclusive to\n     * `DirEntry.isFile` and `DirEntry.isSymlink`. */\n    isDirectory: boolean;\n    /** True if this is info for a symlink. Mutually exclusive to\n     * `DirEntry.isFile` and `DirEntry.isDirectory`. */\n    isSymlink: boolean;\n  }\n\n  /** Reads the directory given by `path` and returns an async iterable of\n   * {@linkcode Deno.DirEntry}. The order of entries is not guaranteed.\n   *\n   * ```ts\n   * for await (const dirEntry of Deno.readDir(\"/\")) {\n   *   console.log(dirEntry.name);\n   * }\n   * ```\n   *\n   * Throws error if `path` is not a directory.\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readDir(path: string | URL): AsyncIterable<DirEntry>;\n\n  /** Synchronously reads the directory given by `path` and returns an iterable\n   * of {@linkcode Deno.DirEntry}. The order of entries is not guaranteed.\n   *\n   * ```ts\n   * for (const dirEntry of Deno.readDirSync(\"/\")) {\n   *   console.log(dirEntry.name);\n   * }\n   * ```\n   *\n   * Throws error if `path` is not a directory.\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readDirSync(path: string | URL): IteratorObject<DirEntry>;\n\n  /** Copies the contents and permissions of one file to another specified path,\n   * by default creating a new file if needed, else overwriting. Fails if target\n   * path is a directory or is unwritable.\n   *\n   * ```ts\n   * await Deno.copyFile(\"from.txt\", \"to.txt\");\n   * ```\n   *\n   * Requires `allow-read` permission on `fromPath`.\n   *\n   * Requires `allow-write` permission on `toPath`.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function copyFile(\n    fromPath: string | URL,\n    toPath: string | URL,\n  ): Promise<void>;\n\n  /** Synchronously copies the contents and permissions of one file to another\n   * specified path, by default creating a new file if needed, else overwriting.\n   * Fails if target path is a directory or is unwritable.\n   *\n   * ```ts\n   * Deno.copyFileSync(\"from.txt\", \"to.txt\");\n   * ```\n   *\n   * Requires `allow-read` permission on `fromPath`.\n   *\n   * Requires `allow-write` permission on `toPath`.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function copyFileSync(\n    fromPath: string | URL,\n    toPath: string | URL,\n  ): void;\n\n  /** Resolves to the full path destination of the named symbolic link.\n   *\n   * ```ts\n   * await Deno.symlink(\"./test.txt\", \"./test_link.txt\");\n   * const target = await Deno.readLink(\"./test_link.txt\"); // full path of ./test.txt\n   * ```\n   *\n   * Throws TypeError if called with a hard link.\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readLink(path: string | URL): Promise<string>;\n\n  /** Synchronously returns the full path destination of the named symbolic\n   * link.\n   *\n   * ```ts\n   * Deno.symlinkSync(\"./test.txt\", \"./test_link.txt\");\n   * const target = Deno.readLinkSync(\"./test_link.txt\"); // full path of ./test.txt\n   * ```\n   *\n   * Throws TypeError if called with a hard link.\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function readLinkSync(path: string | URL): string;\n\n  /** Resolves to a {@linkcode Deno.FileInfo} for the specified `path`. If\n   * `path` is a symlink, information for the symlink will be returned instead\n   * of what it points to.\n   *\n   * ```ts\n   * import { assert } from \"jsr:@std/assert\";\n   * const fileInfo = await Deno.lstat(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function lstat(path: string | URL): Promise<FileInfo>;\n\n  /** Synchronously returns a {@linkcode Deno.FileInfo} for the specified\n   * `path`. If `path` is a symlink, information for the symlink will be\n   * returned instead of what it points to.\n   *\n   * ```ts\n   * import { assert } from \"jsr:@std/assert\";\n   * const fileInfo = Deno.lstatSync(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function lstatSync(path: string | URL): FileInfo;\n\n  /** Resolves to a {@linkcode Deno.FileInfo} for the specified `path`. Will\n   * always follow symlinks.\n   *\n   * ```ts\n   * import { assert } from \"jsr:@std/assert\";\n   * const fileInfo = await Deno.stat(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function stat(path: string | URL): Promise<FileInfo>;\n\n  /** Synchronously returns a {@linkcode Deno.FileInfo} for the specified\n   * `path`. Will always follow symlinks.\n   *\n   * ```ts\n   * import { assert } from \"jsr:@std/assert\";\n   * const fileInfo = Deno.statSync(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function statSync(path: string | URL): FileInfo;\n\n  /** Options for writing to a file.\n   *\n   * @category File System\n   */\n  export interface WriteFileOptions {\n    /** If set to `true`, will append to a file instead of overwriting previous\n     * contents.\n     *\n     * @default {false} */\n    append?: boolean;\n    /** Sets the option to allow creating a new file, if one doesn't already\n     * exist at the specified path.\n     *\n     * @default {true} */\n    create?: boolean;\n    /** If set to `true`, no file, directory, or symlink is allowed to exist at\n     * the target location. When createNew is set to `true`, `create` is ignored.\n     *\n     * @default {false} */\n    createNew?: boolean;\n    /** Permissions always applied to file. */\n    mode?: number;\n    /** An abort signal to allow cancellation of the file write operation.\n     *\n     * If the signal becomes aborted the write file operation will be stopped\n     * and the promise returned will be rejected with an {@linkcode AbortError}.\n     */\n    signal?: AbortSignal;\n  }\n\n  /** Write `data` to the given `path`, by default creating a new file if\n   * needed, else overwriting.\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\\n\");\n   * await Deno.writeFile(\"hello1.txt\", data);  // overwrite \"hello1.txt\" or create it\n   * await Deno.writeFile(\"hello2.txt\", data, { create: false });  // only works if \"hello2.txt\" exists\n   * await Deno.writeFile(\"hello3.txt\", data, { mode: 0o777 });  // set permissions on new file\n   * await Deno.writeFile(\"hello4.txt\", data, { append: true });  // add data to the end of the file\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is\n   * `false`.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function writeFile(\n    path: string | URL,\n    data: Uint8Array | ReadableStream<Uint8Array>,\n    options?: WriteFileOptions,\n  ): Promise<void>;\n\n  /** Synchronously write `data` to the given `path`, by default creating a new\n   * file if needed, else overwriting.\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\\n\");\n   * Deno.writeFileSync(\"hello1.txt\", data);  // overwrite \"hello1.txt\" or create it\n   * Deno.writeFileSync(\"hello2.txt\", data, { create: false });  // only works if \"hello2.txt\" exists\n   * Deno.writeFileSync(\"hello3.txt\", data, { mode: 0o777 });  // set permissions on new file\n   * Deno.writeFileSync(\"hello4.txt\", data, { append: true });  // add data to the end of the file\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is\n   * `false`.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function writeFileSync(\n    path: string | URL,\n    data: Uint8Array,\n    options?: WriteFileOptions,\n  ): void;\n\n  /** Write string `data` to the given `path`, by default creating a new file if\n   * needed, else overwriting.\n   *\n   * ```ts\n   * await Deno.writeTextFile(\"hello1.txt\", \"Hello world\\n\");  // overwrite \"hello1.txt\" or create it\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is\n   * `false`.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function writeTextFile(\n    path: string | URL,\n    data: string | ReadableStream<string>,\n    options?: WriteFileOptions,\n  ): Promise<void>;\n\n  /** Synchronously write string `data` to the given `path`, by default creating\n   * a new file if needed, else overwriting.\n   *\n   * ```ts\n   * Deno.writeTextFileSync(\"hello1.txt\", \"Hello world\\n\");  // overwrite \"hello1.txt\" or create it\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is\n   * `false`.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function writeTextFileSync(\n    path: string | URL,\n    data: string,\n    options?: WriteFileOptions,\n  ): void;\n\n  /** Truncates (or extends) the specified file, to reach the specified `len`.\n   * If `len` is not specified then the entire file contents are truncated.\n   *\n   * ### Truncate the entire file\n   * ```ts\n   * await Deno.truncate(\"my_file.txt\");\n   * ```\n   *\n   * ### Truncate part of the file\n   *\n   * ```ts\n   * const file = await Deno.makeTempFile();\n   * await Deno.writeTextFile(file, \"Hello World\");\n   * await Deno.truncate(file, 7);\n   * const data = await Deno.readFile(file);\n   * console.log(new TextDecoder().decode(data));  // \"Hello W\"\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function truncate(name: string, len?: number): Promise<void>;\n\n  /** Synchronously truncates (or extends) the specified file, to reach the\n   * specified `len`. If `len` is not specified then the entire file contents\n   * are truncated.\n   *\n   * ### Truncate the entire file\n   *\n   * ```ts\n   * Deno.truncateSync(\"my_file.txt\");\n   * ```\n   *\n   * ### Truncate part of the file\n   *\n   * ```ts\n   * const file = Deno.makeTempFileSync();\n   * Deno.writeFileSync(file, new TextEncoder().encode(\"Hello World\"));\n   * Deno.truncateSync(file, 7);\n   * const data = Deno.readFileSync(file);\n   * console.log(new TextDecoder().decode(data));\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function truncateSync(name: string, len?: number): void;\n\n  /**\n   * Additional information for FsEvent objects with the \"other\" kind.\n   *\n   * - `\"rescan\"`: rescan notices indicate either a lapse in the events or a\n   *    change in the filesystem such that events received so far can no longer\n   *    be relied on to represent the state of the filesystem now. An\n   *    application that simply reacts to file changes may not care about this.\n   *    An application that keeps an in-memory representation of the filesystem\n   *    will need to care, and will need to refresh that representation directly\n   *    from the filesystem.\n   *\n   * @category File System\n   */\n  export type FsEventFlag = 'rescan';\n\n  /**\n   * Represents a unique file system event yielded by a\n   * {@linkcode Deno.FsWatcher}.\n   *\n   * @category File System */\n  export interface FsEvent {\n    /** The kind/type of the file system event. */\n    kind:\n      | 'any'\n      | 'access'\n      | 'create'\n      | 'modify'\n      | 'rename'\n      | 'remove'\n      | 'other';\n    /** An array of paths that are associated with the file system event. */\n    paths: string[];\n    /** Any additional flags associated with the event. */\n    flag?: FsEventFlag;\n  }\n\n  /**\n   * Returned by {@linkcode Deno.watchFs}. It is an async iterator yielding up\n   * system events. To stop watching the file system by calling `.close()`\n   * method.\n   *\n   * @category File System\n   */\n  export interface FsWatcher extends AsyncIterable<FsEvent>, Disposable {\n    /** Stops watching the file system and closes the watcher resource. */\n    close(): void;\n    /**\n     * Stops watching the file system and closes the watcher resource.\n     */\n    return?(value?: any): Promise<IteratorResult<FsEvent>>;\n    [Symbol.asyncIterator](): AsyncIterableIterator<FsEvent>;\n  }\n\n  /** Watch for file system events against one or more `paths`, which can be\n   * files or directories. These paths must exist already. One user action (e.g.\n   * `touch test.file`) can generate multiple file system events. Likewise,\n   * one user action can result in multiple file paths in one event (e.g. `mv\n   * old_name.txt new_name.txt`).\n   *\n   * The recursive option is `true` by default and, for directories, will watch\n   * the specified directory and all sub directories.\n   *\n   * Note that the exact ordering of the events can vary between operating\n   * systems.\n   *\n   * ```ts\n   * const watcher = Deno.watchFs(\"/\");\n   * for await (const event of watcher) {\n   *    console.log(\">>>> event\", event);\n   *    // { kind: \"create\", paths: [ \"/foo.txt\" ] }\n   * }\n   * ```\n   *\n   * Call `watcher.close()` to stop watching.\n   *\n   * ```ts\n   * const watcher = Deno.watchFs(\"/\");\n   *\n   * setTimeout(() => {\n   *   watcher.close();\n   * }, 5000);\n   *\n   * for await (const event of watcher) {\n   *    console.log(\">>>> event\", event);\n   * }\n   * ```\n   *\n   * Requires `allow-read` permission.\n   *\n   * @tags allow-read\n   * @category File System\n   */\n  export function watchFs(\n    paths: string | string[],\n    options?: { recursive: boolean },\n  ): FsWatcher;\n\n  /** Operating signals which can be listened for or sent to sub-processes. What\n   * signals and what their standard behaviors are OS dependent.\n   *\n   * @category Runtime */\n  export type Signal =\n    | 'SIGABRT'\n    | 'SIGALRM'\n    | 'SIGBREAK'\n    | 'SIGBUS'\n    | 'SIGCHLD'\n    | 'SIGCONT'\n    | 'SIGEMT'\n    | 'SIGFPE'\n    | 'SIGHUP'\n    | 'SIGILL'\n    | 'SIGINFO'\n    | 'SIGINT'\n    | 'SIGIO'\n    | 'SIGPOLL'\n    | 'SIGUNUSED'\n    | 'SIGKILL'\n    | 'SIGPIPE'\n    | 'SIGPROF'\n    | 'SIGPWR'\n    | 'SIGQUIT'\n    | 'SIGSEGV'\n    | 'SIGSTKFLT'\n    | 'SIGSTOP'\n    | 'SIGSYS'\n    | 'SIGTERM'\n    | 'SIGTRAP'\n    | 'SIGTSTP'\n    | 'SIGTTIN'\n    | 'SIGTTOU'\n    | 'SIGURG'\n    | 'SIGUSR1'\n    | 'SIGUSR2'\n    | 'SIGVTALRM'\n    | 'SIGWINCH'\n    | 'SIGXCPU'\n    | 'SIGXFSZ';\n\n  /** Registers the given function as a listener of the given signal event.\n   *\n   * ```ts\n   * Deno.addSignalListener(\n   *   \"SIGTERM\",\n   *   () => {\n   *     console.log(\"SIGTERM!\")\n   *   }\n   * );\n   * ```\n   *\n   * _Note_: On Windows only `\"SIGINT\"` (CTRL+C) and `\"SIGBREAK\"` (CTRL+Break)\n   * are supported.\n   *\n   * @category Runtime\n   */\n  export function addSignalListener(signal: Signal, handler: () => void): void;\n\n  /** Removes the given signal listener that has been registered with\n   * {@linkcode Deno.addSignalListener}.\n   *\n   * ```ts\n   * const listener = () => {\n   *   console.log(\"SIGTERM!\")\n   * };\n   * Deno.addSignalListener(\"SIGTERM\", listener);\n   * Deno.removeSignalListener(\"SIGTERM\", listener);\n   * ```\n   *\n   * _Note_: On Windows only `\"SIGINT\"` (CTRL+C) and `\"SIGBREAK\"` (CTRL+Break)\n   * are supported.\n   *\n   * @category Runtime\n   */\n  export function removeSignalListener(\n    signal: Signal,\n    handler: () => void,\n  ): void;\n\n  /** Create a child process.\n   *\n   * If any stdio options are not set to `\"piped\"`, accessing the corresponding\n   * field on the `Command` or its `CommandOutput` will throw a `TypeError`.\n   *\n   * If `stdin` is set to `\"piped\"`, the `stdin` {@linkcode WritableStream}\n   * needs to be closed manually.\n   *\n   * `Command` acts as a builder. Each call to {@linkcode Command.spawn} or\n   * {@linkcode Command.output} will spawn a new subprocess.\n   *\n   * @example Spawn a subprocess and pipe the output to a file\n   *\n   * ```ts\n   * const command = new Deno.Command(Deno.execPath(), {\n   *   args: [\n   *     \"eval\",\n   *     \"console.log('Hello World')\",\n   *   ],\n   *   stdin: \"piped\",\n   *   stdout: \"piped\",\n   * });\n   * const child = command.spawn();\n   *\n   * // open a file and pipe the subprocess output to it.\n   * child.stdout.pipeTo(\n   *   Deno.openSync(\"output\", { write: true, create: true }).writable,\n   * );\n   *\n   * // manually close stdin\n   * child.stdin.close();\n   * const status = await child.status;\n   * ```\n   *\n   * @example Spawn a subprocess and collect its output\n   *\n   * ```ts\n   * const command = new Deno.Command(Deno.execPath(), {\n   *   args: [\n   *     \"eval\",\n   *     \"console.log('hello'); console.error('world')\",\n   *   ],\n   * });\n   * const { code, stdout, stderr } = await command.output();\n   * console.assert(code === 0);\n   * console.assert(\"hello\\n\" === new TextDecoder().decode(stdout));\n   * console.assert(\"world\\n\" === new TextDecoder().decode(stderr));\n   * ```\n   *\n   * @example Spawn a subprocess and collect its output synchronously\n   *\n   * ```ts\n   * const command = new Deno.Command(Deno.execPath(), {\n   *   args: [\n   *     \"eval\",\n   *     \"console.log('hello'); console.error('world')\",\n   *   ],\n   * });\n   * const { code, stdout, stderr } = command.outputSync();\n   * console.assert(code === 0);\n   * console.assert(\"hello\\n\" === new TextDecoder().decode(stdout));\n   * console.assert(\"world\\n\" === new TextDecoder().decode(stderr));\n   * ```\n   *\n   * @tags allow-run\n   * @category Subprocess\n   */\n  export class Command {\n    constructor(command: string | URL, options?: CommandOptions);\n    /**\n     * Executes the {@linkcode Deno.Command}, waiting for it to finish and\n     * collecting all of its output.\n     *\n     * Will throw an error if `stdin: \"piped\"` is set.\n     *\n     * If options `stdout` or `stderr` are not set to `\"piped\"`, accessing the\n     * corresponding field on {@linkcode Deno.CommandOutput} will throw a `TypeError`.\n     */\n    output(): Promise<CommandOutput>;\n    /**\n     * Synchronously executes the {@linkcode Deno.Command}, waiting for it to\n     * finish and collecting all of its output.\n     *\n     * Will throw an error if `stdin: \"piped\"` is set.\n     *\n     * If options `stdout` or `stderr` are not set to `\"piped\"`, accessing the\n     * corresponding field on {@linkcode Deno.CommandOutput} will throw a `TypeError`.\n     */\n    outputSync(): CommandOutput;\n    /**\n     * Spawns a streamable subprocess, allowing to use the other methods.\n     */\n    spawn(): ChildProcess;\n  }\n\n  /**\n   * The interface for handling a child process returned from\n   * {@linkcode Deno.Command.spawn}.\n   *\n   * @category Subprocess\n   */\n  export class ChildProcess implements AsyncDisposable {\n    get stdin(): WritableStream<Uint8Array<ArrayBufferLike>>;\n    get stdout(): SubprocessReadableStream;\n    get stderr(): SubprocessReadableStream;\n    readonly pid: number;\n    /** Get the status of the child. */\n    readonly status: Promise<CommandStatus>;\n\n    /** Waits for the child to exit completely, returning all its output and\n     * status. */\n    output(): Promise<CommandOutput>;\n    /** Kills the process with given {@linkcode Deno.Signal}.\n     *\n     * Defaults to `SIGTERM` if no signal is provided.\n     *\n     * @param [signo=\"SIGTERM\"]\n     */\n    kill(signo?: Signal): void;\n\n    /** Ensure that the status of the child process prevents the Deno process\n     * from exiting. */\n    ref(): void;\n    /** Ensure that the status of the child process does not block the Deno\n     * process from exiting. */\n    unref(): void;\n\n    [Symbol.asyncDispose](): Promise<void>;\n  }\n\n  /**\n   * The interface for stdout and stderr streams for child process returned from\n   * {@linkcode Deno.Command.spawn}.\n   *\n   * @category Subprocess\n   */\n  export interface SubprocessReadableStream\n    extends ReadableStream<Uint8Array<ArrayBuffer>> {\n    /**\n     * Reads the stream to completion. It returns a promise that resolves with\n     * an `ArrayBuffer`.\n     */\n    arrayBuffer(): Promise<ArrayBuffer>;\n    /**\n     * Reads the stream to completion. It returns a promise that resolves with\n     * a `Uint8Array`.\n     */\n    bytes(): Promise<Uint8Array<ArrayBuffer>>;\n    /**\n     * Reads the stream to completion. It returns a promise that resolves with\n     * the result of parsing the body text as JSON.\n     */\n    json(): Promise<any>;\n    /**\n     * Reads the stream to completion. It returns a promise that resolves with\n     * a `USVString` (text).\n     */\n    text(): Promise<string>;\n  }\n\n  /**\n   * Options which can be set when calling {@linkcode Deno.Command}.\n   *\n   * @category Subprocess\n   */\n  export interface CommandOptions {\n    /** Arguments to pass to the process. */\n    args?: string[];\n    /**\n     * The working directory of the process.\n     *\n     * If not specified, the `cwd` of the parent process is used.\n     */\n    cwd?: string | URL;\n    /**\n     * Clear environmental variables from parent process.\n     *\n     * Doesn't guarantee that only `env` variables are present, as the OS may\n     * set environmental variables for processes.\n     *\n     * @default {false}\n     */\n    clearEnv?: boolean;\n    /** Environmental variables to pass to the subprocess. */\n    env?: Record<string, string>;\n    /**\n     * Sets the child process’s user ID. This translates to a setuid call in the\n     * child process. Failure in the set uid call will cause the spawn to fail.\n     */\n    uid?: number;\n    /** Similar to `uid`, but sets the group ID of the child process. */\n    gid?: number;\n    /**\n     * An {@linkcode AbortSignal} that allows closing the process using the\n     * corresponding {@linkcode AbortController} by sending the process a\n     * SIGTERM signal.\n     *\n     * Not supported in {@linkcode Deno.Command.outputSync}.\n     */\n    signal?: AbortSignal;\n\n    /** How `stdin` of the spawned process should be handled.\n     *\n     * Defaults to `\"inherit\"` for `output` & `outputSync`,\n     * and `\"inherit\"` for `spawn`. */\n    stdin?: 'piped' | 'inherit' | 'null';\n    /** How `stdout` of the spawned process should be handled.\n     *\n     * Defaults to `\"piped\"` for `output` & `outputSync`,\n     * and `\"inherit\"` for `spawn`. */\n    stdout?: 'piped' | 'inherit' | 'null';\n    /** How `stderr` of the spawned process should be handled.\n     *\n     * Defaults to `\"piped\"` for `output` & `outputSync`,\n     * and `\"inherit\"` for `spawn`. */\n    stderr?: 'piped' | 'inherit' | 'null';\n\n    /** Skips quoting and escaping of the arguments on windows. This option\n     * is ignored on non-windows platforms.\n     *\n     * @default {false} */\n    windowsRawArguments?: boolean;\n\n    /** Whether to detach the spawned process from the current process.\n     * This allows the spawned process to continue running after the current\n     * process exits.\n     *\n     * Note: In order to allow the current process to exit, you need to ensure\n     * you call `unref()` on the child process.\n     *\n     * In addition, the stdio streams – if inherited or piped – may keep the\n     * current process from exiting until the streams are closed.\n     *\n     * @default {false}\n     */\n    detached?: boolean;\n  }\n\n  /**\n   * @category Subprocess\n   */\n  export interface CommandStatus {\n    /** If the child process exits with a 0 status code, `success` will be set\n     * to `true`, otherwise `false`. */\n    success: boolean;\n    /** The exit code of the child process. */\n    code: number;\n    /** The signal associated with the child process. */\n    signal: Signal | null;\n  }\n\n  /**\n   * The interface returned from calling {@linkcode Deno.Command.output} or\n   * {@linkcode Deno.Command.outputSync} which represents the result of spawning the\n   * child process.\n   *\n   * @category Subprocess\n   */\n  export interface CommandOutput extends CommandStatus {\n    /** The buffered output from the child process' `stdout`. */\n    readonly stdout: Uint8Array<ArrayBuffer>;\n    /** The buffered output from the child process' `stderr`. */\n    readonly stderr: Uint8Array<ArrayBuffer>;\n  }\n\n  /** Option which can be specified when performing {@linkcode Deno.inspect}.\n   *\n   * @category I/O */\n  export interface InspectOptions {\n    /** Stylize output with ANSI colors.\n     *\n     * @default {false} */\n    colors?: boolean;\n    /** Try to fit more than one entry of a collection on the same line.\n     *\n     * @default {true} */\n    compact?: boolean;\n    /** Traversal depth for nested objects.\n     *\n     * @default {4} */\n    depth?: number;\n    /** The maximum length for an inspection to take up a single line.\n     *\n     * @default {80} */\n    breakLength?: number;\n    /** Whether or not to escape sequences.\n     *\n     * @default {true} */\n    escapeSequences?: boolean;\n    /** The maximum number of iterable entries to print.\n     *\n     * @default {100} */\n    iterableLimit?: number;\n    /** Show a Proxy's target and handler.\n     *\n     * @default {false} */\n    showProxy?: boolean;\n    /** Sort Object, Set and Map entries by key.\n     *\n     * @default {false} */\n    sorted?: boolean;\n    /** Add a trailing comma for multiline collections.\n     *\n     * @default {false} */\n    trailingComma?: boolean;\n    /** Evaluate the result of calling getters.\n     *\n     * @default {false} */\n    getters?: boolean;\n    /** Show an object's non-enumerable properties.\n     *\n     * @default {false} */\n    showHidden?: boolean;\n    /** The maximum length of a string before it is truncated with an\n     * ellipsis. */\n    strAbbreviateSize?: number;\n  }\n\n  /** Converts the input into a string that has the same format as printed by\n   * `console.log()`.\n   *\n   * ```ts\n   * const obj = {\n   *   a: 10,\n   *   b: \"hello\",\n   * };\n   * const objAsString = Deno.inspect(obj); // { a: 10, b: \"hello\" }\n   * console.log(obj);  // prints same value as objAsString, e.g. { a: 10, b: \"hello\" }\n   * ```\n   *\n   * A custom inspect functions can be registered on objects, via the symbol\n   * `Symbol.for(\"Deno.customInspect\")`, to control and customize the output\n   * of `inspect()` or when using `console` logging:\n   *\n   * ```ts\n   * class A {\n   *   x = 10;\n   *   y = \"hello\";\n   *   [Symbol.for(\"Deno.customInspect\")]() {\n   *     return `x=${this.x}, y=${this.y}`;\n   *   }\n   * }\n   *\n   * const inStringFormat = Deno.inspect(new A()); // \"x=10, y=hello\"\n   * console.log(inStringFormat);  // prints \"x=10, y=hello\"\n   * ```\n   *\n   * A depth can be specified by using the `depth` option:\n   *\n   * ```ts\n   * Deno.inspect({a: {b: {c: {d: 'hello'}}}}, {depth: 2}); // { a: { b: [Object] } }\n   * ```\n   *\n   * @category I/O\n   */\n  export function inspect(value: unknown, options?: InspectOptions): string;\n\n  /** The name of a privileged feature which needs permission.\n   *\n   * @category Permissions\n   */\n  export type PermissionName =\n    | 'run'\n    | 'read'\n    | 'write'\n    | 'net'\n    | 'env'\n    | 'sys'\n    | 'ffi';\n\n  /** The current status of the permission:\n   *\n   * - `\"granted\"` - the permission has been granted.\n   * - `\"denied\"` - the permission has been explicitly denied.\n   * - `\"prompt\"` - the permission has not explicitly granted nor denied.\n   *\n   * @category Permissions\n   */\n  export type PermissionState = 'granted' | 'denied' | 'prompt';\n\n  /** The permission descriptor for the `allow-run` and `deny-run` permissions, which controls\n   * access to what sub-processes can be executed by Deno. The option `command`\n   * allows scoping the permission to a specific executable.\n   *\n   * **Warning, in practice, `allow-run` is effectively the same as `allow-all`\n   * in the sense that malicious code could execute any arbitrary code on the\n   * host.**\n   *\n   * @category Permissions */\n  export interface RunPermissionDescriptor {\n    name: 'run';\n    /** An `allow-run` or `deny-run` permission can be scoped to a specific executable,\n     * which would be relative to the start-up CWD of the Deno CLI. */\n    command?: string | URL;\n  }\n\n  /** The permission descriptor for the `allow-read` and `deny-read` permissions, which controls\n   * access to reading resources from the local host. The option `path` allows\n   * scoping the permission to a specific path (and if the path is a directory\n   * any sub paths).\n   *\n   * Permission granted under `allow-read` only allows runtime code to attempt\n   * to read, the underlying operating system may apply additional permissions.\n   *\n   * @category Permissions */\n  export interface ReadPermissionDescriptor {\n    name: 'read';\n    /** An `allow-read` or `deny-read` permission can be scoped to a specific path (and if\n     * the path is a directory, any sub paths). */\n    path?: string | URL;\n  }\n\n  /** The permission descriptor for the `allow-write` and `deny-write` permissions, which\n   * controls access to writing to resources from the local host. The option\n   * `path` allow scoping the permission to a specific path (and if the path is\n   * a directory any sub paths).\n   *\n   * Permission granted under `allow-write` only allows runtime code to attempt\n   * to write, the underlying operating system may apply additional permissions.\n   *\n   * @category Permissions */\n  export interface WritePermissionDescriptor {\n    name: 'write';\n    /** An `allow-write` or `deny-write` permission can be scoped to a specific path (and if\n     * the path is a directory, any sub paths). */\n    path?: string | URL;\n  }\n\n  /** The permission descriptor for the `allow-net` and `deny-net` permissions, which controls\n   * access to opening network ports and connecting to remote hosts via the\n   * network. The option `host` allows scoping the permission for outbound\n   * connection to a specific host and port.\n   *\n   * @category Permissions */\n  export interface NetPermissionDescriptor {\n    name: 'net';\n    /** Optional host string of the form `\"<hostname>[:<port>]\"`. Examples:\n     *\n     *      \"github.com\"\n     *      \"deno.land:8080\"\n     */\n    host?: string;\n  }\n\n  /** The permission descriptor for the `allow-env` and `deny-env` permissions, which controls\n   * access to being able to read and write to the process environment variables\n   * as well as access other information about the environment. The option\n   * `variable` allows scoping the permission to a specific environment\n   * variable.\n   *\n   * @category Permissions */\n  export interface EnvPermissionDescriptor {\n    name: 'env';\n    /** Optional environment variable name (e.g. `PATH`). */\n    variable?: string;\n  }\n\n  /** The permission descriptor for the `allow-sys` and `deny-sys` permissions, which controls\n   * access to sensitive host system information, which malicious code might\n   * attempt to exploit. The option `kind` allows scoping the permission to a\n   * specific piece of information.\n   *\n   * @category Permissions */\n  export interface SysPermissionDescriptor {\n    name: 'sys';\n    /** The specific information to scope the permission to. */\n    kind?:\n      | 'loadavg'\n      | 'hostname'\n      | 'systemMemoryInfo'\n      | 'networkInterfaces'\n      | 'osRelease'\n      | 'osUptime'\n      | 'uid'\n      | 'gid'\n      | 'username'\n      | 'cpus'\n      | 'homedir'\n      | 'statfs'\n      | 'getPriority'\n      | 'setPriority';\n  }\n\n  /** The permission descriptor for the `allow-ffi` and `deny-ffi` permissions, which controls\n   * access to loading _foreign_ code and interfacing with it via the\n   * [Foreign Function Interface API](https://docs.deno.com/runtime/manual/runtime/ffi_api)\n   * available in Deno.  The option `path` allows scoping the permission to a\n   * specific path on the host.\n   *\n   * @category Permissions */\n  export interface FfiPermissionDescriptor {\n    name: 'ffi';\n    /** Optional path on the local host to scope the permission to. */\n    path?: string | URL;\n  }\n\n  /** The permission descriptor for the `allow-import` and `deny-import` permissions, which controls\n   * access to importing from remote hosts via the network. The option `host` allows scoping the\n   * permission for outbound connection to a specific host and port.\n   *\n   * @category Permissions */\n  export interface ImportPermissionDescriptor {\n    name: 'import';\n    /** Optional host string of the form `\"<hostname>[:<port>]\"`. Examples:\n     *\n     *      \"github.com\"\n     *      \"deno.land:8080\"\n     */\n    host?: string;\n  }\n\n  /** Permission descriptors which define a permission and can be queried,\n   * requested, or revoked.\n   *\n   * View the specifics of the individual descriptors for more information about\n   * each permission kind.\n   *\n   * @category Permissions\n   */\n  export type PermissionDescriptor =\n    | RunPermissionDescriptor\n    | ReadPermissionDescriptor\n    | WritePermissionDescriptor\n    | NetPermissionDescriptor\n    | EnvPermissionDescriptor\n    | SysPermissionDescriptor\n    | FfiPermissionDescriptor\n    | ImportPermissionDescriptor;\n\n  /** The interface which defines what event types are supported by\n   * {@linkcode PermissionStatus} instances.\n   *\n   * @category Permissions */\n  export interface PermissionStatusEventMap {\n    change: Event;\n  }\n\n  /** An {@linkcode EventTarget} returned from the {@linkcode Deno.permissions}\n   * API which can provide updates to any state changes of the permission.\n   *\n   * @category Permissions */\n  export class PermissionStatus extends EventTarget {\n    // deno-lint-ignore no-explicit-any\n    onchange: ((this: PermissionStatus, ev: Event) => any) | null;\n    readonly state: PermissionState;\n    /**\n     * Describes if permission is only granted partially, eg. an access\n     * might be granted to \"/foo\" directory, but denied for \"/foo/bar\".\n     * In such case this field will be set to `true` when querying for\n     * read permissions of \"/foo\" directory.\n     */\n    readonly partial: boolean;\n    addEventListener<K extends keyof PermissionStatusEventMap>(\n      type: K,\n      listener: (\n        this: PermissionStatus,\n        ev: PermissionStatusEventMap[K],\n      ) => any,\n      options?: boolean | AddEventListenerOptions,\n    ): void;\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ): void;\n    removeEventListener<K extends keyof PermissionStatusEventMap>(\n      type: K,\n      listener: (\n        this: PermissionStatus,\n        ev: PermissionStatusEventMap[K],\n      ) => any,\n      options?: boolean | EventListenerOptions,\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions,\n    ): void;\n  }\n\n  /**\n   * Deno's permission management API.\n   *\n   * The class which provides the interface for the {@linkcode Deno.permissions}\n   * global instance and is based on the web platform\n   * [Permissions API](https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API),\n   * though some proposed parts of the API which are useful in a server side\n   * runtime context were removed or abandoned in the web platform specification\n   * which is why it was chosen to locate it in the {@linkcode Deno} namespace\n   * instead.\n   *\n   * By default, if the `stdin`/`stdout` is TTY for the Deno CLI (meaning it can\n   * send and receive text), then the CLI will prompt the user to grant\n   * permission when an un-granted permission is requested. This behavior can\n   * be changed by using the `--no-prompt` command at startup. When prompting\n   * the CLI will request the narrowest permission possible, potentially making\n   * it annoying to the user. The permissions APIs allow the code author to\n   * request a wider set of permissions at one time in order to provide a better\n   * user experience.\n   *\n   * @category Permissions */\n  export class Permissions {\n    /** Resolves to the current status of a permission.\n     *\n     * Note, if the permission is already granted, `request()` will not prompt\n     * the user again, therefore `query()` is only necessary if you are going\n     * to react differently existing permissions without wanting to modify them\n     * or prompt the user to modify them.\n     *\n     * ```ts\n     * const status = await Deno.permissions.query({ name: \"read\", path: \"/etc\" });\n     * console.log(status.state);\n     * ```\n     */\n    query(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Returns the current status of a permission.\n     *\n     * Note, if the permission is already granted, `request()` will not prompt\n     * the user again, therefore `querySync()` is only necessary if you are going\n     * to react differently existing permissions without wanting to modify them\n     * or prompt the user to modify them.\n     *\n     * ```ts\n     * const status = Deno.permissions.querySync({ name: \"read\", path: \"/etc\" });\n     * console.log(status.state);\n     * ```\n     */\n    querySync(desc: PermissionDescriptor): PermissionStatus;\n\n    /** Revokes a permission, and resolves to the state of the permission.\n     *\n     * ```ts\n     * import { assert } from \"jsr:@std/assert\";\n     *\n     * const status = await Deno.permissions.revoke({ name: \"run\" });\n     * assert(status.state !== \"granted\")\n     * ```\n     */\n    revoke(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Revokes a permission, and returns the state of the permission.\n     *\n     * ```ts\n     * import { assert } from \"jsr:@std/assert\";\n     *\n     * const status = Deno.permissions.revokeSync({ name: \"run\" });\n     * assert(status.state !== \"granted\")\n     * ```\n     */\n    revokeSync(desc: PermissionDescriptor): PermissionStatus;\n\n    /** Requests the permission, and resolves to the state of the permission.\n     *\n     * If the permission is already granted, the user will not be prompted to\n     * grant the permission again.\n     *\n     * ```ts\n     * const status = await Deno.permissions.request({ name: \"env\" });\n     * if (status.state === \"granted\") {\n     *   console.log(\"'env' permission is granted.\");\n     * } else {\n     *   console.log(\"'env' permission is denied.\");\n     * }\n     * ```\n     */\n    request(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Requests the permission, and returns the state of the permission.\n     *\n     * If the permission is already granted, the user will not be prompted to\n     * grant the permission again.\n     *\n     * ```ts\n     * const status = Deno.permissions.requestSync({ name: \"env\" });\n     * if (status.state === \"granted\") {\n     *   console.log(\"'env' permission is granted.\");\n     * } else {\n     *   console.log(\"'env' permission is denied.\");\n     * }\n     * ```\n     */\n    requestSync(desc: PermissionDescriptor): PermissionStatus;\n  }\n\n  /** Deno's permission management API.\n   *\n   * It is a singleton instance of the {@linkcode Permissions} object and is\n   * based on the web platform\n   * [Permissions API](https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API),\n   * though some proposed parts of the API which are useful in a server side\n   * runtime context were removed or abandoned in the web platform specification\n   * which is why it was chosen to locate it in the {@linkcode Deno} namespace\n   * instead.\n   *\n   * By default, if the `stdin`/`stdout` is TTY for the Deno CLI (meaning it can\n   * send and receive text), then the CLI will prompt the user to grant\n   * permission when an un-granted permission is requested. This behavior can\n   * be changed by using the `--no-prompt` command at startup. When prompting\n   * the CLI will request the narrowest permission possible, potentially making\n   * it annoying to the user. The permissions APIs allow the code author to\n   * request a wider set of permissions at one time in order to provide a better\n   * user experience.\n   *\n   * Requesting already granted permissions will not prompt the user and will\n   * return that the permission was granted.\n   *\n   * ### Querying\n   *\n   * ```ts\n   * const status = await Deno.permissions.query({ name: \"read\", path: \"/etc\" });\n   * console.log(status.state);\n   * ```\n   *\n   * ```ts\n   * const status = Deno.permissions.querySync({ name: \"read\", path: \"/etc\" });\n   * console.log(status.state);\n   * ```\n   *\n   * ### Revoking\n   *\n   * ```ts\n   * import { assert } from \"jsr:@std/assert\";\n   *\n   * const status = await Deno.permissions.revoke({ name: \"run\" });\n   * assert(status.state !== \"granted\")\n   * ```\n   *\n   * ```ts\n   * import { assert } from \"jsr:@std/assert\";\n   *\n   * const status = Deno.permissions.revokeSync({ name: \"run\" });\n   * assert(status.state !== \"granted\")\n   * ```\n   *\n   * ### Requesting\n   *\n   * ```ts\n   * const status = await Deno.permissions.request({ name: \"env\" });\n   * if (status.state === \"granted\") {\n   *   console.log(\"'env' permission is granted.\");\n   * } else {\n   *   console.log(\"'env' permission is denied.\");\n   * }\n   * ```\n   *\n   * ```ts\n   * const status = Deno.permissions.requestSync({ name: \"env\" });\n   * if (status.state === \"granted\") {\n   *   console.log(\"'env' permission is granted.\");\n   * } else {\n   *   console.log(\"'env' permission is denied.\");\n   * }\n   * ```\n   *\n   * @category Permissions\n   */\n  export const permissions: Permissions;\n\n  /** Information related to the build of the current Deno runtime.\n   *\n   * Users are discouraged from code branching based on this information, as\n   * assumptions about what is available in what build environment might change\n   * over time. Developers should specifically sniff out the features they\n   * intend to use.\n   *\n   * The intended use for the information is for logging and debugging purposes.\n   *\n   * @category Runtime\n   */\n  export const build: {\n    /** The [LLVM](https://llvm.org/) target triple, which is the combination\n     * of `${arch}-${vendor}-${os}` and represent the specific build target that\n     * the current runtime was built for. */\n    target: string;\n    /** Instruction set architecture that the Deno CLI was built for. */\n    arch: 'x86_64' | 'aarch64';\n    /** The operating system that the Deno CLI was built for. `\"darwin\"` is\n     * also known as OSX or MacOS. */\n    os:\n      | 'darwin'\n      | 'linux'\n      | 'android'\n      | 'windows'\n      | 'freebsd'\n      | 'netbsd'\n      | 'aix'\n      | 'solaris'\n      | 'illumos';\n    standalone: boolean;\n    /** The computer vendor that the Deno CLI was built for. */\n    vendor: string;\n    /** Optional environment flags that were set for this build of Deno CLI. */\n    env?: string;\n  };\n\n  /** Version information related to the current Deno CLI runtime environment.\n   *\n   * Users are discouraged from code branching based on this information, as\n   * assumptions about what is available in what build environment might change\n   * over time. Developers should specifically sniff out the features they\n   * intend to use.\n   *\n   * The intended use for the information is for logging and debugging purposes.\n   *\n   * @category Runtime\n   */\n  export const version: {\n    /** Deno CLI's version. For example: `\"1.26.0\"`. */\n    deno: string;\n    /** The V8 version used by Deno. For example: `\"10.7.100.0\"`.\n     *\n     * V8 is the underlying JavaScript runtime platform that Deno is built on\n     * top of. */\n    v8: string;\n    /** The TypeScript version used by Deno. For example: `\"4.8.3\"`.\n     *\n     * A version of the TypeScript type checker and language server is built-in\n     * to the Deno CLI. */\n    typescript: string;\n  };\n\n  /** Returns the script arguments to the program.\n   *\n   * Give the following command line invocation of Deno:\n   *\n   * ```sh\n   * deno run --allow-read https://examples.deno.land/command-line-arguments.ts Sushi\n   * ```\n   *\n   * Then `Deno.args` will contain:\n   *\n   * ```ts\n   * [ \"Sushi\" ]\n   * ```\n   *\n   * If you are looking for a structured way to parse arguments, there is\n   * [`parseArgs()`](https://jsr.io/@std/cli/doc/parse-args/~/parseArgs) from\n   * the Deno Standard Library.\n   *\n   * @category Runtime\n   */\n  export const args: string[];\n\n  /** The URL of the entrypoint module entered from the command-line. It\n   * requires read permission to the CWD.\n   *\n   * Also see {@linkcode ImportMeta} for other related information.\n   *\n   * @tags allow-read\n   * @category Runtime\n   */\n  export const mainModule: string;\n\n  /** Options that can be used with {@linkcode symlink} and\n   * {@linkcode symlinkSync}.\n   *\n   * @category File System */\n  export interface SymlinkOptions {\n    /** Specify the symbolic link type as file, directory or NTFS junction. This\n     * option only applies to Windows and is ignored on other operating systems. */\n    type: 'file' | 'dir' | 'junction';\n  }\n\n  /**\n   * Creates `newpath` as a symbolic link to `oldpath`.\n   *\n   * The `options.type` parameter can be set to `\"file\"`, `\"dir\"` or `\"junction\"`.\n   * This argument is only available on Windows and ignored on other platforms.\n   *\n   * ```ts\n   * await Deno.symlink(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires full `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function symlink(\n    oldpath: string | URL,\n    newpath: string | URL,\n    options?: SymlinkOptions,\n  ): Promise<void>;\n\n  /**\n   * Creates `newpath` as a symbolic link to `oldpath`.\n   *\n   * The `options.type` parameter can be set to `\"file\"`, `\"dir\"` or `\"junction\"`.\n   * This argument is only available on Windows and ignored on other platforms.\n   *\n   * ```ts\n   * Deno.symlinkSync(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires full `allow-read` and `allow-write` permissions.\n   *\n   * @tags allow-read, allow-write\n   * @category File System\n   */\n  export function symlinkSync(\n    oldpath: string | URL,\n    newpath: string | URL,\n    options?: SymlinkOptions,\n  ): void;\n\n  /**\n   * Synchronously changes the access (`atime`) and modification (`mtime`) times\n   * of a file system object referenced by `path`. Given times are either in\n   * seconds (UNIX epoch time) or as `Date` objects.\n   *\n   * ```ts\n   * Deno.utimeSync(\"myfile.txt\", 1556495550, new Date());\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function utimeSync(\n    path: string | URL,\n    atime: number | Date,\n    mtime: number | Date,\n  ): void;\n\n  /**\n   * Changes the access (`atime`) and modification (`mtime`) times of a file\n   * system object referenced by `path`. Given times are either in seconds\n   * (UNIX epoch time) or as `Date` objects.\n   *\n   * ```ts\n   * await Deno.utime(\"myfile.txt\", 1556495550, new Date());\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * @tags allow-write\n   * @category File System\n   */\n  export function utime(\n    path: string | URL,\n    atime: number | Date,\n    mtime: number | Date,\n  ): Promise<void>;\n\n  /** Retrieve the process umask.  If `mask` is provided, sets the process umask.\n   * This call always returns what the umask was before the call.\n   *\n   * ```ts\n   * console.log(Deno.umask());  // e.g. 18 (0o022)\n   * const prevUmaskValue = Deno.umask(0o077);  // e.g. 18 (0o022)\n   * console.log(Deno.umask());  // e.g. 63 (0o077)\n   * ```\n   *\n   * This API is under consideration to determine if permissions are required to\n   * call it.\n   *\n   * *Note*: This API is not implemented on Windows\n   *\n   * @category File System\n   */\n  export function umask(mask?: number): number;\n\n  /** The object that is returned from a {@linkcode Deno.upgradeWebSocket}\n   * request.\n   *\n   * @category WebSockets */\n  export interface WebSocketUpgrade {\n    /** The response object that represents the HTTP response to the client,\n     * which should be used to the {@linkcode RequestEvent} `.respondWith()` for\n     * the upgrade to be successful. */\n    response: Response;\n    /** The {@linkcode WebSocket} interface to communicate to the client via a\n     * web socket. */\n    socket: WebSocket;\n  }\n\n  /** Options which can be set when performing a\n   * {@linkcode Deno.upgradeWebSocket} upgrade of a {@linkcode Request}\n   *\n   * @category WebSockets */\n  export interface UpgradeWebSocketOptions {\n    /** Sets the `.protocol` property on the client side web socket to the\n     * value provided here, which should be one of the strings specified in the\n     * `protocols` parameter when requesting the web socket. This is intended\n     * for clients and servers to specify sub-protocols to use to communicate to\n     * each other. */\n    protocol?: string;\n    /** If the client does not respond to this frame with a\n     * `pong` within the timeout specified, the connection is deemed\n     * unhealthy and is closed. The `close` and `error` event will be emitted.\n     *\n     * The unit is seconds, with a default of 30.\n     * Set to `0` to disable timeouts. */\n    idleTimeout?: number;\n  }\n\n  /**\n   * Upgrade an incoming HTTP request to a WebSocket.\n   *\n   * Given a {@linkcode Request}, returns a pair of {@linkcode WebSocket} and\n   * {@linkcode Response} instances. The original request must be responded to\n   * with the returned response for the websocket upgrade to be successful.\n   *\n   * ```ts\n   * Deno.serve((req) => {\n   *   if (req.headers.get(\"upgrade\") !== \"websocket\") {\n   *     return new Response(null, { status: 501 });\n   *   }\n   *   const { socket, response } = Deno.upgradeWebSocket(req);\n   *   socket.addEventListener(\"open\", () => {\n   *     console.log(\"a client connected!\");\n   *   });\n   *   socket.addEventListener(\"message\", (event) => {\n   *     if (event.data === \"ping\") {\n   *       socket.send(\"pong\");\n   *     }\n   *   });\n   *   return response;\n   * });\n   * ```\n   *\n   * If the request body is disturbed (read from) before the upgrade is\n   * completed, upgrading fails.\n   *\n   * This operation does not yet consume the request or open the websocket. This\n   * only happens once the returned response has been passed to `respondWith()`.\n   *\n   * @category WebSockets\n   */\n  export function upgradeWebSocket(\n    request: Request,\n    options?: UpgradeWebSocketOptions,\n  ): WebSocketUpgrade;\n\n  /** Send a signal to process under given `pid`. The value and meaning of the\n   * `signal` to the process is operating system and process dependant.\n   * {@linkcode Signal} provides the most common signals. Default signal\n   * is `\"SIGTERM\"`.\n   *\n   * The term `kill` is adopted from the UNIX-like command line command `kill`\n   * which also signals processes.\n   *\n   * If `pid` is negative, the signal will be sent to the process group\n   * identified by `pid`. An error will be thrown if a negative `pid` is used on\n   * Windows.\n   *\n   * ```ts\n   * const command = new Deno.Command(\"sleep\", { args: [\"10000\"] });\n   * const child = command.spawn();\n   *\n   * Deno.kill(child.pid, \"SIGINT\");\n   * ```\n   *\n   * Requires `allow-run` permission.\n   *\n   * @tags allow-run\n   * @category Subprocess\n   */\n  export function kill(pid: number, signo?: Signal): void;\n\n  /** The type of the resource record to resolve via DNS using\n   * {@linkcode Deno.resolveDns}.\n   *\n   * Only the listed types are supported currently.\n   *\n   * @category Network\n   */\n  export type RecordType =\n    | 'A'\n    | 'AAAA'\n    | 'ANAME'\n    | 'CAA'\n    | 'CNAME'\n    | 'MX'\n    | 'NAPTR'\n    | 'NS'\n    | 'PTR'\n    | 'SOA'\n    | 'SRV'\n    | 'TXT';\n\n  /**\n   * Options which can be set when using {@linkcode Deno.resolveDns}.\n   *\n   * @category Network */\n  export interface ResolveDnsOptions {\n    /** The name server to be used for lookups.\n     *\n     * If not specified, defaults to the system configuration. For example\n     * `/etc/resolv.conf` on Unix-like systems. */\n    nameServer?: {\n      /** The IP address of the name server. */\n      ipAddr: string;\n      /** The port number the query will be sent to.\n       *\n       * @default {53} */\n      port?: number;\n    };\n    /**\n     * An abort signal to allow cancellation of the DNS resolution operation.\n     * If the signal becomes aborted the resolveDns operation will be stopped\n     * and the promise returned will be rejected with an AbortError.\n     */\n    signal?: AbortSignal;\n  }\n\n  /** If {@linkcode Deno.resolveDns} is called with `\"CAA\"` record type\n   * specified, it will resolve with an array of objects with this interface.\n   *\n   * @category Network\n   */\n  export interface CaaRecord {\n    /** If `true`, indicates that the corresponding property tag **must** be\n     * understood if the semantics of the CAA record are to be correctly\n     * interpreted by an issuer.\n     *\n     * Issuers **must not** issue certificates for a domain if the relevant CAA\n     * Resource Record set contains unknown property tags that have `critical`\n     * set. */\n    critical: boolean;\n    /** An string that represents the identifier of the property represented by\n     * the record. */\n    tag: string;\n    /** The value associated with the tag. */\n    value: string;\n  }\n\n  /** If {@linkcode Deno.resolveDns} is called with `\"MX\"` record type\n   * specified, it will return an array of objects with this interface.\n   *\n   * @category Network */\n  export interface MxRecord {\n    /** A priority value, which is a relative value compared to the other\n     * preferences of MX records for the domain. */\n    preference: number;\n    /** The server that mail should be delivered to. */\n    exchange: string;\n  }\n\n  /** If {@linkcode Deno.resolveDns} is called with `\"NAPTR\"` record type\n   * specified, it will return an array of objects with this interface.\n   *\n   * @category Network */\n  export interface NaptrRecord {\n    order: number;\n    preference: number;\n    flags: string;\n    services: string;\n    regexp: string;\n    replacement: string;\n  }\n\n  /** If {@linkcode Deno.resolveDns} is called with `\"SOA\"` record type\n   * specified, it will return an array of objects with this interface.\n   *\n   * @category Network */\n  export interface SoaRecord {\n    mname: string;\n    rname: string;\n    serial: number;\n    refresh: number;\n    retry: number;\n    expire: number;\n    minimum: number;\n  }\n\n  /** If {@linkcode Deno.resolveDns} is called with `\"SRV\"` record type\n   * specified, it will return an array of objects with this interface.\n   *\n   * @category Network\n   */\n  export interface SrvRecord {\n    priority: number;\n    weight: number;\n    port: number;\n    target: string;\n  }\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'A' | 'AAAA' | 'ANAME' | 'CNAME' | 'NS' | 'PTR',\n    options?: ResolveDnsOptions,\n  ): Promise<string[]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'CAA',\n    options?: ResolveDnsOptions,\n  ): Promise<CaaRecord[]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'MX',\n    options?: ResolveDnsOptions,\n  ): Promise<MxRecord[]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'NAPTR',\n    options?: ResolveDnsOptions,\n  ): Promise<NaptrRecord[]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'SOA',\n    options?: ResolveDnsOptions,\n  ): Promise<SoaRecord[]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'SRV',\n    options?: ResolveDnsOptions,\n  ): Promise<SrvRecord[]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: 'TXT',\n    options?: ResolveDnsOptions,\n  ): Promise<string[][]>;\n\n  /**\n   * Performs DNS resolution against the given query, returning resolved\n   * records.\n   *\n   * Fails in the cases such as:\n   *\n   * - the query is in invalid format.\n   * - the options have an invalid parameter. For example `nameServer.port` is\n   *   beyond the range of 16-bit unsigned integer.\n   * - the request timed out.\n   *\n   * ```ts\n   * const a = await Deno.resolveDns(\"example.com\", \"A\");\n   *\n   * const aaaa = await Deno.resolveDns(\"example.com\", \"AAAA\", {\n   *   nameServer: { ipAddr: \"8.8.8.8\", port: 53 },\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function resolveDns(\n    query: string,\n    recordType: RecordType,\n    options?: ResolveDnsOptions,\n  ): Promise<\n    | string[]\n    | CaaRecord[]\n    | MxRecord[]\n    | NaptrRecord[]\n    | SoaRecord[]\n    | SrvRecord[]\n    | string[][]\n  >;\n\n  /**\n   * Make the timer of the given `id` block the event loop from finishing.\n   *\n   * @category Runtime\n   */\n  export function refTimer(id: number): void;\n\n  /**\n   * Make the timer of the given `id` not block the event loop from finishing.\n   *\n   * @category Runtime\n   */\n  export function unrefTimer(id: number): void;\n\n  /**\n   * Returns the user id of the process on POSIX platforms. Returns null on Windows.\n   *\n   * ```ts\n   * console.log(Deno.uid());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function uid(): number | null;\n\n  /**\n   * Returns the group id of the process on POSIX platforms. Returns null on windows.\n   *\n   * ```ts\n   * console.log(Deno.gid());\n   * ```\n   *\n   * Requires `allow-sys` permission.\n   *\n   * @tags allow-sys\n   * @category Runtime\n   */\n  export function gid(): number | null;\n\n  /** Additional information for an HTTP request and its connection.\n   *\n   * @category HTTP Server\n   */\n  export interface ServeHandlerInfo<Addr extends Deno.Addr = Deno.Addr> {\n    /** The remote address of the connection. */\n    remoteAddr: Addr;\n    /** The completion promise */\n    completed: Promise<void>;\n  }\n\n  /** A handler for HTTP requests. Consumes a request and returns a response.\n   *\n   * If a handler throws, the server calling the handler will assume the impact\n   * of the error is isolated to the individual request. It will catch the error\n   * and if necessary will close the underlying connection.\n   *\n   * @category HTTP Server\n   */\n  export type ServeHandler<Addr extends Deno.Addr = Deno.Addr> = (\n    request: Request,\n    info: ServeHandlerInfo<Addr>,\n  ) => Response | Promise<Response>;\n\n  /** Interface that module run with `deno serve` subcommand must conform to.\n   *\n   * To ensure your code is type-checked properly, make sure to add `satisfies Deno.ServeDefaultExport`\n   * to the `export default { ... }` like so:\n   *\n   * ```ts\n   * export default {\n   *   fetch(req) {\n   *     return new Response(\"Hello world\");\n   *   }\n   * } satisfies Deno.ServeDefaultExport;\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export interface ServeDefaultExport {\n    /** A handler for HTTP requests. Consumes a request and returns a response.\n     *\n     * If a handler throws, the server calling the handler will assume the impact\n     * of the error is isolated to the individual request. It will catch the error\n     * and if necessary will close the underlying connection.\n     *\n     * @category HTTP Server\n     */\n    fetch: ServeHandler;\n    /**\n     * The callback which is called when the server starts listening.\n     *\n     * @category HTTP Server\n     */\n    onListen?: (localAddr: Deno.Addr) => void;\n  }\n\n  /** Options which can be set when calling {@linkcode Deno.serve}.\n   *\n   * @category HTTP Server\n   */\n  export interface ServeOptions<Addr extends Deno.Addr = Deno.Addr> {\n    /** An {@linkcode AbortSignal} to close the server and all connections. */\n    signal?: AbortSignal;\n\n    /** The handler to invoke when route handlers throw an error. */\n    onError?: (error: unknown) => Response | Promise<Response>;\n\n    /** The callback which is called when the server starts listening. */\n    onListen?: (localAddr: Addr) => void;\n  }\n\n  /**\n   * Options that can be passed to `Deno.serve` to create a server listening on\n   * a TCP port.\n   *\n   * @category HTTP Server\n   */\n  export interface ServeTcpOptions extends ServeOptions<Deno.NetAddr> {\n    /** The transport to use. */\n    transport?: 'tcp';\n\n    /** The port to listen on.\n     *\n     * Set to `0` to listen on any available port.\n     *\n     * @default {8000} */\n    port?: number;\n\n    /** A literal IP address or host name that can be resolved to an IP address.\n     *\n     * __Note about `0.0.0.0`__ While listening `0.0.0.0` works on all platforms,\n     * the browsers on Windows don't work with the address `0.0.0.0`.\n     * You should show the message like `server running on localhost:8080` instead of\n     * `server running on 0.0.0.0:8080` if your program supports Windows.\n     *\n     * @default {\"0.0.0.0\"} */\n    hostname?: string;\n\n    /** Sets `SO_REUSEPORT` on POSIX systems. */\n    reusePort?: boolean;\n\n    /** Maximum number of pending connections in the listen queue.\n     *\n     * This parameter controls how many incoming connections can be queued by the\n     * operating system while waiting for the application to accept them. If more\n     * connections arrive when the queue is full, they will be refused.\n     *\n     * The kernel may adjust this value (e.g., rounding up to the next power of 2\n     * plus 1). Different operating systems have different maximum limits.\n     *\n     * @default {511} */\n    tcpBacklog?: number;\n  }\n\n  /**\n   * Options that can be passed to `Deno.serve` to create a server listening on\n   * a Unix domain socket.\n   *\n   * @category HTTP Server\n   */\n  export interface ServeUnixOptions extends ServeOptions<Deno.UnixAddr> {\n    /** The transport to use. */\n    transport?: 'unix';\n\n    /** The unix domain socket path to listen on. */\n    path: string;\n  }\n\n  /**\n   * Options that can be passed to `Deno.serve` to create a server listening on\n   * a VSOCK socket.\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @category HTTP Server\n   */\n  export interface ServeVsockOptions extends ServeOptions<Deno.VsockAddr> {\n    /** The transport to use. */\n    transport?: 'vsock';\n\n    /** The context identifier to use. */\n    cid: number;\n\n    /** The port to use. */\n    port: number;\n  }\n\n  /**\n   * @category HTTP Server\n   */\n  export interface ServeInit<Addr extends Deno.Addr = Deno.Addr> {\n    /** The handler to invoke to process each incoming request. */\n    handler: ServeHandler<Addr>;\n  }\n\n  /** An instance of the server created using `Deno.serve()` API.\n   *\n   * @category HTTP Server\n   */\n  export interface HttpServer<Addr extends Deno.Addr = Deno.Addr>\n    extends AsyncDisposable {\n    /** A promise that resolves once server finishes - eg. when aborted using\n     * the signal passed to {@linkcode ServeOptions.signal}.\n     */\n    finished: Promise<void>;\n\n    /** The local address this server is listening on. */\n    addr: Addr;\n\n    /**\n     * Make the server block the event loop from finishing.\n     *\n     * Note: the server blocks the event loop from finishing by default.\n     * This method is only meaningful after `.unref()` is called.\n     */\n    ref(): void;\n\n    /** Make the server not block the event loop from finishing. */\n    unref(): void;\n\n    /** Gracefully close the server. No more new connections will be accepted,\n     * while pending requests will be allowed to finish.\n     */\n    shutdown(): Promise<void>;\n  }\n\n  /** Serves HTTP requests with the given handler.\n   *\n   * The below example serves with the port `8000` on hostname `\"127.0.0.1\"`.\n   *\n   * ```ts\n   * Deno.serve((_req) => new Response(\"Hello, world\"));\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    handler: ServeHandler<Deno.NetAddr>,\n  ): HttpServer<Deno.NetAddr>;\n  /** Serves HTTP requests with the given option bag and handler.\n   *\n   * You can specify the socket path with `path` option.\n   *\n   * ```ts\n   * Deno.serve(\n   *   { path: \"path/to/socket\" },\n   *   (_req) => new Response(\"Hello, world\")\n   * );\n   * ```\n   *\n   * You can stop the server with an {@linkcode AbortSignal}. The abort signal\n   * needs to be passed as the `signal` option in the options bag. The server\n   * aborts when the abort signal is aborted. To wait for the server to close,\n   * await the promise returned from the `Deno.serve` API.\n   *\n   * ```ts\n   * const ac = new AbortController();\n   *\n   * const server = Deno.serve(\n   *    { signal: ac.signal, path: \"path/to/socket\" },\n   *    (_req) => new Response(\"Hello, world\")\n   * );\n   * server.finished.then(() => console.log(\"Server closed\"));\n   *\n   * console.log(\"Closing server...\");\n   * ac.abort();\n   * ```\n   *\n   * By default `Deno.serve` prints the message\n   * `Listening on path/to/socket` on listening. If you like to\n   * change this behavior, you can specify a custom `onListen` callback.\n   *\n   * ```ts\n   * Deno.serve({\n   *   onListen({ path }) {\n   *     console.log(`Server started at ${path}`);\n   *     // ... more info specific to your server ..\n   *   },\n   *   path: \"path/to/socket\",\n   * }, (_req) => new Response(\"Hello, world\"));\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    options: ServeUnixOptions,\n    handler: ServeHandler<Deno.UnixAddr>,\n  ): HttpServer<Deno.UnixAddr>;\n  /** Serves HTTP requests with the given option bag and handler.\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * You can specify an object with the cid and port options for the VSOCK interface.\n   *\n   * The VSOCK address family facilitates communication between virtual machines and the host they are running on: https://man7.org/linux/man-pages/man7/vsock.7.html\n   *\n   * ```ts\n   * Deno.serve(\n   *   { cid: -1, port: 3000 },\n   *   (_req) => new Response(\"Hello, world\")\n   * );\n   * ```\n   *\n   * You can stop the server with an {@linkcode AbortSignal}. The abort signal\n   * needs to be passed as the `signal` option in the options bag. The server\n   * aborts when the abort signal is aborted. To wait for the server to close,\n   * await the promise returned from the `Deno.serve` API.\n   *\n   * ```ts\n   * const ac = new AbortController();\n   *\n   * const server = Deno.serve(\n   *    { signal: ac.signal, cid: -1, port: 3000 },\n   *    (_req) => new Response(\"Hello, world\")\n   * );\n   * server.finished.then(() => console.log(\"Server closed\"));\n   *\n   * console.log(\"Closing server...\");\n   * ac.abort();\n   * ```\n   *\n   * By default `Deno.serve` prints the message `Listening on cid:port`.\n   * If you want to change this behavior, you can specify a custom `onListen`\n   * callback.\n   *\n   * ```ts\n   * Deno.serve({\n   *   onListen({ cid, port }) {\n   *     console.log(`Server started at ${cid}:${port}`);\n   *     // ... more info specific to your server ..\n   *   },\n   *   cid: -1,\n   *   port: 3000,\n   * }, (_req) => new Response(\"Hello, world\"));\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    options: ServeVsockOptions,\n    handler: ServeHandler<Deno.VsockAddr>,\n  ): HttpServer<Deno.VsockAddr>;\n  /** Serves HTTP requests with the given option bag and handler.\n   *\n   * You can specify an object with a port and hostname option, which is the\n   * address to listen on. The default is port `8000` on hostname `\"0.0.0.0\"`.\n   *\n   * You can change the address to listen on using the `hostname` and `port`\n   * options. The below example serves on port `3000` and hostname `\"127.0.0.1\"`.\n   *\n   * ```ts\n   * Deno.serve(\n   *   { port: 3000, hostname: \"127.0.0.1\" },\n   *   (_req) => new Response(\"Hello, world\")\n   * );\n   * ```\n   *\n   * You can stop the server with an {@linkcode AbortSignal}. The abort signal\n   * needs to be passed as the `signal` option in the options bag. The server\n   * aborts when the abort signal is aborted. To wait for the server to close,\n   * await the promise returned from the `Deno.serve` API.\n   *\n   * ```ts\n   * const ac = new AbortController();\n   *\n   * const server = Deno.serve(\n   *    { signal: ac.signal },\n   *    (_req) => new Response(\"Hello, world\")\n   * );\n   * server.finished.then(() => console.log(\"Server closed\"));\n   *\n   * console.log(\"Closing server...\");\n   * ac.abort();\n   * ```\n   *\n   * By default `Deno.serve` prints the message\n   * `Listening on http://<hostname>:<port>/` on listening. If you like to\n   * change this behavior, you can specify a custom `onListen` callback.\n   *\n   * ```ts\n   * Deno.serve({\n   *   onListen({ port, hostname }) {\n   *     console.log(`Server started at http://${hostname}:${port}`);\n   *     // ... more info specific to your server ..\n   *   },\n   * }, (_req) => new Response(\"Hello, world\"));\n   * ```\n   *\n   * To enable TLS you must specify the `key` and `cert` options.\n   *\n   * ```ts\n   * const cert = \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\\n\";\n   * const key = \"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\\n\";\n   * Deno.serve({ cert, key }, (_req) => new Response(\"Hello, world\"));\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    options: ServeTcpOptions | (ServeTcpOptions & TlsCertifiedKeyPem),\n    handler: ServeHandler<Deno.NetAddr>,\n  ): HttpServer<Deno.NetAddr>;\n  /** Serves HTTP requests with the given option bag.\n   *\n   * You can specify an object with the path option, which is the\n   * unix domain socket to listen on.\n   *\n   * ```ts\n   * const ac = new AbortController();\n   *\n   * const server = Deno.serve({\n   *   path: \"path/to/socket\",\n   *   handler: (_req) => new Response(\"Hello, world\"),\n   *   signal: ac.signal,\n   *   onListen({ path }) {\n   *     console.log(`Server started at ${path}`);\n   *   },\n   * });\n   * server.finished.then(() => console.log(\"Server closed\"));\n   *\n   * console.log(\"Closing server...\");\n   * ac.abort();\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    options: ServeUnixOptions & ServeInit<Deno.UnixAddr>,\n  ): HttpServer<Deno.UnixAddr>;\n  /** Serves HTTP requests with the given option bag.\n   *\n   * The VSOCK address family facilitates communication between virtual machines and the host they are running on: https://man7.org/linux/man-pages/man7/vsock.7.html\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * You can specify an object with the cid and port options for the VSOCK interface.\n   *\n   * ```ts\n   * const ac = new AbortController();\n   *\n   * const server = Deno.serve({\n   *   cid: -1,\n   *   port: 3000,\n   *   handler: (_req) => new Response(\"Hello, world\"),\n   *   signal: ac.signal,\n   *   onListen({ cid, port }) {\n   *     console.log(`Server started at ${cid}:${port}`);\n   *   },\n   * });\n   * server.finished.then(() => console.log(\"Server closed\"));\n   *\n   * console.log(\"Closing server...\");\n   * ac.abort();\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    options: ServeVsockOptions & ServeInit<Deno.VsockAddr>,\n  ): HttpServer<Deno.VsockAddr>;\n  /** Serves HTTP requests with the given option bag.\n   *\n   * You can specify an object with a port and hostname option, which is the\n   * address to listen on. The default is port `8000` on hostname `\"0.0.0.0\"`.\n   *\n   * ```ts\n   * const ac = new AbortController();\n   *\n   * const server = Deno.serve({\n   *   port: 3000,\n   *   hostname: \"127.0.0.1\",\n   *   handler: (_req) => new Response(\"Hello, world\"),\n   *   signal: ac.signal,\n   *   onListen({ port, hostname }) {\n   *     console.log(`Server started at http://${hostname}:${port}`);\n   *   },\n   * });\n   * server.finished.then(() => console.log(\"Server closed\"));\n   *\n   * console.log(\"Closing server...\");\n   * ac.abort();\n   * ```\n   *\n   * @category HTTP Server\n   */\n  export function serve(\n    options: (ServeTcpOptions | (ServeTcpOptions & TlsCertifiedKeyPem)) &\n      ServeInit<Deno.NetAddr>,\n  ): HttpServer<Deno.NetAddr>;\n\n  /** All plain number types for interfacing with foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeNumberType =\n    | 'u8'\n    | 'i8'\n    | 'u16'\n    | 'i16'\n    | 'u32'\n    | 'i32'\n    | 'f32'\n    | 'f64';\n\n  /** All BigInt number types for interfacing with foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeBigIntType = 'u64' | 'i64' | 'usize' | 'isize';\n\n  /** The native boolean type for interfacing to foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeBooleanType = 'bool';\n\n  /** The native pointer type for interfacing to foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativePointerType = 'pointer';\n\n  /** The native buffer type for interfacing to foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeBufferType = 'buffer';\n\n  /** The native function type for interfacing with foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeFunctionType = 'function';\n\n  /** The native void type for interfacing with foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeVoidType = 'void';\n\n  /** The native struct type for interfacing with foreign functions.\n   *\n   * @category FFI\n   */\n  export interface NativeStructType {\n    readonly struct: readonly NativeType[];\n  }\n\n  /**\n   * @category FFI\n   */\n  const brand: unique symbol;\n\n  /**\n   * @category FFI\n   */\n  export type NativeU8Enum<T extends number> = 'u8' & { [brand]: T };\n  /**\n   * @category FFI\n   */\n  export type NativeI8Enum<T extends number> = 'i8' & { [brand]: T };\n  /**\n   * @category FFI\n   */\n  export type NativeU16Enum<T extends number> = 'u16' & { [brand]: T };\n  /**\n   * @category FFI\n   */\n  export type NativeI16Enum<T extends number> = 'i16' & { [brand]: T };\n  /**\n   * @category FFI\n   */\n  export type NativeU32Enum<T extends number> = 'u32' & { [brand]: T };\n  /**\n   * @category FFI\n   */\n  export type NativeI32Enum<T extends number> = 'i32' & { [brand]: T };\n  /**\n   * @category FFI\n   */\n  export type NativeTypedPointer<T extends PointerObject> = 'pointer' & {\n    [brand]: T;\n  };\n  /**\n   * @category FFI\n   */\n  export type NativeTypedFunction<T extends UnsafeCallbackDefinition> =\n    'function' & {\n      [brand]: T;\n    };\n\n  /** All supported types for interfacing with foreign functions.\n   *\n   * @category FFI\n   */\n  export type NativeType =\n    | NativeNumberType\n    | NativeBigIntType\n    | NativeBooleanType\n    | NativePointerType\n    | NativeBufferType\n    | NativeFunctionType\n    | NativeStructType;\n\n  /** @category FFI\n   */\n  export type NativeResultType = NativeType | NativeVoidType;\n\n  /** Type conversion for foreign symbol parameters and unsafe callback return\n   * types.\n   *\n   * @category FFI\n   */\n  export type ToNativeType<T extends NativeType = NativeType> =\n    T extends NativeStructType\n      ? BufferSource\n      : T extends NativeNumberType\n        ? T extends NativeU8Enum<infer U>\n          ? U\n          : T extends NativeI8Enum<infer U>\n            ? U\n            : T extends NativeU16Enum<infer U>\n              ? U\n              : T extends NativeI16Enum<infer U>\n                ? U\n                : T extends NativeU32Enum<infer U>\n                  ? U\n                  : T extends NativeI32Enum<infer U>\n                    ? U\n                    : number\n        : T extends NativeBigIntType\n          ? bigint\n          : T extends NativeBooleanType\n            ? boolean\n            : T extends NativePointerType\n              ? T extends NativeTypedPointer<infer U>\n                ? U | null\n                : PointerValue\n              : T extends NativeFunctionType\n                ? T extends NativeTypedFunction<infer U>\n                  ? PointerValue<U> | null\n                  : PointerValue\n                : T extends NativeBufferType\n                  ? BufferSource | null\n                  : never;\n\n  /** Type conversion for unsafe callback return types.\n   *\n   * @category FFI\n   */\n  export type ToNativeResultType<\n    T extends NativeResultType = NativeResultType,\n  > = T extends NativeStructType\n    ? BufferSource\n    : T extends NativeNumberType\n      ? T extends NativeU8Enum<infer U>\n        ? U\n        : T extends NativeI8Enum<infer U>\n          ? U\n          : T extends NativeU16Enum<infer U>\n            ? U\n            : T extends NativeI16Enum<infer U>\n              ? U\n              : T extends NativeU32Enum<infer U>\n                ? U\n                : T extends NativeI32Enum<infer U>\n                  ? U\n                  : number\n      : T extends NativeBigIntType\n        ? bigint\n        : T extends NativeBooleanType\n          ? boolean\n          : T extends NativePointerType\n            ? T extends NativeTypedPointer<infer U>\n              ? U | null\n              : PointerValue\n            : T extends NativeFunctionType\n              ? T extends NativeTypedFunction<infer U>\n                ? PointerObject<U> | null\n                : PointerValue\n              : T extends NativeBufferType\n                ? BufferSource | null\n                : T extends NativeVoidType\n                  ? void\n                  : never;\n\n  /** A utility type for conversion of parameter types of foreign functions.\n   *\n   * @category FFI\n   */\n  export type ToNativeParameterTypes<T extends readonly NativeType[]> =\n    //\n    [T[number][]] extends [T]\n      ? ToNativeType<T[number]>[]\n      : [readonly T[number][]] extends [T]\n        ? readonly ToNativeType<T[number]>[]\n        : T extends readonly [...NativeType[]]\n          ? {\n              [K in keyof T]: ToNativeType<T[K]>;\n            }\n          : never;\n\n  /** Type conversion for foreign symbol return types and unsafe callback\n   * parameters.\n   *\n   * @category FFI\n   */\n  export type FromNativeType<T extends NativeType = NativeType> =\n    T extends NativeStructType\n      ? Uint8Array<ArrayBuffer>\n      : T extends NativeNumberType\n        ? T extends NativeU8Enum<infer U>\n          ? U\n          : T extends NativeI8Enum<infer U>\n            ? U\n            : T extends NativeU16Enum<infer U>\n              ? U\n              : T extends NativeI16Enum<infer U>\n                ? U\n                : T extends NativeU32Enum<infer U>\n                  ? U\n                  : T extends NativeI32Enum<infer U>\n                    ? U\n                    : number\n        : T extends NativeBigIntType\n          ? bigint\n          : T extends NativeBooleanType\n            ? boolean\n            : T extends NativePointerType\n              ? T extends NativeTypedPointer<infer U>\n                ? U | null\n                : PointerValue\n              : T extends NativeBufferType\n                ? PointerValue\n                : T extends NativeFunctionType\n                  ? T extends NativeTypedFunction<infer U>\n                    ? PointerObject<U> | null\n                    : PointerValue\n                  : never;\n\n  /** Type conversion for foreign symbol return types.\n   *\n   * @category FFI\n   */\n  export type FromNativeResultType<\n    T extends NativeResultType = NativeResultType,\n  > = T extends NativeStructType\n    ? Uint8Array<ArrayBuffer>\n    : T extends NativeNumberType\n      ? T extends NativeU8Enum<infer U>\n        ? U\n        : T extends NativeI8Enum<infer U>\n          ? U\n          : T extends NativeU16Enum<infer U>\n            ? U\n            : T extends NativeI16Enum<infer U>\n              ? U\n              : T extends NativeU32Enum<infer U>\n                ? U\n                : T extends NativeI32Enum<infer U>\n                  ? U\n                  : number\n      : T extends NativeBigIntType\n        ? bigint\n        : T extends NativeBooleanType\n          ? boolean\n          : T extends NativePointerType\n            ? T extends NativeTypedPointer<infer U>\n              ? U | null\n              : PointerValue\n            : T extends NativeBufferType\n              ? PointerValue\n              : T extends NativeFunctionType\n                ? T extends NativeTypedFunction<infer U>\n                  ? PointerObject<U> | null\n                  : PointerValue\n                : T extends NativeVoidType\n                  ? void\n                  : never;\n\n  /** @category FFI\n   */\n  export type FromNativeParameterTypes<T extends readonly NativeType[]> =\n    //\n    [T[number][]] extends [T]\n      ? FromNativeType<T[number]>[]\n      : [readonly T[number][]] extends [T]\n        ? readonly FromNativeType<T[number]>[]\n        : T extends readonly [...NativeType[]]\n          ? {\n              [K in keyof T]: FromNativeType<T[K]>;\n            }\n          : never;\n\n  /** The interface for a foreign function as defined by its parameter and result\n   * types.\n   *\n   * @category FFI\n   */\n  export interface ForeignFunction<\n    Parameters extends readonly NativeType[] = readonly NativeType[],\n    Result extends NativeResultType = NativeResultType,\n    NonBlocking extends boolean = boolean,\n  > {\n    /** Name of the symbol.\n     *\n     * Defaults to the key name in symbols object. */\n    name?: string;\n    /** The parameters of the foreign function. */\n    parameters: Parameters;\n    /** The result (return value) of the foreign function. */\n    result: Result;\n    /** When `true`, function calls will run on a dedicated blocking thread and\n     * will return a `Promise` resolving to the `result`. */\n    nonblocking?: NonBlocking;\n    /** When `true`, dlopen will not fail if the symbol is not found.\n     * Instead, the symbol will be set to `null`.\n     *\n     * @default {false} */\n    optional?: boolean;\n  }\n\n  /** @category FFI\n   */\n  export interface ForeignStatic<Type extends NativeType = NativeType> {\n    /** Name of the symbol, defaults to the key name in symbols object. */\n    name?: string;\n    /** The type of the foreign static value. */\n    type: Type;\n    /** When `true`, dlopen will not fail if the symbol is not found.\n     * Instead, the symbol will be set to `null`.\n     *\n     * @default {false} */\n    optional?: boolean;\n  }\n\n  /** A foreign library interface descriptor.\n   *\n   * @category FFI\n   */\n  export interface ForeignLibraryInterface {\n    [name: string]: ForeignFunction | ForeignStatic;\n  }\n\n  /** A utility type that infers a foreign symbol.\n   *\n   * @category FFI\n   */\n  export type StaticForeignSymbol<T extends ForeignFunction | ForeignStatic> =\n    T extends ForeignFunction\n      ? FromForeignFunction<T>\n      : T extends ForeignStatic\n        ? FromNativeType<T['type']>\n        : never;\n\n  /**  @category FFI\n   */\n  export type FromForeignFunction<T extends ForeignFunction> =\n    T['parameters'] extends readonly []\n      ? () => StaticForeignSymbolReturnType<T>\n      : (\n          ...args: ToNativeParameterTypes<T['parameters']>\n        ) => StaticForeignSymbolReturnType<T>;\n\n  /** @category FFI\n   */\n  export type StaticForeignSymbolReturnType<T extends ForeignFunction> =\n    ConditionalAsync<T['nonblocking'], FromNativeResultType<T['result']>>;\n\n  /** @category FFI\n   */\n  export type ConditionalAsync<\n    IsAsync extends boolean | undefined,\n    T,\n  > = IsAsync extends true ? Promise<T> : T;\n\n  /** A utility type that infers a foreign library interface.\n   *\n   * @category FFI\n   */\n  export type StaticForeignLibraryInterface<T extends ForeignLibraryInterface> =\n    {\n      [K in keyof T]: T[K]['optional'] extends true\n        ? StaticForeignSymbol<T[K]> | null\n        : StaticForeignSymbol<T[K]>;\n    };\n\n  /** A non-null pointer, represented as an object\n   * at runtime. The object's prototype is `null`\n   * and cannot be changed. The object cannot be\n   * assigned to either and is thus entirely read-only.\n   *\n   * To interact with memory through a pointer use the\n   * {@linkcode UnsafePointerView} class. To create a\n   * pointer from an address or the get the address of\n   * a pointer use the static methods of the\n   * {@linkcode UnsafePointer} class.\n   *\n   * @category FFI\n   */\n  export interface PointerObject<T = unknown> {\n    [brand]: T;\n  }\n\n  /** Pointers are represented either with a {@linkcode PointerObject}\n   * object or a `null` if the pointer is null.\n   *\n   * @category FFI\n   */\n  export type PointerValue<T = unknown> = null | PointerObject<T>;\n\n  /** A collection of static functions for interacting with pointer objects.\n   *\n   * @category FFI\n   */\n  export class UnsafePointer {\n    /** Create a pointer from a numeric value. This one is <i>really</i> dangerous! */\n    static create<T = unknown>(value: bigint): PointerValue<T>;\n    /** Returns `true` if the two pointers point to the same address. */\n    static equals<T = unknown>(a: PointerValue<T>, b: PointerValue<T>): boolean;\n    /** Return the direct memory pointer to the typed array in memory. */\n    static of<T = unknown>(\n      value: Deno.UnsafeCallback | BufferSource,\n    ): PointerValue<T>;\n    /** Return a new pointer offset from the original by `offset` bytes. */\n    static offset<T = unknown>(\n      value: PointerObject,\n      offset: number,\n    ): PointerValue<T>;\n    /** Get the numeric value of a pointer */\n    static value(value: PointerValue): bigint;\n  }\n\n  /** An unsafe pointer view to a memory location as specified by the `pointer`\n   * value. The `UnsafePointerView` API follows the standard built in interface\n   * {@linkcode DataView} for accessing the underlying types at an memory\n   * location (numbers, strings and raw bytes).\n   *\n   * @category FFI\n   */\n  export class UnsafePointerView {\n    constructor(pointer: PointerObject);\n\n    pointer: PointerObject;\n\n    /** Gets a boolean at the specified byte offset from the pointer. */\n    getBool(offset?: number): boolean;\n    /** Gets an unsigned 8-bit integer at the specified byte offset from the\n     * pointer. */\n    getUint8(offset?: number): number;\n    /** Gets a signed 8-bit integer at the specified byte offset from the\n     * pointer. */\n    getInt8(offset?: number): number;\n    /** Gets an unsigned 16-bit integer at the specified byte offset from the\n     * pointer. */\n    getUint16(offset?: number): number;\n    /** Gets a signed 16-bit integer at the specified byte offset from the\n     * pointer. */\n    getInt16(offset?: number): number;\n    /** Gets an unsigned 32-bit integer at the specified byte offset from the\n     * pointer. */\n    getUint32(offset?: number): number;\n    /** Gets a signed 32-bit integer at the specified byte offset from the\n     * pointer. */\n    getInt32(offset?: number): number;\n    /** Gets an unsigned 64-bit integer at the specified byte offset from the\n     * pointer. */\n    getBigUint64(offset?: number): bigint;\n    /** Gets a signed 64-bit integer at the specified byte offset from the\n     * pointer. */\n    getBigInt64(offset?: number): bigint;\n    /** Gets a signed 32-bit float at the specified byte offset from the\n     * pointer. */\n    getFloat32(offset?: number): number;\n    /** Gets a signed 64-bit float at the specified byte offset from the\n     * pointer. */\n    getFloat64(offset?: number): number;\n    /** Gets a pointer at the specified byte offset from the pointer */\n    getPointer<T = unknown>(offset?: number): PointerValue<T>;\n    /** Gets a C string (`null` terminated string) at the specified byte offset\n     * from the pointer. */\n    getCString(offset?: number): string;\n    /** Gets a C string (`null` terminated string) at the specified byte offset\n     * from the specified pointer. */\n    static getCString(pointer: PointerObject, offset?: number): string;\n    /** Gets an `ArrayBuffer` of length `byteLength` at the specified byte\n     * offset from the pointer. */\n    getArrayBuffer(byteLength: number, offset?: number): ArrayBuffer;\n    /** Gets an `ArrayBuffer` of length `byteLength` at the specified byte\n     * offset from the specified pointer. */\n    static getArrayBuffer(\n      pointer: PointerObject,\n      byteLength: number,\n      offset?: number,\n    ): ArrayBuffer;\n    /** Copies the memory of the pointer into a typed array.\n     *\n     * Length is determined from the typed array's `byteLength`.\n     *\n     * Also takes optional byte offset from the pointer. */\n    copyInto(destination: BufferSource, offset?: number): void;\n    /** Copies the memory of the specified pointer into a typed array.\n     *\n     * Length is determined from the typed array's `byteLength`.\n     *\n     * Also takes optional byte offset from the pointer. */\n    static copyInto(\n      pointer: PointerObject,\n      destination: BufferSource,\n      offset?: number,\n    ): void;\n  }\n\n  /** An unsafe pointer to a function, for calling functions that are not present\n   * as symbols.\n   *\n   * @category FFI\n   */\n  export class UnsafeFnPointer<const Fn extends ForeignFunction> {\n    /** The pointer to the function. */\n    pointer: PointerObject<Fn>;\n    /** The definition of the function. */\n    definition: Fn;\n\n    constructor(\n      pointer: PointerObject<NoInfer<Omit<Fn, 'nonblocking'>>>,\n      definition: Fn,\n    );\n\n    /** Call the foreign function. */\n    call: FromForeignFunction<Fn>;\n  }\n\n  /** Definition of a unsafe callback function.\n   *\n   * @category FFI\n   */\n  export interface UnsafeCallbackDefinition<\n    Parameters extends readonly NativeType[] = readonly NativeType[],\n    Result extends NativeResultType = NativeResultType,\n  > {\n    /** The parameters of the callbacks. */\n    parameters: Parameters;\n    /** The current result of the callback. */\n    result: Result;\n  }\n\n  /** An unsafe callback function.\n   *\n   * @category FFI\n   */\n  export type UnsafeCallbackFunction<\n    Parameters extends readonly NativeType[] = readonly NativeType[],\n    Result extends NativeResultType = NativeResultType,\n  > = Parameters extends readonly []\n    ? () => ToNativeResultType<Result>\n    : (\n        ...args: FromNativeParameterTypes<Parameters>\n      ) => ToNativeResultType<Result>;\n\n  /** An unsafe function pointer for passing JavaScript functions as C function\n   * pointers to foreign function calls.\n   *\n   * The function pointer remains valid until the `close()` method is called.\n   *\n   * All `UnsafeCallback` are always thread safe in that they can be called from\n   * foreign threads without crashing. However, they do not wake up the Deno event\n   * loop by default.\n   *\n   * If a callback is to be called from foreign threads, use the `threadSafe()`\n   * static constructor or explicitly call `ref()` to have the callback wake up\n   * the Deno event loop when called from foreign threads. This also stops\n   * Deno's process from exiting while the callback still exists and is not\n   * unref'ed.\n   *\n   * Use `deref()` to then allow Deno's process to exit. Calling `deref()` on\n   * a ref'ed callback does not stop it from waking up the Deno event loop when\n   * called from foreign threads.\n   *\n   * @category FFI\n   */\n  export class UnsafeCallback<\n    const Definition extends\n      UnsafeCallbackDefinition = UnsafeCallbackDefinition,\n  > {\n    constructor(\n      definition: Definition,\n      callback: UnsafeCallbackFunction<\n        Definition['parameters'],\n        Definition['result']\n      >,\n    );\n\n    /** The pointer to the unsafe callback. */\n    readonly pointer: PointerObject<Definition>;\n    /** The definition of the unsafe callback. */\n    readonly definition: Definition;\n    /** The callback function. */\n    readonly callback: UnsafeCallbackFunction<\n      Definition['parameters'],\n      Definition['result']\n    >;\n\n    /**\n     * Creates an {@linkcode UnsafeCallback} and calls `ref()` once to allow it to\n     * wake up the Deno event loop when called from foreign threads.\n     *\n     * This also stops Deno's process from exiting while the callback still\n     * exists and is not unref'ed.\n     */\n    static threadSafe<\n      Definition extends UnsafeCallbackDefinition = UnsafeCallbackDefinition,\n    >(\n      definition: Definition,\n      callback: UnsafeCallbackFunction<\n        Definition['parameters'],\n        Definition['result']\n      >,\n    ): UnsafeCallback<Definition>;\n\n    /**\n     * Increments the callback's reference counting and returns the new\n     * reference count.\n     *\n     * After `ref()` has been called, the callback always wakes up the\n     * Deno event loop when called from foreign threads.\n     *\n     * If the callback's reference count is non-zero, it keeps Deno's\n     * process from exiting.\n     */\n    ref(): number;\n\n    /**\n     * Decrements the callback's reference counting and returns the new\n     * reference count.\n     *\n     * Calling `unref()` does not stop a callback from waking up the Deno\n     * event loop when called from foreign threads.\n     *\n     * If the callback's reference counter is zero, it no longer keeps\n     * Deno's process from exiting.\n     */\n    unref(): number;\n\n    /**\n     * Removes the C function pointer associated with this instance.\n     *\n     * Continuing to use the instance or the C function pointer after closing\n     * the `UnsafeCallback` will lead to errors and crashes.\n     *\n     * Calling this method sets the callback's reference counting to zero,\n     * stops the callback from waking up the Deno event loop when called from\n     * foreign threads and no longer keeps Deno's process from exiting.\n     */\n    close(): void;\n  }\n\n  /** A dynamic library resource.  Use {@linkcode Deno.dlopen} to load a dynamic\n   * library and return this interface.\n   *\n   * @category FFI\n   */\n  export interface DynamicLibrary<S extends ForeignLibraryInterface> {\n    /** All of the registered library along with functions for calling them. */\n    symbols: StaticForeignLibraryInterface<S>;\n    /** Removes the pointers associated with the library symbols.\n     *\n     * Continuing to use symbols that are part of the library will lead to\n     * errors and crashes.\n     *\n     * Calling this method will also immediately set any references to zero and\n     * will no longer keep Deno's process from exiting.\n     */\n    close(): void;\n  }\n\n  /** Opens an external dynamic library and registers symbols, making foreign\n   * functions available to be called.\n   *\n   * Requires `allow-ffi` permission. Loading foreign dynamic libraries can in\n   * theory bypass all of the sandbox permissions. While it is a separate\n   * permission users should acknowledge in practice that is effectively the\n   * same as running with the `allow-all` permission.\n   *\n   * @example Given a C library which exports a foreign function named `add()`\n   *\n   * ```ts\n   * // Determine library extension based on\n   * // your OS.\n   * let libSuffix = \"\";\n   * switch (Deno.build.os) {\n   *   case \"windows\":\n   *     libSuffix = \"dll\";\n   *     break;\n   *   case \"darwin\":\n   *     libSuffix = \"dylib\";\n   *     break;\n   *   default:\n   *     libSuffix = \"so\";\n   *     break;\n   * }\n   *\n   * const libName = `./libadd.${libSuffix}`;\n   * // Open library and define exported symbols\n   * const dylib = Deno.dlopen(\n   *   libName,\n   *   {\n   *     \"add\": { parameters: [\"isize\", \"isize\"], result: \"isize\" },\n   *   } as const,\n   * );\n   *\n   * // Call the symbol `add`\n   * const result = dylib.symbols.add(35n, 34n); // 69n\n   *\n   * console.log(`Result from external addition of 35 and 34: ${result}`);\n   * ```\n   *\n   * @tags allow-ffi\n   * @category FFI\n   */\n  export function dlopen<const S extends ForeignLibraryInterface>(\n    filename: string | URL,\n    symbols: S,\n  ): DynamicLibrary<S>;\n\n  /**\n   * A custom `HttpClient` for use with {@linkcode fetch} function. This is\n   * designed to allow custom certificates or proxies to be used with `fetch()`.\n   *\n   * @example ```ts\n   * const caCert = await Deno.readTextFile(\"./ca.pem\");\n   * const client = Deno.createHttpClient({ caCerts: [ caCert ] });\n   * const req = await fetch(\"https://myserver.com\", { client });\n   * ```\n   *\n   * @category Fetch\n   */\n  export class HttpClient implements Disposable {\n    /** Close the HTTP client. */\n    close(): void;\n\n    [Symbol.dispose](): void;\n  }\n\n  /**\n   * The options used when creating a {@linkcode Deno.HttpClient}.\n   *\n   * @category Fetch\n   */\n  export interface CreateHttpClientOptions {\n    /** A list of root certificates that will be used in addition to the\n     * default root certificates to verify the peer's certificate.\n     *\n     * Must be in PEM format. */\n    caCerts?: string[];\n    /** An alternative transport (a proxy) to use for new connections. */\n    proxy?: Proxy;\n    /** Sets the maximum number of idle connections per host allowed in the pool. */\n    poolMaxIdlePerHost?: number;\n    /** Set an optional timeout for idle sockets being kept-alive.\n     * Set to false to disable the timeout. */\n    poolIdleTimeout?: number | false;\n    /**\n     * Whether HTTP/1.1 is allowed or not.\n     *\n     * @default {true}\n     */\n    http1?: boolean;\n    /** Whether HTTP/2 is allowed or not.\n     *\n     * @default {true}\n     */\n    http2?: boolean;\n    /** Whether setting the host header is allowed or not.\n     *\n     * @default {false}\n     */\n    allowHost?: boolean;\n    /** Sets the local address where the socket will connect from. */\n    localAddress?: string;\n  }\n\n  /**\n   * The definition for alternative transports (or proxies) in\n   * {@linkcode Deno.CreateHttpClientOptions}.\n   *\n   * Supported proxies:\n   *  - HTTP/HTTPS proxy: this uses passthrough to tunnel HTTP requests, or HTTP\n   *    CONNECT to tunnel HTTPS requests through a different server.\n   *  - SOCKS5 proxy: this uses the SOCKS5 protocol to tunnel TCP connections\n   *    through a different server.\n   *  - TCP socket: this sends all requests to a specified TCP socket.\n   *  - Unix domain socket: this sends all requests to a local Unix domain\n   *    socket rather than a TCP socket. *Not supported on Windows.*\n   *  - Vsock socket: this sends all requests to a local vsock socket.\n   *    *Only supported on Linux and macOS.*\n   *\n   * @category Fetch\n   */\n  export type Proxy =\n    | {\n        transport?: 'http' | 'https' | 'socks5';\n        /**\n         * The string URL of the proxy server to use.\n         *\n         * For `http` and `https` transports, the URL must start with `http://` or\n         * `https://` respectively, or be a plain hostname.\n         *\n         * For `socks` transport, the URL must start with `socks5://` or\n         * `socks5h://`.\n         */\n        url: string;\n        /** The basic auth credentials to be used against the proxy server. */\n        basicAuth?: BasicAuth;\n      }\n    | {\n        transport: 'tcp';\n        /** The hostname of the TCP server to connect to. */\n        hostname: string;\n        /** The port of the TCP server to connect to. */\n        port: number;\n      }\n    | {\n        transport: 'unix';\n        /** The path to the unix domain socket to use. */\n        path: string;\n      }\n    | {\n        transport: 'vsock';\n        /** The CID (Context Identifier) of the vsock to connect to. */\n        cid: number;\n        /** The port of the vsock to connect to. */\n        port: number;\n      };\n\n  /**\n   * Basic authentication credentials to be used with a {@linkcode Deno.Proxy}\n   * server when specifying {@linkcode Deno.CreateHttpClientOptions}.\n   *\n   * @category Fetch\n   */\n  export interface BasicAuth {\n    /** The username to be used against the proxy server. */\n    username: string;\n    /** The password to be used against the proxy server. */\n    password: string;\n  }\n\n  /** Create a custom HttpClient to use with {@linkcode fetch}. This is an\n   * extension of the web platform Fetch API which allows Deno to use custom\n   * TLS CA certificates and connect via a proxy while using `fetch()`.\n   *\n   * The `cert` and `key` options can be used to specify a client certificate\n   * and key to use when connecting to a server that requires client\n   * authentication (mutual TLS or mTLS). The `cert` and `key` options must be\n   * provided in PEM format.\n   *\n   * @example ```ts\n   * const caCert = await Deno.readTextFile(\"./ca.pem\");\n   * const client = Deno.createHttpClient({ caCerts: [ caCert ] });\n   * const response = await fetch(\"https://myserver.com\", { client });\n   * ```\n   *\n   * @example ```ts\n   * const client = Deno.createHttpClient({\n   *   proxy: { url: \"http://myproxy.com:8080\" }\n   * });\n   * const response = await fetch(\"https://myserver.com\", { client });\n   * ```\n   *\n   * @example ```ts\n   * const key = \"----BEGIN PRIVATE KEY----...\";\n   * const cert = \"----BEGIN CERTIFICATE----...\";\n   * const client = Deno.createHttpClient({ key, cert });\n   * const response = await fetch(\"https://myserver.com\", { client });\n   * ```\n   *\n   * @category Fetch\n   */\n  export function createHttpClient(\n    options:\n      | CreateHttpClientOptions\n      | (CreateHttpClientOptions & TlsCertifiedKeyPem),\n  ): HttpClient;\n\n  /**\n   * APIs for working with the OpenTelemetry observability framework. Deno can\n   * export traces, metrics, and logs to OpenTelemetry compatible backends via\n   * the OTLP protocol.\n   *\n   * Deno automatically instruments the runtime with OpenTelemetry traces and\n   * metrics. This data is exported via OTLP to OpenTelemetry compatible\n   * backends. User logs from the `console` API are exported as OpenTelemetry\n   * logs via OTLP.\n   *\n   * User code can also create custom traces, metrics, and logs using the\n   * OpenTelemetry API. This is done using the official OpenTelemetry package\n   * for JavaScript:\n   * [`npm:@opentelemetry/api`](https://opentelemetry.io/docs/languages/js/).\n   * Deno integrates with this package to provide tracing, metrics, and trace\n   * context propagation between native Deno APIs (like `Deno.serve` or `fetch`)\n   * and custom user code. Deno automatically registers the providers with the\n   * OpenTelemetry API, so users can start creating custom traces, metrics, and\n   * logs without any additional setup.\n   *\n   * @example Using OpenTelemetry API to create custom traces\n   * ```ts,ignore\n   * import { trace } from \"npm:@opentelemetry/api@1\";\n   *\n   * const tracer = trace.getTracer(\"example-tracer\");\n   *\n   * async function doWork() {\n   *   return tracer.startActiveSpan(\"doWork\", async (span) => {\n   *     span.setAttribute(\"key\", \"value\");\n   *     await new Promise((resolve) => setTimeout(resolve, 1000));\n   *     span.end();\n   *   });\n   * }\n   *\n   * Deno.serve(async (req) => {\n   *   await doWork();\n   *   const resp = await fetch(\"https://example.com\");\n   *   return resp;\n   * });\n   * ```\n   *\n   * @category Telemetry\n   */\n  export namespace telemetry {\n    /**\n     * A TracerProvider compatible with OpenTelemetry.js\n     * https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api.TracerProvider.html\n     *\n     * This is a singleton object that implements the OpenTelemetry\n     * TracerProvider interface.\n     *\n     * @category Telemetry\n     */\n    // deno-lint-ignore no-explicit-any\n    export const tracerProvider: any;\n\n    /**\n     * A ContextManager compatible with OpenTelemetry.js\n     * https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api.ContextManager.html\n     *\n     * This is a singleton object that implements the OpenTelemetry\n     * ContextManager interface.\n     *\n     * @category Telemetry\n     */\n    // deno-lint-ignore no-explicit-any\n    export const contextManager: any;\n\n    /**\n     * A MeterProvider compatible with OpenTelemetry.js\n     * https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api.MeterProvider.html\n     *\n     * This is a singleton object that implements the OpenTelemetry\n     * MeterProvider interface.\n     *\n     * @category Telemetry\n     */\n    // deno-lint-ignore no-explicit-any\n    export const meterProvider: any;\n\n    export {}; // only export exports\n  }\n\n  export {}; // only export exports\n}\n\n/** @category GPU */\ninterface GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUObjectDescriptorBase {\n  label?: string;\n}\n\n/** @category GPU */\ndeclare class GPUSupportedLimits {\n  readonly maxTextureDimension1D: number;\n  readonly maxTextureDimension2D: number;\n  readonly maxTextureDimension3D: number;\n  readonly maxTextureArrayLayers: number;\n  readonly maxBindGroups: number;\n  // TODO(@crowlKats): support max_bind_groups_plus_vertex_buffers\n  readonly maxBindGroupsPlusVertexBuffers?: number;\n  readonly maxBindingsPerBindGroup: number;\n  readonly maxDynamicUniformBuffersPerPipelineLayout: number;\n  readonly maxDynamicStorageBuffersPerPipelineLayout: number;\n  readonly maxSampledTexturesPerShaderStage: number;\n  readonly maxSamplersPerShaderStage: number;\n  readonly maxStorageBuffersPerShaderStage: number;\n  readonly maxStorageTexturesPerShaderStage: number;\n  readonly maxUniformBuffersPerShaderStage: number;\n  readonly maxUniformBufferBindingSize: number;\n  readonly maxStorageBufferBindingSize: number;\n  readonly minUniformBufferOffsetAlignment: number;\n  readonly minStorageBufferOffsetAlignment: number;\n  readonly maxVertexBuffers: number;\n  readonly maxBufferSize: number;\n  readonly maxVertexAttributes: number;\n  readonly maxVertexBufferArrayStride: number;\n  // TODO(@crowlKats): support max_inter_stage_shader_variables\n  readonly maxInterStageShaderVariables?: number;\n  readonly maxColorAttachments: number;\n  readonly maxColorAttachmentBytesPerSample: number;\n  readonly maxComputeWorkgroupStorageSize: number;\n  readonly maxComputeInvocationsPerWorkgroup: number;\n  readonly maxComputeWorkgroupSizeX: number;\n  readonly maxComputeWorkgroupSizeY: number;\n  readonly maxComputeWorkgroupSizeZ: number;\n  readonly maxComputeWorkgroupsPerDimension: number;\n}\n\n/** @category GPU */\ndeclare class GPUSupportedFeatures {\n  forEach(\n    callbackfn: (\n      value: GPUFeatureName,\n      value2: GPUFeatureName,\n      set: Set<GPUFeatureName>,\n    ) => void,\n    thisArg?: any,\n  ): void;\n  has(value: GPUFeatureName): boolean;\n  size: number;\n  [Symbol.iterator](): IterableIterator<GPUFeatureName>;\n  entries(): IterableIterator<[GPUFeatureName, GPUFeatureName]>;\n  keys(): IterableIterator<GPUFeatureName>;\n  values(): IterableIterator<GPUFeatureName>;\n}\n\n/** @category GPU */\ndeclare class GPUAdapterInfo {\n  readonly vendor: string;\n  readonly architecture: string;\n  readonly device: string;\n  readonly description: string;\n  readonly subgroupMinSize: number;\n  readonly subgroupMaxSize: number;\n  readonly isFallbackAdapter: boolean;\n}\n\n/**\n * The entry point to WebGPU in Deno, accessed via the global navigator.gpu property.\n *\n * @example\n * ```ts\n * // Basic WebGPU initialization in Deno\n * const gpu = navigator.gpu;\n * if (!gpu) {\n *   console.error(\"WebGPU not supported in this Deno environment\");\n *   Deno.exit(1);\n * }\n *\n * // Request an adapter (physical GPU device)\n * const adapter = await gpu.requestAdapter();\n * if (!adapter) {\n *   console.error(\"Couldn't request WebGPU adapter\");\n *   Deno.exit(1);\n * }\n *\n * // Get the preferred format for canvas rendering\n * // Useful when working with canvas in browser/Deno environments\n * const preferredFormat = gpu.getPreferredCanvasFormat();\n * console.log(`Preferred canvas format: ${preferredFormat}`);\n *\n * // Create a device with default settings\n * const device = await adapter.requestDevice();\n * console.log(\"WebGPU device created successfully\");\n * ```\n *\n * @category GPU\n */\ndeclare class GPU {\n  requestAdapter(\n    options?: GPURequestAdapterOptions,\n  ): Promise<GPUAdapter | null>;\n  getPreferredCanvasFormat(): GPUTextureFormat;\n}\n\n/** @category GPU */\ninterface GPURequestAdapterOptions {\n  powerPreference?: GPUPowerPreference;\n  forceFallbackAdapter?: boolean;\n}\n\n/** @category GPU */\ntype GPUPowerPreference = 'low-power' | 'high-performance';\n\n/**\n * Represents a physical GPU device that can be used to create a logical GPU device.\n *\n * @example\n * ```ts\n * // Request an adapter with specific power preference\n * const adapter = await navigator.gpu.requestAdapter({\n *   powerPreference: \"high-performance\"\n * });\n *\n * if (!adapter) {\n *   console.error(\"WebGPU not supported or no appropriate adapter found\");\n *   Deno.exit(1);\n * }\n *\n * // Check adapter capabilities\n * if (adapter.features.has(\"shader-f16\")) {\n *   console.log(\"Adapter supports 16-bit shader operations\");\n * }\n *\n * console.log(`Maximum buffer size: ${adapter.limits.maxBufferSize} bytes`);\n *\n * // Get adapter info (vendor, device, etc.)\n * console.log(`GPU Vendor: ${adapter.info.vendor}`);\n * console.log(`GPU Device: ${adapter.info.device}`);\n *\n * // Request a logical device with specific features and limits\n * const device = await adapter.requestDevice({\n *   requiredFeatures: [\"shader-f16\"],\n *   requiredLimits: {\n *     maxStorageBufferBindingSize: 128 * 1024 * 1024, // 128MB\n *   }\n * });\n * ```\n *\n * @category GPU\n */\ndeclare class GPUAdapter {\n  readonly features: GPUSupportedFeatures;\n  readonly limits: GPUSupportedLimits;\n  readonly info: GPUAdapterInfo;\n\n  requestDevice(descriptor?: GPUDeviceDescriptor): Promise<GPUDevice>;\n}\n\n/** @category GPU */\ninterface GPUDeviceDescriptor extends GPUObjectDescriptorBase {\n  requiredFeatures?: GPUFeatureName[];\n  requiredLimits?: Record<string, number | undefined>;\n}\n\n/** @category GPU */\ntype GPUFeatureName =\n  | 'depth-clip-control'\n  | 'timestamp-query'\n  | 'indirect-first-instance'\n  | 'shader-f16'\n  | 'depth32float-stencil8'\n  | 'texture-compression-bc'\n  | 'texture-compression-bc-sliced-3d'\n  | 'texture-compression-etc2'\n  | 'texture-compression-astc'\n  | 'rg11b10ufloat-renderable'\n  | 'bgra8unorm-storage'\n  | 'float32-filterable'\n  | 'dual-source-blending'\n  | 'subgroups'\n  // extended from spec\n  | 'texture-format-16-bit-norm'\n  | 'texture-compression-astc-hdr'\n  | 'texture-adapter-specific-format-features'\n  | 'pipeline-statistics-query'\n  | 'timestamp-query-inside-passes'\n  | 'mappable-primary-buffers'\n  | 'texture-binding-array'\n  | 'buffer-binding-array'\n  | 'storage-resource-binding-array'\n  | 'sampled-texture-and-storage-buffer-array-non-uniform-indexing'\n  | 'uniform-buffer-and-storage-texture-array-non-uniform-indexing'\n  | 'partially-bound-binding-array'\n  | 'multi-draw-indirect'\n  | 'multi-draw-indirect-count'\n  | 'push-constants'\n  | 'address-mode-clamp-to-zero'\n  | 'address-mode-clamp-to-border'\n  | 'polygon-mode-line'\n  | 'polygon-mode-point'\n  | 'conservative-rasterization'\n  | 'vertex-writable-storage'\n  | 'clear-texture'\n  | 'spirv-shader-passthrough'\n  | 'multiview'\n  | 'vertex-attribute-64-bit'\n  | 'shader-f64'\n  | 'shader-i16'\n  | 'shader-primitive-index'\n  | 'shader-early-depth-test';\n\n/**\n * The primary interface for interacting with a WebGPU device.\n *\n * @example\n * ```ts\n * // Request a GPU adapter from the browser/Deno\n * const adapter = await navigator.gpu.requestAdapter();\n * if (!adapter) throw new Error(\"WebGPU not supported\");\n *\n * // Request a device from the adapter\n * const device = await adapter.requestDevice();\n *\n * // Create a buffer on the GPU\n * const buffer = device.createBuffer({\n *   size: 128,\n *   usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n * });\n *\n * // Use device.queue to submit commands\n * device.queue.writeBuffer(buffer, 0, new Uint8Array([1, 2, 3, 4]));\n * ```\n *\n * @category GPU\n */\ndeclare class GPUDevice extends EventTarget implements GPUObjectBase {\n  label: string;\n\n  readonly lost: Promise<GPUDeviceLostInfo>;\n  pushErrorScope(filter: GPUErrorFilter): undefined;\n  popErrorScope(): Promise<GPUError | null>;\n\n  readonly features: GPUSupportedFeatures;\n  readonly limits: GPUSupportedLimits;\n  readonly adapterInfo: GPUAdapterInfo;\n  readonly queue: GPUQueue;\n\n  destroy(): undefined;\n\n  createBuffer(descriptor: GPUBufferDescriptor): GPUBuffer;\n  createTexture(descriptor: GPUTextureDescriptor): GPUTexture;\n  createSampler(descriptor?: GPUSamplerDescriptor): GPUSampler;\n\n  createBindGroupLayout(\n    descriptor: GPUBindGroupLayoutDescriptor,\n  ): GPUBindGroupLayout;\n  createPipelineLayout(\n    descriptor: GPUPipelineLayoutDescriptor,\n  ): GPUPipelineLayout;\n  createBindGroup(descriptor: GPUBindGroupDescriptor): GPUBindGroup;\n\n  createShaderModule(descriptor: GPUShaderModuleDescriptor): GPUShaderModule;\n  createComputePipeline(\n    descriptor: GPUComputePipelineDescriptor,\n  ): GPUComputePipeline;\n  createRenderPipeline(\n    descriptor: GPURenderPipelineDescriptor,\n  ): GPURenderPipeline;\n  createComputePipelineAsync(\n    descriptor: GPUComputePipelineDescriptor,\n  ): Promise<GPUComputePipeline>;\n  createRenderPipelineAsync(\n    descriptor: GPURenderPipelineDescriptor,\n  ): Promise<GPURenderPipeline>;\n\n  createCommandEncoder(\n    descriptor?: GPUCommandEncoderDescriptor,\n  ): GPUCommandEncoder;\n  createRenderBundleEncoder(\n    descriptor: GPURenderBundleEncoderDescriptor,\n  ): GPURenderBundleEncoder;\n\n  createQuerySet(descriptor: GPUQuerySetDescriptor): GPUQuerySet;\n}\n\n/**\n * Represents a block of memory allocated on the GPU.\n *\n * @example\n * ```ts\n * // Create a buffer that can be used as a vertex buffer and can be written to\n * const vertexBuffer = device.createBuffer({\n *   label: \"Vertex Buffer\",\n *   size: vertices.byteLength,\n *   usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n * });\n *\n * // Write data to the buffer\n * device.queue.writeBuffer(vertexBuffer, 0, vertices);\n *\n * // Example of creating a mapped buffer for CPU access\n * const stagingBuffer = device.createBuffer({\n *   size: data.byteLength,\n *   usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n *   mappedAtCreation: true,\n * });\n *\n * // Copy data to the mapped buffer\n * new Uint8Array(stagingBuffer.getMappedRange()).set(data);\n * stagingBuffer.unmap();\n * ```\n *\n * @category GPU\n */\ndeclare class GPUBuffer implements GPUObjectBase {\n  label: string;\n\n  readonly size: number;\n  readonly usage: GPUFlagsConstant;\n  readonly mapState: GPUBufferMapState;\n\n  mapAsync(\n    mode: GPUMapModeFlags,\n    offset?: number,\n    size?: number,\n  ): Promise<undefined>;\n  getMappedRange(offset?: number, size?: number): ArrayBuffer;\n  unmap(): undefined;\n\n  destroy(): undefined;\n}\n\n/** @category GPU */\ntype GPUBufferMapState = 'unmapped' | 'pending' | 'mapped';\n\n/** @category GPU */\ninterface GPUBufferDescriptor extends GPUObjectDescriptorBase {\n  size: number;\n  usage: GPUBufferUsageFlags;\n  mappedAtCreation?: boolean;\n}\n\n/** @category GPU */\ntype GPUBufferUsageFlags = number;\n\n/** @category GPU */\ntype GPUFlagsConstant = number;\n\n/** @category GPU */\ndeclare class GPUBufferUsage {\n  static MAP_READ: 0x0001;\n  static MAP_WRITE: 0x0002;\n  static COPY_SRC: 0x0004;\n  static COPY_DST: 0x0008;\n  static INDEX: 0x0010;\n  static VERTEX: 0x0020;\n  static UNIFORM: 0x0040;\n  static STORAGE: 0x0080;\n  static INDIRECT: 0x0100;\n  static QUERY_RESOLVE: 0x0200;\n}\n\n/** @category GPU */\ntype GPUMapModeFlags = number;\n\n/** @category GPU */\ndeclare class GPUMapMode {\n  static READ: 0x0001;\n  static WRITE: 0x0002;\n}\n\n/**\n * Represents a texture (image) in GPU memory.\n *\n * @example\n * ```ts\n * // Create a texture to render to\n * const texture = device.createTexture({\n *   label: \"Output Texture\",\n *   size: { width: 640, height: 480 },\n *   format: \"rgba8unorm\",\n *   usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n * });\n *\n * // Get a view of the texture (needed for most operations)\n * const textureView = texture.createView();\n *\n * // When the texture is no longer needed\n * texture.destroy();\n *\n * // Example: Creating a depth texture\n * const depthTexture = device.createTexture({\n *   size: { width: 640, height: 480 },\n *   format: \"depth24plus\",\n *   usage: GPUTextureUsage.RENDER_ATTACHMENT,\n * });\n * ```\n *\n * @category GPU\n */\ndeclare class GPUTexture implements GPUObjectBase {\n  label: string;\n\n  createView(descriptor?: GPUTextureViewDescriptor): GPUTextureView;\n  destroy(): undefined;\n\n  readonly width: number;\n  readonly height: number;\n  readonly depthOrArrayLayers: number;\n  readonly mipLevelCount: number;\n  readonly sampleCount: number;\n  readonly dimension: GPUTextureDimension;\n  readonly format: GPUTextureFormat;\n  readonly usage: GPUFlagsConstant;\n}\n\n/** @category GPU */\ninterface GPUTextureDescriptor extends GPUObjectDescriptorBase {\n  size: GPUExtent3D;\n  mipLevelCount?: number;\n  sampleCount?: number;\n  dimension?: GPUTextureDimension;\n  format: GPUTextureFormat;\n  usage: GPUTextureUsageFlags;\n  viewFormats?: GPUTextureFormat[];\n}\n\n/** @category GPU */\ntype GPUTextureDimension = '1d' | '2d' | '3d';\n\n/** @category GPU */\ntype GPUTextureUsageFlags = number;\n\n/** @category GPU */\ndeclare class GPUTextureUsage {\n  static COPY_SRC: 0x01;\n  static COPY_DST: 0x02;\n  static TEXTURE_BINDING: 0x04;\n  static STORAGE_BINDING: 0x08;\n  static RENDER_ATTACHMENT: 0x10;\n}\n\n/** @category GPU */\ndeclare class GPUTextureView implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUTextureViewDescriptor extends GPUObjectDescriptorBase {\n  format?: GPUTextureFormat;\n  dimension?: GPUTextureViewDimension;\n  usage?: GPUTextureUsageFlags;\n  aspect?: GPUTextureAspect;\n  baseMipLevel?: number;\n  mipLevelCount?: number;\n  baseArrayLayer?: number;\n  arrayLayerCount?: number;\n}\n\n/** @category GPU */\ntype GPUTextureViewDimension =\n  | '1d'\n  | '2d'\n  | '2d-array'\n  | 'cube'\n  | 'cube-array'\n  | '3d';\n\n/** @category GPU */\ntype GPUTextureAspect = 'all' | 'stencil-only' | 'depth-only';\n\n/** @category GPU */\ntype GPUTextureFormat =\n  | 'r8unorm'\n  | 'r8snorm'\n  | 'r8uint'\n  | 'r8sint'\n  | 'r16uint'\n  | 'r16sint'\n  | 'r16float'\n  | 'rg8unorm'\n  | 'rg8snorm'\n  | 'rg8uint'\n  | 'rg8sint'\n  | 'r32uint'\n  | 'r32sint'\n  | 'r32float'\n  | 'rg16uint'\n  | 'rg16sint'\n  | 'rg16float'\n  | 'rgba8unorm'\n  | 'rgba8unorm-srgb'\n  | 'rgba8snorm'\n  | 'rgba8uint'\n  | 'rgba8sint'\n  | 'bgra8unorm'\n  | 'bgra8unorm-srgb'\n  | 'rgb9e5ufloat'\n  | 'rgb10a2uint'\n  | 'rgb10a2unorm'\n  | 'rg11b10ufloat'\n  | 'rg32uint'\n  | 'rg32sint'\n  | 'rg32float'\n  | 'rgba16uint'\n  | 'rgba16sint'\n  | 'rgba16float'\n  | 'rgba32uint'\n  | 'rgba32sint'\n  | 'rgba32float'\n  | 'stencil8'\n  | 'depth16unorm'\n  | 'depth24plus'\n  | 'depth24plus-stencil8'\n  | 'depth32float'\n  | 'depth32float-stencil8'\n  | 'bc1-rgba-unorm'\n  | 'bc1-rgba-unorm-srgb'\n  | 'bc2-rgba-unorm'\n  | 'bc2-rgba-unorm-srgb'\n  | 'bc3-rgba-unorm'\n  | 'bc3-rgba-unorm-srgb'\n  | 'bc4-r-unorm'\n  | 'bc4-r-snorm'\n  | 'bc5-rg-unorm'\n  | 'bc5-rg-snorm'\n  | 'bc6h-rgb-ufloat'\n  | 'bc6h-rgb-float'\n  | 'bc7-rgba-unorm'\n  | 'bc7-rgba-unorm-srgb'\n  | 'etc2-rgb8unorm'\n  | 'etc2-rgb8unorm-srgb'\n  | 'etc2-rgb8a1unorm'\n  | 'etc2-rgb8a1unorm-srgb'\n  | 'etc2-rgba8unorm'\n  | 'etc2-rgba8unorm-srgb'\n  | 'eac-r11unorm'\n  | 'eac-r11snorm'\n  | 'eac-rg11unorm'\n  | 'eac-rg11snorm'\n  | 'astc-4x4-unorm'\n  | 'astc-4x4-unorm-srgb'\n  | 'astc-5x4-unorm'\n  | 'astc-5x4-unorm-srgb'\n  | 'astc-5x5-unorm'\n  | 'astc-5x5-unorm-srgb'\n  | 'astc-6x5-unorm'\n  | 'astc-6x5-unorm-srgb'\n  | 'astc-6x6-unorm'\n  | 'astc-6x6-unorm-srgb'\n  | 'astc-8x5-unorm'\n  | 'astc-8x5-unorm-srgb'\n  | 'astc-8x6-unorm'\n  | 'astc-8x6-unorm-srgb'\n  | 'astc-8x8-unorm'\n  | 'astc-8x8-unorm-srgb'\n  | 'astc-10x5-unorm'\n  | 'astc-10x5-unorm-srgb'\n  | 'astc-10x6-unorm'\n  | 'astc-10x6-unorm-srgb'\n  | 'astc-10x8-unorm'\n  | 'astc-10x8-unorm-srgb'\n  | 'astc-10x10-unorm'\n  | 'astc-10x10-unorm-srgb'\n  | 'astc-12x10-unorm'\n  | 'astc-12x10-unorm-srgb'\n  | 'astc-12x12-unorm'\n  | 'astc-12x12-unorm-srgb';\n\n/** @category GPU */\ndeclare class GPUSampler implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUSamplerDescriptor extends GPUObjectDescriptorBase {\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  addressModeW?: GPUAddressMode;\n  magFilter?: GPUFilterMode;\n  minFilter?: GPUFilterMode;\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  lodMaxClamp?: number;\n  compare?: GPUCompareFunction;\n  maxAnisotropy?: number;\n}\n\n/** @category GPU */\ntype GPUAddressMode = 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n/** @category GPU */\ntype GPUFilterMode = 'nearest' | 'linear';\n\n/** @category GPU */\ntype GPUMipmapFilterMode = 'nearest' | 'linear';\n\n/** @category GPU */\ntype GPUCompareFunction =\n  | 'never'\n  | 'less'\n  | 'equal'\n  | 'less-equal'\n  | 'greater'\n  | 'not-equal'\n  | 'greater-equal'\n  | 'always';\n\n/** @category GPU */\ndeclare class GPUBindGroupLayout implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUBindGroupLayoutDescriptor extends GPUObjectDescriptorBase {\n  entries: GPUBindGroupLayoutEntry[];\n}\n\n/** @category GPU */\ninterface GPUBindGroupLayoutEntry {\n  binding: number;\n  visibility: GPUShaderStageFlags;\n\n  buffer?: GPUBufferBindingLayout;\n  sampler?: GPUSamplerBindingLayout;\n  texture?: GPUTextureBindingLayout;\n  storageTexture?: GPUStorageTextureBindingLayout;\n}\n\n/** @category GPU */\ntype GPUShaderStageFlags = number;\n\n/** @category GPU */\ndeclare class GPUShaderStage {\n  static VERTEX: 0x1;\n  static FRAGMENT: 0x2;\n  static COMPUTE: 0x4;\n}\n\n/** @category GPU */\ninterface GPUBufferBindingLayout {\n  type?: GPUBufferBindingType;\n  hasDynamicOffset?: boolean;\n  minBindingSize?: number;\n}\n\n/** @category GPU */\ntype GPUBufferBindingType = 'uniform' | 'storage' | 'read-only-storage';\n\n/** @category GPU */\ninterface GPUSamplerBindingLayout {\n  type?: GPUSamplerBindingType;\n}\n\n/** @category GPU */\ntype GPUSamplerBindingType = 'filtering' | 'non-filtering' | 'comparison';\n\n/** @category GPU */\ninterface GPUTextureBindingLayout {\n  sampleType?: GPUTextureSampleType;\n  viewDimension?: GPUTextureViewDimension;\n  multisampled?: boolean;\n}\n\n/** @category GPU */\ntype GPUTextureSampleType =\n  | 'float'\n  | 'unfilterable-float'\n  | 'depth'\n  | 'sint'\n  | 'uint';\n\n/** @category GPU */\ntype GPUStorageTextureAccess = 'write-only' | 'read-only' | 'read-write';\n\n/** @category GPU */\ninterface GPUStorageTextureBindingLayout {\n  access: GPUStorageTextureAccess;\n  format: GPUTextureFormat;\n  viewDimension?: GPUTextureViewDimension;\n}\n\n/** @category GPU */\ndeclare class GPUBindGroup implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUBindGroupDescriptor extends GPUObjectDescriptorBase {\n  layout: GPUBindGroupLayout;\n  entries: GPUBindGroupEntry[];\n}\n\n/** @category GPU */\ntype GPUBindingResource = GPUSampler | GPUTextureView | GPUBufferBinding;\n\n/** @category GPU */\ninterface GPUBindGroupEntry {\n  binding: number;\n  resource: GPUBindingResource;\n}\n\n/** @category GPU */\ninterface GPUBufferBinding {\n  buffer: GPUBuffer;\n  offset?: number;\n  size?: number;\n}\n\n/** @category GPU */\ndeclare class GPUPipelineLayout implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUPipelineLayoutDescriptor extends GPUObjectDescriptorBase {\n  bindGroupLayouts: GPUBindGroupLayout[];\n}\n\n/** @category GPU */\ntype GPUCompilationMessageType = 'error' | 'warning' | 'info';\n\n/** @category GPU */\ninterface GPUCompilationMessage {\n  readonly message: string;\n  readonly type: GPUCompilationMessageType;\n  readonly lineNum: number;\n  readonly linePos: number;\n}\n\n/** @category GPU */\ninterface GPUCompilationInfo {\n  readonly messages: ReadonlyArray<GPUCompilationMessage>;\n}\n\n/**\n * The **`GPUPipelineError`** interface of the WebGPU API describes a pipeline failure.\n * Available only in secure contexts.\n *\n * [MDN Reference](https://developer.mozilla.org/docs/Web/API/GPUPipelineError)\n * @category GPU\n */\ninterface GPUPipelineError extends DOMException {\n  /**\n   * The **`reason`** read-only property of the GPUPipelineError interface defines the reason the pipeline creation failed in a machine-readable way.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/GPUPipelineError/reason)\n   */\n  readonly reason: 'validation' | 'internal';\n}\n\n/** @category GPU */\ndeclare var GPUPipelineError: {\n  prototype: GPUPipelineError;\n  new (message: string, options: GPUPipelineErrorInit): GPUPipelineError;\n};\n\n/** @category GPU */\ninterface GPUPipelineErrorInit {\n  reason: 'validation' | 'internal';\n}\n\n/**\n * Represents a compiled shader module that can be used to create graphics or compute pipelines.\n *\n * @example\n * ```ts\n * // Create a shader module using WGSL (WebGPU Shading Language)\n * const shaderModule = device.createShaderModule({\n *   label: \"My Shader\",\n *   code: `\n *     @vertex\n *     fn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {\n *       return vec4f(pos, 0.0, 1.0);\n *     }\n *\n *     @fragment\n *     fn fragmentMain() -> @location(0) vec4f {\n *       return vec4f(1.0, 0.0, 0.0, 1.0); // red color\n *     }\n *   `\n * });\n *\n * // Can optionally check for compilation errors/warnings\n * const compilationInfo = await shaderModule.getCompilationInfo();\n * for (const message of compilationInfo.messages) {\n *   console.log(`${message.type}: ${message.message} at ${message.lineNum}:${message.linePos}`);\n * }\n * ```\n *\n * @category GPU\n */\ndeclare class GPUShaderModule implements GPUObjectBase {\n  label: string;\n\n  /**\n   * Returns compilation messages for this shader module,\n   * which can include errors, warnings and info messages.\n   */\n  getCompilationInfo(): Promise<GPUCompilationInfo>;\n}\n\n/** @category GPU */\ninterface GPUShaderModuleDescriptor extends GPUObjectDescriptorBase {\n  code: string;\n  sourceMap?: any;\n}\n\n/** @category GPU */\ntype GPUAutoLayoutMode = 'auto';\n\n/** @category GPU */\ninterface GPUPipelineDescriptorBase extends GPUObjectDescriptorBase {\n  layout: GPUPipelineLayout | GPUAutoLayoutMode;\n}\n\n/** @category GPU */\ninterface GPUPipelineBase {\n  getBindGroupLayout(index: number): GPUBindGroupLayout;\n}\n\n/** @category GPU */\ninterface GPUProgrammableStage {\n  module: GPUShaderModule;\n  entryPoint?: string;\n  constants?: Record<string, number>;\n}\n\n/** @category GPU */\ndeclare class GPUComputePipeline implements GPUObjectBase, GPUPipelineBase {\n  label: string;\n\n  getBindGroupLayout(index: number): GPUBindGroupLayout;\n}\n\n/** @category GPU */\ninterface GPUComputePipelineDescriptor extends GPUPipelineDescriptorBase {\n  compute: GPUProgrammableStage;\n}\n\n/** @category GPU */\ndeclare class GPURenderPipeline implements GPUObjectBase, GPUPipelineBase {\n  label: string;\n\n  getBindGroupLayout(index: number): GPUBindGroupLayout;\n}\n\n/** @category GPU */\ninterface GPURenderPipelineDescriptor extends GPUPipelineDescriptorBase {\n  vertex: GPUVertexState;\n  primitive?: GPUPrimitiveState;\n  depthStencil?: GPUDepthStencilState;\n  multisample?: GPUMultisampleState;\n  fragment?: GPUFragmentState;\n}\n\n/** @category GPU */\ninterface GPUPrimitiveState {\n  topology?: GPUPrimitiveTopology;\n  stripIndexFormat?: GPUIndexFormat;\n  frontFace?: GPUFrontFace;\n  cullMode?: GPUCullMode;\n  unclippedDepth?: boolean;\n}\n\n/** @category GPU */\ntype GPUPrimitiveTopology =\n  | 'point-list'\n  | 'line-list'\n  | 'line-strip'\n  | 'triangle-list'\n  | 'triangle-strip';\n\n/** @category GPU */\ntype GPUFrontFace = 'ccw' | 'cw';\n\n/** @category GPU */\ntype GPUCullMode = 'none' | 'front' | 'back';\n\n/** @category GPU */\ninterface GPUMultisampleState {\n  count?: number;\n  mask?: number;\n  alphaToCoverageEnabled?: boolean;\n}\n\n/** @category GPU */\ninterface GPUFragmentState extends GPUProgrammableStage {\n  targets: (GPUColorTargetState | null)[];\n}\n\n/** @category GPU */\ninterface GPUColorTargetState {\n  format: GPUTextureFormat;\n\n  blend?: GPUBlendState;\n  writeMask?: GPUColorWriteFlags;\n}\n\n/** @category GPU */\ninterface GPUBlendState {\n  color: GPUBlendComponent;\n  alpha: GPUBlendComponent;\n}\n\n/** @category GPU */\ntype GPUColorWriteFlags = number;\n\n/** @category GPU */\ndeclare class GPUColorWrite {\n  static RED: 0x1;\n  static GREEN: 0x2;\n  static BLUE: 0x4;\n  static ALPHA: 0x8;\n  static ALL: 0xf;\n}\n\n/** @category GPU */\ninterface GPUBlendComponent {\n  operation?: GPUBlendOperation;\n  srcFactor?: GPUBlendFactor;\n  dstFactor?: GPUBlendFactor;\n}\n\n/** @category GPU */\ntype GPUBlendFactor =\n  | 'zero'\n  | 'one'\n  | 'src'\n  | 'one-minus-src'\n  | 'src-alpha'\n  | 'one-minus-src-alpha'\n  | 'dst'\n  | 'one-minus-dst'\n  | 'dst-alpha'\n  | 'one-minus-dst-alpha'\n  | 'src-alpha-saturated'\n  | 'constant'\n  | 'one-minus-constant'\n  | 'src1'\n  | 'one-minus-src1'\n  | 'src1-alpha'\n  | 'one-minus-src1-alpha';\n\n/** @category GPU */\ntype GPUBlendOperation =\n  | 'add'\n  | 'subtract'\n  | 'reverse-subtract'\n  | 'min'\n  | 'max';\n\n/** @category GPU */\ninterface GPUDepthStencilState {\n  format: GPUTextureFormat;\n\n  depthWriteEnabled?: boolean;\n  depthCompare?: GPUCompareFunction;\n\n  stencilFront?: GPUStencilFaceState;\n  stencilBack?: GPUStencilFaceState;\n\n  stencilReadMask?: number;\n  stencilWriteMask?: number;\n\n  depthBias?: number;\n  depthBiasSlopeScale?: number;\n  depthBiasClamp?: number;\n}\n\n/** @category GPU */\ninterface GPUStencilFaceState {\n  compare?: GPUCompareFunction;\n  failOp?: GPUStencilOperation;\n  depthFailOp?: GPUStencilOperation;\n  passOp?: GPUStencilOperation;\n}\n\n/** @category GPU */\ntype GPUStencilOperation =\n  | 'keep'\n  | 'zero'\n  | 'replace'\n  | 'invert'\n  | 'increment-clamp'\n  | 'decrement-clamp'\n  | 'increment-wrap'\n  | 'decrement-wrap';\n\n/** @category GPU */\ntype GPUIndexFormat = 'uint16' | 'uint32';\n\n/** @category GPU */\ntype GPUVertexFormat =\n  | 'uint8x2'\n  | 'uint8x4'\n  | 'sint8x2'\n  | 'sint8x4'\n  | 'unorm8x2'\n  | 'unorm8x4'\n  | 'snorm8x2'\n  | 'snorm8x4'\n  | 'uint16x2'\n  | 'uint16x4'\n  | 'sint16x2'\n  | 'sint16x4'\n  | 'unorm16x2'\n  | 'unorm16x4'\n  | 'snorm16x2'\n  | 'snorm16x4'\n  | 'float16x2'\n  | 'float16x4'\n  | 'float32'\n  | 'float32x2'\n  | 'float32x3'\n  | 'float32x4'\n  | 'uint32'\n  | 'uint32x2'\n  | 'uint32x3'\n  | 'uint32x4'\n  | 'sint32'\n  | 'sint32x2'\n  | 'sint32x3'\n  | 'sint32x4'\n  | 'unorm10-10-10-2';\n\n/** @category GPU */\ntype GPUVertexStepMode = 'vertex' | 'instance';\n\n/** @category GPU */\ninterface GPUVertexState extends GPUProgrammableStage {\n  buffers?: (GPUVertexBufferLayout | null)[];\n}\n\n/** @category GPU */\ninterface GPUVertexBufferLayout {\n  arrayStride: number;\n  stepMode?: GPUVertexStepMode;\n  attributes: GPUVertexAttribute[];\n}\n\n/** @category GPU */\ninterface GPUVertexAttribute {\n  format: GPUVertexFormat;\n  offset: number;\n\n  shaderLocation: number;\n}\n\n/** @category GPU */\ninterface GPUTexelCopyBufferLayout {\n  offset?: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\n/** @category GPU */\ndeclare class GPUCommandBuffer implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPUCommandBufferDescriptor extends GPUObjectDescriptorBase {}\n\n/**\n * Used to record GPU commands for later execution by the GPU.\n *\n * @example\n * ```ts\n * // Create a command encoder\n * const commandEncoder = device.createCommandEncoder({\n *   label: \"Main Command Encoder\"\n * });\n *\n * // Record a copy from one buffer to another\n * commandEncoder.copyBufferToBuffer(\n *   sourceBuffer, 0, // Source buffer and offset\n *   destinationBuffer, 0, // Destination buffer and offset\n *   sourceBuffer.size // Size to copy\n * );\n *\n * // Begin a compute pass to execute a compute shader\n * const computePass = commandEncoder.beginComputePass();\n * computePass.setPipeline(computePipeline);\n * computePass.setBindGroup(0, bindGroup);\n * computePass.dispatchWorkgroups(32, 1, 1); // Run 32 workgroups\n * computePass.end();\n *\n * // Begin a render pass to draw to a texture\n * const renderPass = commandEncoder.beginRenderPass({\n *   colorAttachments: [{\n *     view: textureView,\n *     clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n *     loadOp: \"clear\",\n *     storeOp: \"store\"\n *   }]\n * });\n * renderPass.setPipeline(renderPipeline);\n * renderPass.draw(3, 1, 0, 0); // Draw a triangle\n * renderPass.end();\n *\n * // Finish encoding and submit to GPU\n * const commandBuffer = commandEncoder.finish();\n * device.queue.submit([commandBuffer]);\n * ```\n *\n * @category GPU\n */\ndeclare class GPUCommandEncoder implements GPUObjectBase {\n  label: string;\n\n  beginRenderPass(descriptor: GPURenderPassDescriptor): GPURenderPassEncoder;\n  beginComputePass(\n    descriptor?: GPUComputePassDescriptor,\n  ): GPUComputePassEncoder;\n\n  copyBufferToBuffer(\n    source: GPUBuffer,\n    sourceOffset: number,\n    destination: GPUBuffer,\n    destinationOffset: number,\n    size: number,\n  ): undefined;\n\n  copyBufferToTexture(\n    source: GPUTexelCopyBufferInfo,\n    destination: GPUTexelCopyTextureInfo,\n    copySize: GPUExtent3D,\n  ): undefined;\n\n  copyTextureToBuffer(\n    source: GPUTexelCopyTextureInfo,\n    destination: GPUTexelCopyBufferInfo,\n    copySize: GPUExtent3D,\n  ): undefined;\n\n  copyTextureToTexture(\n    source: GPUTexelCopyTextureInfo,\n    destination: GPUTexelCopyTextureInfo,\n    copySize: GPUExtent3D,\n  ): undefined;\n\n  clearBuffer(\n    destination: GPUBuffer,\n    destinationOffset?: number,\n    size?: number,\n  ): undefined;\n\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n\n  writeTimestamp(querySet: GPUQuerySet, queryIndex: number): undefined;\n\n  resolveQuerySet(\n    querySet: GPUQuerySet,\n    firstQuery: number,\n    queryCount: number,\n    destination: GPUBuffer,\n    destinationOffset: number,\n  ): undefined;\n\n  finish(descriptor?: GPUCommandBufferDescriptor): GPUCommandBuffer;\n}\n\n/** @category GPU */\ninterface GPUCommandEncoderDescriptor extends GPUObjectDescriptorBase {}\n\n/** @category GPU */\ninterface GPUTexelCopyBufferInfo extends GPUTexelCopyBufferLayout {\n  buffer: GPUBuffer;\n}\n\n/** @category GPU */\ninterface GPUTexelCopyTextureInfo {\n  texture: GPUTexture;\n  mipLevel?: number;\n  origin?: GPUOrigin3D;\n  aspect?: GPUTextureAspect;\n}\n\n/** @category GPU */\ninterface GPUProgrammablePassEncoder {\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsets?: number[],\n  ): undefined;\n\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n}\n\n/** @category GPU */\ndeclare class GPUComputePassEncoder\n  implements GPUObjectBase, GPUProgrammablePassEncoder\n{\n  label: string;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsets?: number[],\n  ): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n  setPipeline(pipeline: GPUComputePipeline): undefined;\n  dispatchWorkgroups(x: number, y?: number, z?: number): undefined;\n  dispatchWorkgroupsIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n\n  end(): undefined;\n}\n\n/** @category GPU */\ninterface GPUComputePassTimestampWrites {\n  querySet: GPUQuerySet;\n  beginningOfPassWriteIndex?: number;\n  endOfPassWriteIndex?: number;\n}\n\n/** @category GPU */\ninterface GPUComputePassDescriptor extends GPUObjectDescriptorBase {\n  timestampWrites?: GPUComputePassTimestampWrites;\n}\n\n/** @category GPU */\ninterface GPURenderEncoderBase {\n  setPipeline(pipeline: GPURenderPipeline): undefined;\n\n  setIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  setVertexBuffer(\n    slot: number,\n    buffer: GPUBuffer,\n    offset?: number,\n    size?: number,\n  ): undefined;\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): undefined;\n  drawIndexedIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n}\n\n/** @category GPU */\ndeclare class GPURenderPassEncoder\n  implements GPUObjectBase, GPUProgrammablePassEncoder, GPURenderEncoderBase\n{\n  label: string;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsets?: number[],\n  ): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n  setPipeline(pipeline: GPURenderPipeline): undefined;\n  setIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  setVertexBuffer(\n    slot: number,\n    buffer: GPUBuffer,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): undefined;\n  drawIndexedIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n\n  setViewport(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    minDepth: number,\n    maxDepth: number,\n  ): undefined;\n\n  setScissorRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n  ): undefined;\n\n  setBlendConstant(color: GPUColor): undefined;\n  setStencilReference(reference: number): undefined;\n\n  beginOcclusionQuery(queryIndex: number): undefined;\n  endOcclusionQuery(): undefined;\n\n  executeBundles(bundles: GPURenderBundle[]): undefined;\n  end(): undefined;\n}\n\n/** @category GPU */\ninterface GPURenderPassTimestampWrites {\n  querySet: GPUQuerySet;\n  beginningOfPassWriteIndex?: number;\n  endOfPassWriteIndex?: number;\n}\n\n/** @category GPU */\ninterface GPURenderPassDescriptor extends GPUObjectDescriptorBase {\n  colorAttachments: (GPURenderPassColorAttachment | null)[];\n  depthStencilAttachment?: GPURenderPassDepthStencilAttachment;\n  occlusionQuerySet?: GPUQuerySet;\n  timestampWrites?: GPURenderPassTimestampWrites;\n}\n\n/** @category GPU */\ninterface GPURenderPassColorAttachment {\n  view: GPUTextureView;\n  resolveTarget?: GPUTextureView;\n\n  clearValue?: GPUColor;\n  loadOp: GPULoadOp;\n  storeOp: GPUStoreOp;\n}\n\n/** @category GPU */\ninterface GPURenderPassDepthStencilAttachment {\n  view: GPUTextureView;\n\n  depthClearValue?: number;\n  depthLoadOp?: GPULoadOp;\n  depthStoreOp?: GPUStoreOp;\n  depthReadOnly?: boolean;\n\n  stencilClearValue?: number;\n  stencilLoadOp?: GPULoadOp;\n  stencilStoreOp?: GPUStoreOp;\n  stencilReadOnly?: boolean;\n}\n\n/** @category GPU */\ntype GPULoadOp = 'load' | 'clear';\n\n/** @category GPU */\ntype GPUStoreOp = 'store' | 'discard';\n\n/** @category GPU */\ndeclare class GPURenderBundle implements GPUObjectBase {\n  label: string;\n}\n\n/** @category GPU */\ninterface GPURenderBundleDescriptor extends GPUObjectDescriptorBase {}\n\n/** @category GPU */\ndeclare class GPURenderBundleEncoder\n  implements GPUObjectBase, GPUProgrammablePassEncoder, GPURenderEncoderBase\n{\n  label: string;\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexedIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n  popDebugGroup(): undefined;\n  pushDebugGroup(groupLabel: string): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsets?: number[],\n  ): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup | null,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n  setIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  setPipeline(pipeline: GPURenderPipeline): undefined;\n  setVertexBuffer(\n    slot: number,\n    buffer: GPUBuffer,\n    offset?: number,\n    size?: number,\n  ): undefined;\n\n  finish(descriptor?: GPURenderBundleDescriptor): GPURenderBundle;\n}\n\n/** @category GPU */\ninterface GPURenderPassLayout extends GPUObjectDescriptorBase {\n  colorFormats: (GPUTextureFormat | null)[];\n  depthStencilFormat?: GPUTextureFormat;\n  sampleCount?: number;\n}\n\n/** @category GPU */\ninterface GPURenderBundleEncoderDescriptor extends GPURenderPassLayout {\n  depthReadOnly?: boolean;\n  stencilReadOnly?: boolean;\n}\n\n/**\n * Represents a queue to submit commands to the GPU.\n *\n * @example\n * ```ts\n * // Get a queue from the device (each device has a default queue)\n * const queue = device.queue;\n *\n * // Write data to a buffer\n * const buffer = device.createBuffer({\n *   size: data.byteLength,\n *   usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n * });\n * queue.writeBuffer(buffer, 0, data);\n *\n * // Submit command buffers to the GPU for execution\n * const commandBuffer = commandEncoder.finish();\n * queue.submit([commandBuffer]);\n *\n * // Wait for all submitted operations to complete\n * await queue.onSubmittedWorkDone();\n *\n * // Example: Write data to a texture\n * const texture = device.createTexture({\n *   size: { width: 256, height: 256 },\n *   format: \"rgba8unorm\",\n *   usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\n * });\n *\n * const data = new Uint8Array(256 * 256 * 4); // RGBA data\n * // Fill data with your texture content...\n *\n * queue.writeTexture(\n *   { texture },\n *   data,\n *   { bytesPerRow: 256 * 4 },\n *   { width: 256, height: 256 }\n * );\n * ```\n *\n * @category GPU\n */\ndeclare class GPUQueue implements GPUObjectBase {\n  label: string;\n\n  submit(commandBuffers: GPUCommandBuffer[]): undefined;\n\n  onSubmittedWorkDone(): Promise<undefined>;\n\n  writeBuffer(\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    data: BufferSource,\n    dataOffset?: number,\n    size?: number,\n  ): undefined;\n\n  writeTexture(\n    destination: GPUTexelCopyTextureInfo,\n    data: BufferSource,\n    dataLayout: GPUTexelCopyBufferLayout,\n    size: GPUExtent3D,\n  ): undefined;\n}\n\n/** @category GPU */\ndeclare class GPUQuerySet implements GPUObjectBase {\n  label: string;\n\n  destroy(): undefined;\n\n  readonly type: GPUQueryType;\n  readonly count: number;\n}\n\n/** @category GPU */\ninterface GPUQuerySetDescriptor extends GPUObjectDescriptorBase {\n  type: GPUQueryType;\n  count: number;\n}\n\n/** @category GPU */\ntype GPUQueryType = 'occlusion' | 'timestamp';\n\n/** @category GPU */\ntype GPUDeviceLostReason = 'destroyed';\n\n/** @category GPU */\ninterface GPUDeviceLostInfo {\n  readonly reason: GPUDeviceLostReason;\n  readonly message: string;\n}\n\n/**\n * The **`GPUError`** interface of the WebGPU API is the base interface for errors surfaced by GPUDevice.popErrorScope and the GPUDevice.uncapturederror_event event.\n * Available only in secure contexts.\n *\n * [MDN Reference](https://developer.mozilla.org/docs/Web/API/GPUError)\n * @category GPU\n */\ninterface GPUError {\n  /**\n   * The **`message`** read-only property of the A string.\n   * The **`message`** read-only property of the GPUError interface provides a human-readable message that explains why the error occurred.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/GPUError/message)\n   */\n  readonly message: string;\n}\n\n/** @category GPU */\ndeclare var GPUError: {\n  prototype: GPUError;\n  new (): GPUError;\n};\n\n/** @category GPU */\ninterface GPUOutOfMemoryError extends GPUError {}\n\n/** @category GPU */\ndeclare var GPUOutOfMemoryError: {\n  prototype: GPUOutOfMemoryError;\n  new (message?: string): GPUOutOfMemoryError;\n};\n\n/** @category GPU */\ninterface GPUValidationError extends GPUError {}\n\n/** @category GPU */\ndeclare var GPUValidationError: {\n  prototype: GPUValidationError;\n  new (message?: string): GPUValidationError;\n};\n\n/** @category GPU */\ninterface GPUInternalError extends GPUError {}\n\n/** @category GPU */\ndeclare var GPUInternalError: {\n  prototype: GPUInternalError;\n  new (message?: string): GPUInternalError;\n};\n\n/** @category GPU */\ntype GPUErrorFilter = 'out-of-memory' | 'validation' | 'internal';\n\n/** @category GPU */\ndeclare class GPUUncapturedErrorEvent extends Event {\n  constructor(\n    type: string,\n    gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit,\n  );\n\n  readonly error: GPUError;\n}\n\n/** @category GPU */\ninterface GPUUncapturedErrorEventInit extends EventInit {\n  error: GPUError;\n}\n\n/** @category GPU */\ninterface GPUColorDict {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\n/** @category GPU */\ntype GPUColor = number[] | GPUColorDict;\n\n/** @category GPU */\ninterface GPUOrigin3DDict {\n  x?: number;\n  y?: number;\n  z?: number;\n}\n\n/** @category GPU */\ntype GPUOrigin3D = number[] | GPUOrigin3DDict;\n\n/** @category GPU */\ninterface GPUExtent3DDict {\n  width: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n}\n\n/** @category GPU */\ntype GPUExtent3D = number[] | GPUExtent3DDict;\n\n/** @category GPU */\ntype GPUCanvasAlphaMode = 'opaque' | 'premultiplied';\n\n/** @category GPU */\ninterface GPUCanvasConfiguration {\n  device: GPUDevice;\n  format: GPUTextureFormat;\n  usage?: GPUTextureUsageFlags;\n  viewFormats?: GPUTextureFormat[];\n  colorSpace?: 'srgb' | 'display-p3';\n  alphaMode?: GPUCanvasAlphaMode;\n}\n\n/** @category GPU */\ninterface GPUCanvasContext {\n  configure(configuration: GPUCanvasConfiguration): undefined;\n  unconfigure(): undefined;\n  getCurrentTexture(): GPUTexture;\n}\n\ndeclare namespace Deno {\n  /** @category Network */\n  export interface NetAddr {\n    transport: 'tcp' | 'udp';\n    hostname: string;\n    port: number;\n  }\n\n  /** @category Network */\n  export interface UnixAddr {\n    transport: 'unix' | 'unixpacket';\n    path: string;\n  }\n\n  /**\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   * @category Network\n   */\n  export interface VsockAddr {\n    transport: 'vsock';\n    cid: number;\n    port: number;\n  }\n\n  /** @category Network */\n  export type Addr = NetAddr | UnixAddr | VsockAddr;\n\n  /** A generic network listener for stream-oriented protocols.\n   *\n   * @category Network\n   */\n  export interface Listener<T extends Conn = Conn, A extends Addr = Addr>\n    extends AsyncIterable<T>,\n      Disposable {\n    /** Waits for and resolves to the next connection to the `Listener`. */\n    accept(): Promise<T>;\n    /** Close closes the listener. Any pending accept promises will be rejected\n     * with errors. */\n    close(): void;\n    /** Return the address of the `Listener`. */\n    readonly addr: A;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<T>;\n\n    /**\n     * Make the listener block the event loop from finishing.\n     *\n     * Note: the listener blocks the event loop from finishing by default.\n     * This method is only meaningful after `.unref()` is called.\n     */\n    ref(): void;\n\n    /** Make the listener not block the event loop from finishing. */\n    unref(): void;\n  }\n\n  /** Specialized listener that accepts TLS connections.\n   *\n   * @category Network\n   */\n  export type TlsListener = Listener<TlsConn, NetAddr>;\n\n  /** Specialized listener that accepts TCP connections.\n   *\n   * @category Network\n   */\n  export type TcpListener = Listener<TcpConn, NetAddr>;\n\n  /** Specialized listener that accepts Unix connections.\n   *\n   * @category Network\n   */\n  export type UnixListener = Listener<UnixConn, UnixAddr>;\n\n  /** Specialized listener that accepts VSOCK connections.\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @category Network\n   */\n  export type VsockListener = Listener<VsockConn, VsockAddr>;\n\n  /** @category Network */\n  export interface Conn<A extends Addr = Addr> extends Disposable {\n    /** Read the incoming data from the connection into an array buffer (`p`).\n     *\n     * Resolves to either the number of bytes read during the operation or EOF\n     * (`null`) if there was nothing more to read.\n     *\n     * It is possible for a read to successfully return with `0` bytes. This\n     * does not indicate EOF.\n     *\n     * **It is not guaranteed that the full buffer will be read in a single\n     * call.**\n     *\n     * ```ts\n     * // If the text \"hello world\" is received by the client:\n     * const conn = await Deno.connect({ hostname: \"example.com\", port: 80 });\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await conn.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * ```\n     *\n     * @category I/O\n     */\n    read(p: Uint8Array): Promise<number | null>;\n    /** Write the contents of the array buffer (`p`) to the connection.\n     *\n     * Resolves to the number of bytes written.\n     *\n     * **It is not guaranteed that the full buffer will be written in a single\n     * call.**\n     *\n     * ```ts\n     * const conn = await Deno.connect({ hostname: \"example.com\", port: 80 });\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const bytesWritten = await conn.write(data); // 11\n     * ```\n     *\n     * @category I/O\n     */\n    write(p: Uint8Array): Promise<number>;\n    /** Closes the connection, freeing the resource.\n     *\n     * ```ts\n     * const conn = await Deno.connect({ hostname: \"example.com\", port: 80 });\n     *\n     * // ...\n     *\n     * conn.close();\n     * ```\n     */\n    close(): void;\n    /** The local address of the connection. */\n    readonly localAddr: A;\n    /** The remote address of the connection. */\n    readonly remoteAddr: A;\n    /** Shuts down (`shutdown(2)`) the write side of the connection. Most\n     * callers should just use `close()`. */\n    closeWrite(): Promise<void>;\n\n    /** Make the connection block the event loop from finishing.\n     *\n     * Note: the connection blocks the event loop from finishing by default.\n     * This method is only meaningful after `.unref()` is called.\n     */\n    ref(): void;\n    /** Make the connection not block the event loop from finishing. */\n    unref(): void;\n\n    readonly readable: ReadableStream<Uint8Array<ArrayBuffer>>;\n    readonly writable: WritableStream<Uint8Array<ArrayBufferLike>>;\n  }\n\n  /** @category Network */\n  export interface TlsHandshakeInfo {\n    /**\n     * Contains the ALPN protocol selected during negotiation with the server.\n     * If no ALPN protocol selected, returns `null`.\n     */\n    alpnProtocol: string | null;\n  }\n\n  /** @category Network */\n  export interface TlsConn extends Conn<NetAddr> {\n    /** Runs the client or server handshake protocol to completion if that has\n     * not happened yet. Calling this method is optional; the TLS handshake\n     * will be completed automatically as soon as data is sent or received. */\n    handshake(): Promise<TlsHandshakeInfo>;\n  }\n\n  /** @category Network */\n  export interface ListenOptions {\n    /** The port to listen on.\n     *\n     * Set to `0` to listen on any available port.\n     */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     *\n     * __Note about `0.0.0.0`__ While listening `0.0.0.0` works on all platforms,\n     * the browsers on Windows don't work with the address `0.0.0.0`.\n     * You should show the message like `server running on localhost:8080` instead of\n     * `server running on 0.0.0.0:8080` if your program supports Windows.\n     *\n     * @default {\"0.0.0.0\"} */\n    hostname?: string;\n\n    /** Maximum number of pending connections in the listen queue.\n     *\n     * This parameter controls how many incoming connections can be queued by the\n     * operating system while waiting for the application to accept them. If more\n     * connections arrive when the queue is full, they will be refused.\n     *\n     * The kernel may adjust this value (e.g., rounding up to the next power of 2\n     * plus 1). Different operating systems have different maximum limits.\n     *\n     * @default {511} */\n    tcpBacklog?: number;\n  }\n\n  /** @category Network */\n  export interface TcpListenOptions extends ListenOptions {}\n\n  /** Listen announces on the local transport address.\n   *\n   * ```ts\n   * const listener1 = Deno.listen({ port: 80 })\n   * const listener2 = Deno.listen({ hostname: \"192.0.2.1\", port: 80 })\n   * const listener3 = Deno.listen({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const listener4 = Deno.listen({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function listen(\n    options: TcpListenOptions & { transport?: 'tcp' },\n  ): TcpListener;\n\n  /** Options which can be set when opening a Unix listener via\n   * {@linkcode Deno.listen} or {@linkcode Deno.listenDatagram}.\n   *\n   * @category Network\n   */\n  export interface UnixListenOptions {\n    /** A path to the Unix Socket. */\n    path: string;\n  }\n\n  /** Listen announces on the local transport address.\n   *\n   * ```ts\n   * const listener = Deno.listen({ path: \"/foo/bar.sock\", transport: \"unix\" })\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permission.\n   *\n   * @tags allow-read, allow-write\n   * @category Network\n   */\n  // deno-lint-ignore adjacent-overload-signatures\n  export function listen(\n    options: UnixListenOptions & { transport: 'unix' },\n  ): UnixListener;\n\n  /** Options which can be set when opening a VSOCK listener via\n   * {@linkcode Deno.listen}.\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @category Network\n   */\n  export interface VsockListenOptions {\n    cid: number;\n    port: number;\n  }\n\n  /** Listen announces on the local transport address.\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * The VSOCK address family facilitates communication between virtual machines and the host they are running on: https://man7.org/linux/man-pages/man7/vsock.7.html\n   *\n   * ```ts\n   * const listener = Deno.listen({ cid: -1, port: 80, transport: \"vsock\" })\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  // deno-lint-ignore adjacent-overload-signatures\n  export function listen(\n    options: VsockListenOptions & { transport: 'vsock' },\n  ): VsockListener;\n\n  /**\n   * Provides certified key material from strings. The key material is provided in\n   * `PEM`-format (Privacy Enhanced Mail, https://www.rfc-editor.org/rfc/rfc1422) which can be identified by having\n   * `-----BEGIN-----` and `-----END-----` markers at the beginning and end of the strings. This type of key is not compatible\n   * with `DER`-format keys which are binary.\n   *\n   * Deno supports RSA, EC, and PKCS8-format keys.\n   *\n   * ```ts\n   * const key = {\n   *  key: \"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\\n\",\n   *  cert: \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\\n\" }\n   * };\n   * ```\n   *\n   * @category Network\n   */\n  export interface TlsCertifiedKeyPem {\n    /** The format of this key material, which must be PEM. */\n    keyFormat?: 'pem';\n    /** Private key in `PEM` format. RSA, EC, and PKCS8-format keys are supported. */\n    key: string;\n    /** Certificate chain in `PEM` format. */\n    cert: string;\n  }\n\n  /** @category Network */\n  export interface ListenTlsOptions extends TcpListenOptions {\n    transport?: 'tcp';\n\n    /** Application-Layer Protocol Negotiation (ALPN) protocols to announce to\n     * the client. If not specified, no ALPN extension will be included in the\n     * TLS handshake.\n     */\n    alpnProtocols?: string[];\n  }\n\n  /** Listen announces on the local transport address over TLS (transport layer\n   * security).\n   *\n   * ```ts\n   * using listener = Deno.listenTls({\n   *   port: 443,\n   *   cert: Deno.readTextFileSync(\"./server.crt\"),\n   *   key: Deno.readTextFileSync(\"./server.key\"),\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function listenTls(\n    options: ListenTlsOptions & TlsCertifiedKeyPem,\n  ): TlsListener;\n\n  /** @category Network */\n  export interface ConnectOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified,\n     *\n     * @default {\"127.0.0.1\"} */\n    hostname?: string;\n    /** The transport layer protocol to use. */\n    transport?: 'tcp';\n    /** An {@linkcode AbortSignal} to close the tcp connection. */\n    signal?: AbortSignal;\n  }\n\n  /**\n   * Connects to the hostname (default is \"127.0.0.1\") and port on the named\n   * transport (default is \"tcp\"), and resolves to the connection (`Conn`).\n   *\n   * ```ts\n   * const conn1 = await Deno.connect({ port: 80 });\n   * const conn2 = await Deno.connect({ hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connect({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connect({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * ```\n   *\n   * Requires `allow-net` permission for \"tcp\".\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function connect(options: ConnectOptions): Promise<TcpConn>;\n\n  /** @category Network */\n  export interface TcpConn extends Conn<NetAddr> {\n    /**\n     * Enable/disable the use of Nagle's algorithm.\n     *\n     * @param [noDelay=true]\n     */\n    setNoDelay(noDelay?: boolean): void;\n    /** Enable/disable keep-alive functionality. */\n    setKeepAlive(keepAlive?: boolean): void;\n  }\n\n  /** @category Network */\n  export interface UnixConnectOptions {\n    transport: 'unix';\n    path: string;\n  }\n\n  /** @category Network */\n  export interface UnixConn extends Conn<UnixAddr> {}\n\n  /** Connects to the hostname (default is \"127.0.0.1\") and port on the named\n   * transport (default is \"tcp\"), and resolves to the connection (`Conn`).\n   *\n   * ```ts\n   * const conn1 = await Deno.connect({ port: 80 });\n   * const conn2 = await Deno.connect({ hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connect({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connect({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * const conn5 = await Deno.connect({ path: \"/foo/bar.sock\", transport: \"unix\" });\n   * ```\n   *\n   * Requires `allow-net` permission for \"tcp\" and `allow-read` for \"unix\".\n   *\n   * @tags allow-net, allow-read\n   * @category Network\n   */\n  // deno-lint-ignore adjacent-overload-signatures\n  export function connect(options: UnixConnectOptions): Promise<UnixConn>;\n\n  /**\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   * @category Network\n   */\n  export interface VsockConnectOptions {\n    transport: 'vsock';\n    cid: number;\n    port: number;\n  }\n\n  /** @category Network */\n  export interface VsockConn extends Conn<VsockAddr> {}\n\n  /** Connects to the hostname (default is \"127.0.0.1\") and port on the named\n   * transport (default is \"tcp\"), and resolves to the connection (`Conn`).\n   *\n   * @experimental **UNSTABLE**: New API, yet to be vetted.\n   *\n   * ```ts\n   * const conn1 = await Deno.connect({ port: 80 });\n   * const conn2 = await Deno.connect({ hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connect({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connect({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * const conn5 = await Deno.connect({ path: \"/foo/bar.sock\", transport: \"unix\" });\n   * const conn6 = await Deno.connect({ cid: -1, port: 80, transport: \"vsock\" });\n   * ```\n   *\n   * Requires `allow-net` permission for \"tcp\" and \"vsock\", and `allow-read` for \"unix\".\n   *\n   * @tags allow-net, allow-read\n   * @category Network\n   */\n  // deno-lint-ignore adjacent-overload-signatures\n  export function connect(options: VsockConnectOptions): Promise<VsockConn>;\n\n  /** @category Network */\n  export interface ConnectTlsOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     *\n     * @default {\"127.0.0.1\"} */\n    hostname?: string;\n    /** A list of root certificates that will be used in addition to the\n     * default root certificates to verify the peer's certificate.\n     *\n     * Must be in PEM format. */\n    caCerts?: string[];\n    /** Application-Layer Protocol Negotiation (ALPN) protocols supported by\n     * the client. If not specified, no ALPN extension will be included in the\n     * TLS handshake.\n     */\n    alpnProtocols?: string[];\n    /** If true, the certificate's common name or subject alternative names will not be\n     * checked against the hostname provided in the options.\n     *\n     * This disables hostname verification but still validates the certificate chain.\n     * Use with caution and only when connecting to known servers.\n     *\n     * @default {false}\n     */\n    unsafelyDisableHostnameVerification?: boolean;\n  }\n\n  /** Establishes a secure connection over TLS (transport layer security) using\n   * an optional list of CA certs, hostname (default is \"127.0.0.1\") and port.\n   *\n   * The CA cert list is optional and if not included Mozilla's root\n   * certificates will be used (see also https://github.com/ctz/webpki-roots for\n   * specifics).\n   *\n   * Mutual TLS (mTLS or client certificates) are supported by providing a\n   * `key` and `cert` in the options as PEM-encoded strings.\n   *\n   * ```ts\n   * const caCert = await Deno.readTextFile(\"./certs/my_custom_root_CA.pem\");\n   * const conn1 = await Deno.connectTls({ port: 80 });\n   * const conn2 = await Deno.connectTls({ caCerts: [caCert], hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connectTls({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connectTls({ caCerts: [caCert], hostname: \"golang.org\", port: 80});\n   *\n   * const key = \"----BEGIN PRIVATE KEY----...\";\n   * const cert = \"----BEGIN CERTIFICATE----...\";\n   * const conn5 = await Deno.connectTls({ port: 80, key, cert });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function connectTls(\n    options: ConnectTlsOptions | (ConnectTlsOptions & TlsCertifiedKeyPem),\n  ): Promise<TlsConn>;\n\n  /** @category Network */\n  export interface StartTlsOptions {\n    /** A literal IP address or host name that can be resolved to an IP address.\n     *\n     * @default {\"127.0.0.1\"} */\n    hostname?: string;\n    /** A list of root certificates that will be used in addition to the\n     * default root certificates to verify the peer's certificate.\n     *\n     * Must be in PEM format. */\n    caCerts?: string[];\n    /** Application-Layer Protocol Negotiation (ALPN) protocols to announce to\n     * the client. If not specified, no ALPN extension will be included in the\n     * TLS handshake.\n     */\n    alpnProtocols?: string[];\n    /** If true, the certificate's common name or subject alternative names will not be\n     * checked against the hostname provided in the options.\n     *\n     * This disables hostname verification but still validates the certificate chain.\n     * Use with caution and only when connecting to known servers.\n     *\n     * @default {false}\n     */\n    unsafelyDisableHostnameVerification?: boolean;\n  }\n\n  /** Start TLS handshake from an existing connection using an optional list of\n   * CA certificates, and hostname (default is \"127.0.0.1\"). Specifying CA certs\n   * is optional. By default the configured root certificates are used. Using\n   * this function requires that the other end of the connection is prepared for\n   * a TLS handshake.\n   *\n   * Note that this function *consumes* the TCP connection passed to it, thus the\n   * original TCP connection will be unusable after calling this. Additionally,\n   * you need to ensure that the TCP connection is not being used elsewhere when\n   * calling this function in order for the TCP connection to be consumed properly.\n   * For instance, if there is a `Promise` that is waiting for read operation on\n   * the TCP connection to complete, it is considered that the TCP connection is\n   * being used elsewhere. In such a case, this function will fail.\n   *\n   * ```ts\n   * const conn = await Deno.connect({ port: 80, hostname: \"127.0.0.1\" });\n   * const caCert = await Deno.readTextFile(\"./certs/my_custom_root_CA.pem\");\n   * // `conn` becomes unusable after calling `Deno.startTls`\n   * const tlsConn = await Deno.startTls(conn, { caCerts: [caCert], hostname: \"localhost\" });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   */\n  export function startTls(\n    conn: TcpConn,\n    options?: StartTlsOptions,\n  ): Promise<TlsConn>;\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface QuicEndpointOptions {\n    /**\n     * A literal IP address or host name that can be resolved to an IP address.\n     * @default {\"::\"}\n     */\n    hostname?: string;\n    /**\n     * The port to bind to.\n     * @default {0}\n     */\n    port?: number;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface QuicTransportOptions {\n    /** Period of inactivity before sending a keep-alive packet. Keep-alive\n     * packets prevent an inactive but otherwise healthy connection from timing\n     * out. Only one side of any given connection needs keep-alive enabled for\n     * the connection to be preserved.\n     * @default {undefined}\n     */\n    keepAliveInterval?: number;\n    /** Maximum duration of inactivity to accept before timing out the\n     * connection. The true idle timeout is the minimum of this and the peer’s\n     * own max idle timeout.\n     * @default {undefined}\n     */\n    maxIdleTimeout?: number;\n    /** Maximum number of incoming bidirectional streams that may be open\n     * concurrently.\n     * @default {100}\n     */\n    maxConcurrentBidirectionalStreams?: number;\n    /** Maximum number of incoming unidirectional streams that may be open\n     * concurrently.\n     * @default {100}\n     */\n    maxConcurrentUnidirectionalStreams?: number;\n    /**\n     * The congestion control algorithm used when sending data over this connection.\n     * @default {\"default\"}\n     */\n    congestionControl?: 'throughput' | 'low-latency' | 'default';\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface ConnectQuicOptions<ZRTT extends boolean>\n    extends QuicTransportOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address. */\n    hostname: string;\n    /** The name used for validating the certificate provided by the server. If\n     * not provided, defaults to `hostname`. */\n    serverName?: string | undefined;\n    /** Application-Layer Protocol Negotiation (ALPN) protocols supported by\n     * the client. QUIC requires the use of ALPN.\n     */\n    alpnProtocols: string[];\n    /** A list of root certificates that will be used in addition to the\n     * default root certificates to verify the peer's certificate.\n     *\n     * Must be in PEM format. */\n    caCerts?: string[];\n    /**\n     * If no endpoint is provided, a new one is bound on an ephemeral port.\n     */\n    endpoint?: QuicEndpoint;\n    /**\n     * Attempt to convert the connection into 0-RTT. Any data sent before\n     * the TLS handshake completes is vulnerable to replay attacks.\n     * @default {false}\n     */\n    zeroRtt?: ZRTT;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface QuicServerTransportOptions extends QuicTransportOptions {\n    /**\n     * Preferred IPv4 address to be communicated to the client during\n     * handshaking. If the client is able to reach this address it will switch\n     * to it.\n     * @default {undefined}\n     */\n    preferredAddressV4?: string;\n    /**\n     * Preferred IPv6 address to be communicated to the client during\n     * handshaking. If the client is able to reach this address it will switch\n     * to it.\n     * @default {undefined}\n     */\n    preferredAddressV6?: string;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface QuicListenOptions extends QuicServerTransportOptions {\n    /** Application-Layer Protocol Negotiation (ALPN) protocols to announce to\n     * the client. QUIC requires the use of ALPN.\n     */\n    alpnProtocols: string[];\n    /** Server private key in PEM format */\n    key: string;\n    /** Cert chain in PEM format */\n    cert: string;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface QuicAcceptOptions<ZRTT extends boolean>\n    extends QuicServerTransportOptions {\n    /** Application-Layer Protocol Negotiation (ALPN) protocols to announce to\n     * the client. QUIC requires the use of ALPN.\n     */\n    alpnProtocols?: string[];\n    /**\n     * Convert this connection into 0.5-RTT at the cost of weakened security, as\n     * 0.5-RTT data may be sent before TLS client authentication has occurred.\n     * @default {false}\n     */\n    zeroRtt?: ZRTT;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export interface QuicCloseInfo {\n    /** A number representing the error code for the error. */\n    closeCode: number;\n    /** A string representing the reason for closing the connection. */\n    reason: string;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicSendStreamOptions {\n    /** Indicates the send priority of this stream relative to other streams for\n     * which the value has been set.\n     * @default {0}\n     */\n    sendOrder?: number;\n    /** Wait until there is sufficient flow credit to create the stream.\n     * @default {false}\n     */\n    waitUntilAvailable?: boolean;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * @experimental\n   * @category Network\n   */\n  export class QuicEndpoint {\n    /**\n     * Create a QUIC endpoint which may be used for client or server connections.\n     *\n     * Requires `allow-net` permission.\n     *\n     * @experimental\n     * @tags allow-net\n     * @category Network\n     */\n    constructor(options?: QuicEndpointOptions);\n\n    /** Return the address of the `QuicListener`. */\n    readonly addr: NetAddr;\n\n    /**\n     * **UNSTABLE**: New API, yet to be vetted.\n     * Listen announces on the local transport address over QUIC.\n     *\n     * @experimental\n     * @category Network\n     */\n    listen(options: QuicListenOptions): QuicListener;\n\n    /**\n     * Closes the endpoint. All associated connections will be closed and incoming\n     * connections will be rejected.\n     */\n    close(info?: QuicCloseInfo): void;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * Specialized listener that accepts QUIC connections.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicListener extends AsyncIterable<QuicIncoming> {\n    /** Waits for and resolves to the next incoming connection. */\n    incoming(): Promise<QuicIncoming>;\n\n    /** Wait for the next incoming connection and accepts it. */\n    accept(): Promise<QuicConn>;\n\n    /** Stops the listener. This does not close the endpoint. */\n    stop(): void;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<QuicIncoming>;\n\n    /** The endpoint for this listener. */\n    readonly endpoint: QuicEndpoint;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * An incoming connection for which the server has not yet begun its part of\n   * the handshake.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicIncoming {\n    /**\n     * The local IP address which was used when the peer established the\n     * connection.\n     */\n    readonly localIp: string;\n\n    /**\n     * The peer’s UDP address.\n     */\n    readonly remoteAddr: NetAddr;\n\n    /**\n     * Whether the socket address that is initiating this connection has proven\n     * that they can receive traffic.\n     */\n    readonly remoteAddressValidated: boolean;\n\n    /**\n     * Accept this incoming connection.\n     */\n    accept<ZRTT extends boolean>(\n      options?: QuicAcceptOptions<ZRTT>,\n    ): ZRTT extends true ? QuicConn : Promise<QuicConn>;\n\n    /**\n     * Refuse this incoming connection.\n     */\n    refuse(): void;\n\n    /**\n     * Ignore this incoming connection attempt, not sending any packet in response.\n     */\n    ignore(): void;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicConn {\n    /** Close closes the listener. Any pending accept promises will be rejected\n     * with errors. */\n    close(info?: QuicCloseInfo): void;\n    /** Opens and returns a bidirectional stream. */\n    createBidirectionalStream(\n      options?: QuicSendStreamOptions,\n    ): Promise<QuicBidirectionalStream>;\n    /** Opens and returns a unidirectional stream. */\n    createUnidirectionalStream(\n      options?: QuicSendStreamOptions,\n    ): Promise<QuicSendStream>;\n    /** Send a datagram. The provided data cannot be larger than\n     * `maxDatagramSize`. */\n    sendDatagram(data: Uint8Array): Promise<void>;\n    /** Receive a datagram. */\n    readDatagram(): Promise<Uint8Array<ArrayBuffer>>;\n\n    /** The endpoint for this connection. */\n    readonly endpoint: QuicEndpoint;\n    /** Returns a promise that resolves when the TLS handshake is complete. */\n    readonly handshake: Promise<void>;\n    /** Return the remote address for the connection. Clients may change\n     * addresses at will, for example when switching to a cellular internet\n     * connection.\n     */\n    readonly remoteAddr: NetAddr;\n    /**\n     * The negotiated ALPN protocol, if provided. Only available after the\n     * handshake is complete. */\n    readonly protocol: string | undefined;\n    /** The negotiated server name. Only available on the server after the\n     * handshake is complete. */\n    readonly serverName: string | undefined;\n    /** Returns a promise that resolves when the connection is closed. */\n    readonly closed: Promise<QuicCloseInfo>;\n    /** A stream of bidirectional streams opened by the peer. */\n    readonly incomingBidirectionalStreams: ReadableStream<QuicBidirectionalStream>;\n    /** A stream of unidirectional streams opened by the peer. */\n    readonly incomingUnidirectionalStreams: ReadableStream<QuicReceiveStream>;\n    /** Returns the datagram stream for sending and receiving datagrams. */\n    readonly maxDatagramSize: number;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicBidirectionalStream {\n    /** Returns a QuicReceiveStream instance that can be used to read incoming data. */\n    readonly readable: QuicReceiveStream;\n    /** Returns a QuicSendStream instance that can be used to write outgoing data. */\n    readonly writable: QuicSendStream;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicSendStream\n    extends WritableStream<Uint8Array<ArrayBufferLike>> {\n    /** Indicates the send priority of this stream relative to other streams for\n     * which the value has been set. */\n    sendOrder: number;\n\n    /**\n     * 62-bit stream ID, unique within this connection.\n     */\n    readonly id: bigint;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * @experimental\n   * @category Network\n   */\n  export interface QuicReceiveStream\n    extends ReadableStream<Uint8Array<ArrayBuffer>> {\n    /**\n     * 62-bit stream ID, unique within this connection.\n     */\n    readonly id: bigint;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   * Establishes a secure connection over QUIC using a hostname and port.  The\n   * cert file is optional and if not included Mozilla's root certificates will\n   * be used. See also https://github.com/ctz/webpki-roots for specifics.\n   *\n   * ```ts\n   * const caCert = await Deno.readTextFile(\"./certs/my_custom_root_CA.pem\");\n   * const conn1 = await Deno.connectQuic({ hostname: \"example.com\", port: 443, alpnProtocols: [\"h3\"] });\n   * const conn2 = await Deno.connectQuic({ caCerts: [caCert], hostname: \"example.com\", port: 443, alpnProtocols: [\"h3\"] });\n   * ```\n   *\n   * If an endpoint is shared among many connections, 0-RTT can be enabled.\n   * When 0-RTT is successful, a QuicConn will be synchronously returned\n   * and data can be sent immediately with it. **Any data sent before the\n   * TLS handshake completes is vulnerable to replay attacks.**\n   *\n   * Requires `allow-net` permission.\n   *\n   * @experimental\n   * @tags allow-net\n   * @category Network\n   */\n  export function connectQuic<ZRTT extends boolean>(\n    options: ConnectQuicOptions<ZRTT>,\n  ): ZRTT extends true ? QuicConn | Promise<QuicConn> : Promise<QuicConn>;\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Upgrade a QUIC connection into a WebTransport instance.\n   *\n   * @category Network\n   * @experimental\n   */\n  export function upgradeWebTransport(\n    conn: QuicConn,\n  ): Promise<WebTransport & { url: string }>;\n\n  export {}; // only export exports\n}\n\ndeclare namespace Deno {\n  export {}; // stop default export type behavior\n\n  /**\n   * @category Bundler\n   * @experimental\n   */\n  export namespace bundle {\n    /**\n     * The target platform of the bundle.\n     * @category Bundler\n     * @experimental\n     */\n    export type Platform = 'browser' | 'deno';\n\n    /**\n     * The output format of the bundle.\n     * @category Bundler\n     * @experimental\n     */\n    export type Format = 'esm' | 'cjs' | 'iife';\n\n    /**\n     * The source map type of the bundle.\n     * @category Bundler\n     * @experimental\n     */\n    export type SourceMapType = 'linked' | 'inline' | 'external';\n\n    /**\n     * How to handle packages.\n     *\n     * - `bundle`: packages are inlined into the bundle.\n     * - `external`: packages are excluded from the bundle, and treated as external dependencies.\n     * @category Bundler\n     * @experimental\n     */\n    export type PackageHandling = 'bundle' | 'external';\n\n    /**\n     * Options for the bundle.\n     * @category Bundler\n     * @experimental\n     */\n    export interface Options {\n      /**\n       * The entrypoints of the bundle.\n       */\n      entrypoints: string[];\n      /**\n       * Output file path.\n       */\n      outputPath?: string;\n      /**\n       * Output directory path.\n       */\n      outputDir?: string;\n      /**\n       * External modules to exclude from bundling.\n       */\n      external?: string[];\n      /**\n       * Bundle format.\n       */\n      format?: Format;\n      /**\n       * Whether to minify the output.\n       */\n      minify?: boolean;\n      /**\n       * Whether to enable code splitting.\n       */\n      codeSplitting?: boolean;\n      /**\n       * Whether to inline imports.\n       */\n      inlineImports?: boolean;\n      /**\n       * How to handle packages.\n       */\n      packages?: PackageHandling;\n      /**\n       * Source map configuration.\n       */\n      sourcemap?: SourceMapType;\n      /**\n       * Target platform.\n       */\n      platform?: Platform;\n\n      /**\n       * Whether to write the output to the filesystem.\n       *\n       * @default true if outputDir or outputPath is set, false otherwise\n       */\n      write?: boolean;\n    }\n\n    /**\n     * The location of a message.\n     * @category Bundler\n     * @experimental\n     */\n    export interface MessageLocation {\n      file: string;\n      namespace?: string;\n      line: number;\n      column: number;\n      length: number;\n      suggestion?: string;\n    }\n\n    /**\n     * A note about a message.\n     * @category Bundler\n     * @experimental\n     */\n    export interface MessageNote {\n      text: string;\n      location?: MessageLocation;\n    }\n\n    /**\n     * A message emitted from the bundler.\n     * @category Bundler\n     * @experimental\n     */\n    export interface Message {\n      text: string;\n      location?: MessageLocation;\n      notes?: MessageNote[];\n    }\n\n    /**\n     * An output file in the bundle.\n     * @category Bundler\n     * @experimental\n     */\n    export interface OutputFile {\n      path: string;\n      contents?: Uint8Array<ArrayBuffer>;\n      hash: string;\n      text(): string;\n    }\n\n    /**\n     * The result of bundling.\n     * @category Bundler\n     * @experimental\n     */\n    export interface Result {\n      errors: Message[];\n      warnings: Message[];\n      success: boolean;\n      outputFiles?: OutputFile[];\n    }\n\n    export {}; // only export exports\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Bundle Typescript/Javascript code\n   * @category Bundle\n   * @experimental\n   */\n  export function bundle(\n    options: Deno.bundle.Options,\n  ): Promise<Deno.bundle.Result>;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   *  Creates a presentable WebGPU surface from given window and\n   *  display handles.\n   *\n   *  The parameters correspond to the table below:\n   *\n   *  | system            | winHandle     | displayHandle   |\n   *  | ----------------- | ------------- | --------------- |\n   *  | \"cocoa\" (macOS)   | -             | `NSView*`       |\n   *  | \"win32\" (Windows) | `HWND`        | `HINSTANCE`     |\n   *  | \"x11\" (Linux)     | Xlib `Window` | Xlib `Display*` |\n   *  | \"wayland\" (Linux) | `wl_surface*` | `wl_display*`   |\n   *\n   * @category GPU\n   * @experimental\n   */\n  export class UnsafeWindowSurface {\n    constructor(options: {\n      system: 'cocoa' | 'win32' | 'x11' | 'wayland';\n      windowHandle: Deno.PointerValue<unknown>;\n      displayHandle: Deno.PointerValue<unknown>;\n      width: number;\n      height: number;\n    });\n    getContext(context: 'webgpu'): GPUCanvasContext;\n    present(): void;\n    /**\n     * This method should be invoked when the size of the window changes.\n     */\n    resize(width: number, height: number): void;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Represents membership of a IPv4 multicast group.\n   *\n   * @category Network\n   * @experimental\n   */\n  export interface MulticastV4Membership {\n    /** Leaves the multicast group. */\n    leave: () => Promise<void>;\n    /** Sets the multicast loopback option. If enabled, multicast packets will be looped back to the local socket. */\n    setLoopback: (loopback: boolean) => Promise<void>;\n    /** Sets the time-to-live of outgoing multicast packets for this socket. */\n    setTTL: (ttl: number) => Promise<void>;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Represents membership of a IPv6 multicast group.\n   *\n   * @category Network\n   * @experimental\n   */\n  export interface MulticastV6Membership {\n    /** Leaves the multicast group. */\n    leave: () => Promise<void>;\n    /** Sets the multicast loopback option. If enabled, multicast packets will be looped back to the local socket. */\n    setLoopback: (loopback: boolean) => Promise<void>;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A generic transport listener for message-oriented protocols.\n   *\n   * @category Network\n   * @experimental\n   */\n  export interface DatagramConn\n    extends AsyncIterable<[Uint8Array<ArrayBuffer>, Addr]> {\n    /** Joins an IPv4 multicast group. */\n    joinMulticastV4(\n      address: string,\n      networkInterface: string,\n    ): Promise<MulticastV4Membership>;\n\n    /** Joins an IPv6 multicast group. */\n    joinMulticastV6(\n      address: string,\n      networkInterface: number,\n    ): Promise<MulticastV6Membership>;\n\n    /** Waits for and resolves to the next message to the instance.\n     *\n     * Messages are received in the format of a tuple containing the data array\n     * and the address information.\n     */\n    receive(p?: Uint8Array): Promise<[Uint8Array<ArrayBuffer>, Addr]>;\n    /** Sends a message to the target via the connection. The method resolves\n     * with the number of bytes sent. */\n    send(p: Uint8Array, addr: Addr): Promise<number>;\n    /** Close closes the socket. Any pending message promises will be rejected\n     * with errors. */\n    close(): void;\n    /** Return the address of the instance. */\n    readonly addr: Addr;\n    [Symbol.asyncIterator](): AsyncIterableIterator<\n      [Uint8Array<ArrayBuffer>, Addr]\n    >;\n  }\n\n  /**\n   * @category Network\n   * @experimental\n   */\n  export interface TcpListenOptions extends ListenOptions {\n    /** When `true` the SO_REUSEPORT flag will be set on the listener. This\n     * allows multiple processes to listen on the same address and port.\n     *\n     * On Linux this will cause the kernel to distribute incoming connections\n     * across the different processes that are listening on the same address and\n     * port.\n     *\n     * This flag is only supported on Linux. It is silently ignored on other\n     * platforms.\n     *\n     * @default {false} */\n    reusePort?: boolean;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Unstable options which can be set when opening a datagram listener via\n   * {@linkcode Deno.listenDatagram}.\n   *\n   * @category Network\n   * @experimental\n   */\n  export interface UdpListenOptions extends ListenOptions {\n    /** When `true` the specified address will be reused, even if another\n     * process has already bound a socket on it. This effectively steals the\n     * socket from the listener.\n     *\n     * @default {false} */\n    reuseAddress?: boolean;\n\n    /** When `true`, sent multicast packets will be looped back to the local socket.\n     *\n     * @default {false} */\n    loopback?: boolean;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Listen announces on the local transport address.\n   *\n   * ```ts\n   * const listener1 = Deno.listenDatagram({\n   *   port: 80,\n   *   transport: \"udp\"\n   * });\n   * const listener2 = Deno.listenDatagram({\n   *   hostname: \"golang.org\",\n   *   port: 80,\n   *   transport: \"udp\"\n   * });\n   * ```\n   *\n   * Requires `allow-net` permission.\n   *\n   * @tags allow-net\n   * @category Network\n   * @experimental\n   */\n  export function listenDatagram(\n    options: UdpListenOptions & { transport: 'udp' },\n  ): DatagramConn;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Listen announces on the local transport address.\n   *\n   * ```ts\n   * const listener = Deno.listenDatagram({\n   *   path: \"/foo/bar.sock\",\n   *   transport: \"unixpacket\"\n   * });\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permission.\n   *\n   * @tags allow-read, allow-write\n   * @category Network\n   * @experimental\n   */\n  export function listenDatagram(\n    options: UnixListenOptions & { transport: 'unixpacket' },\n  ): DatagramConn;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Open a new {@linkcode Deno.Kv} connection to persist data.\n   *\n   * When a path is provided, the database will be persisted to disk at that\n   * path. Read and write access to the file is required.\n   *\n   * When no path is provided, the database will be opened in a default path for\n   * the current script. This location is persistent across script runs and is\n   * keyed on the origin storage key (the same key that is used to determine\n   * `localStorage` persistence). More information about the origin storage key\n   * can be found in the Deno Manual.\n   *\n   * @tags allow-read, allow-write\n   * @category Cloud\n   * @experimental\n   */\n  export function openKv(path?: string): Promise<Kv>;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * CronScheduleExpression is used as the type of `minute`, `hour`,\n   * `dayOfMonth`, `month`, and `dayOfWeek` in {@linkcode CronSchedule}.\n   * @category Cloud\n   * @experimental\n   */\n  export type CronScheduleExpression =\n    | number\n    | { exact: number | number[] }\n    | {\n        start?: number;\n        end?: number;\n        every?: number;\n      };\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * CronSchedule is the interface used for JSON format\n   * cron `schedule`.\n   * @category Cloud\n   * @experimental\n   */\n  export interface CronSchedule {\n    minute?: CronScheduleExpression;\n    hour?: CronScheduleExpression;\n    dayOfMonth?: CronScheduleExpression;\n    month?: CronScheduleExpression;\n    dayOfWeek?: CronScheduleExpression;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Create a cron job that will periodically execute the provided handler\n   * callback based on the specified schedule.\n   *\n   * ```ts\n   * Deno.cron(\"sample cron\", \"20 * * * *\", () => {\n   *   console.log(\"cron job executed\");\n   * });\n   * ```\n   *\n   * ```ts\n   * Deno.cron(\"sample cron\", { hour: { every: 6 } }, () => {\n   *   console.log(\"cron job executed\");\n   * });\n   * ```\n   *\n   * `schedule` can be a string in the Unix cron format or in JSON format\n   * as specified by interface {@linkcode CronSchedule}, where time is specified\n   * using UTC time zone.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export function cron(\n    name: string,\n    schedule: string | CronSchedule,\n    handler: () => Promise<void> | void,\n  ): Promise<void>;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Create a cron job that will periodically execute the provided handler\n   * callback based on the specified schedule.\n   *\n   * ```ts\n   * Deno.cron(\"sample cron\", \"20 * * * *\", {\n   *   backoffSchedule: [10, 20]\n   * }, () => {\n   *   console.log(\"cron job executed\");\n   * });\n   * ```\n   *\n   * `schedule` can be a string in the Unix cron format or in JSON format\n   * as specified by interface {@linkcode CronSchedule}, where time is specified\n   * using UTC time zone.\n   *\n   * `backoffSchedule` option can be used to specify the retry policy for failed\n   * executions. Each element in the array represents the number of milliseconds\n   * to wait before retrying the execution. For example, `[1000, 5000, 10000]`\n   * means that a failed execution will be retried at most 3 times, with 1\n   * second, 5 seconds, and 10 seconds delay between each retry. There is a\n   * limit of 5 retries and a maximum interval of 1 hour (3600000 milliseconds).\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export function cron(\n    name: string,\n    schedule: string | CronSchedule,\n    options: { backoffSchedule?: number[]; signal?: AbortSignal },\n    handler: () => Promise<void> | void,\n  ): Promise<void>;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A key to be persisted in a {@linkcode Deno.Kv}. A key is a sequence\n   * of {@linkcode Deno.KvKeyPart}s.\n   *\n   * Keys are ordered lexicographically by their parts. The first part is the\n   * most significant, and the last part is the least significant. The order of\n   * the parts is determined by both the type and the value of the part. The\n   * relative significance of the types can be found in documentation for the\n   * {@linkcode Deno.KvKeyPart} type.\n   *\n   * Keys have a maximum size of 2048 bytes serialized. If the size of the key\n   * exceeds this limit, an error will be thrown on the operation that this key\n   * was passed to.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export type KvKey = readonly KvKeyPart[];\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A single part of a {@linkcode Deno.KvKey}. Parts are ordered\n   * lexicographically, first by their type, and within a given type by their\n   * value.\n   *\n   * The ordering of types is as follows:\n   *\n   * 1. `Uint8Array`\n   * 2. `string`\n   * 3. `number`\n   * 4. `bigint`\n   * 5. `boolean`\n   *\n   * Within a given type, the ordering is as follows:\n   *\n   * - `Uint8Array` is ordered by the byte ordering of the array\n   * - `string` is ordered by the byte ordering of the UTF-8 encoding of the\n   *   string\n   * - `number` is ordered following this pattern: `-NaN`\n   *   < `-Infinity` < `-100.0` < `-1.0` < -`0.5` < `-0.0` < `0.0` < `0.5`\n   *   < `1.0` < `100.0` < `Infinity` < `NaN`\n   * - `bigint` is ordered by mathematical ordering, with the largest negative\n   *   number being the least first value, and the largest positive number\n   *   being the last value\n   * - `boolean` is ordered by `false` < `true`\n   *\n   * This means that the part `1.0` (a number) is ordered before the part `2.0`\n   * (also a number), but is greater than the part `0n` (a bigint), because\n   * `1.0` is a number and `0n` is a bigint, and type ordering has precedence\n   * over the ordering of values within a type.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export type KvKeyPart =\n    | Uint8Array\n    | string\n    | number\n    | bigint\n    | boolean\n    | symbol;\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Consistency level of a KV operation.\n   *\n   * - `strong` - This operation must be strongly-consistent.\n   * - `eventual` - Eventually-consistent behavior is allowed.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export type KvConsistencyLevel = 'strong' | 'eventual';\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A selector that selects the range of data returned by a list operation on a\n   * {@linkcode Deno.Kv}.\n   *\n   * The selector can either be a prefix selector or a range selector. A prefix\n   * selector selects all keys that start with the given prefix (optionally\n   * starting at a given key). A range selector selects all keys that are\n   * lexicographically between the given start and end keys.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export type KvListSelector =\n    | { prefix: KvKey }\n    | { prefix: KvKey; start: KvKey }\n    | { prefix: KvKey; end: KvKey }\n    | { start: KvKey; end: KvKey };\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A mutation to a key in a {@linkcode Deno.Kv}. A mutation is a\n   * combination of a key, a value, and a type. The type determines how the\n   * mutation is applied to the key.\n   *\n   * - `set` - Sets the value of the key to the given value, overwriting any\n   *   existing value. Optionally an `expireIn` option can be specified to\n   *   set a time-to-live (TTL) for the key. The TTL is specified in\n   *   milliseconds, and the key will be deleted from the database at earliest\n   *   after the specified number of milliseconds have elapsed. Once the\n   *   specified duration has passed, the key may still be visible for some\n   *   additional time. If the `expireIn` option is not specified, the key will\n   *   not expire.\n   * - `delete` - Deletes the key from the database. The mutation is a no-op if\n   *   the key does not exist.\n   * - `sum` - Adds the given value to the existing value of the key. Both the\n   *   value specified in the mutation, and any existing value must be of type\n   *   `Deno.KvU64`. If the key does not exist, the value is set to the given\n   *   value (summed with 0). If the result of the sum overflows an unsigned\n   *   64-bit integer, the result is wrapped around.\n   * - `max` - Sets the value of the key to the maximum of the existing value\n   *   and the given value. Both the value specified in the mutation, and any\n   *   existing value must be of type `Deno.KvU64`. If the key does not exist,\n   *   the value is set to the given value.\n   * - `min` - Sets the value of the key to the minimum of the existing value\n   *   and the given value. Both the value specified in the mutation, and any\n   *   existing value must be of type `Deno.KvU64`. If the key does not exist,\n   *   the value is set to the given value.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export type KvMutation = { key: KvKey } & (\n    | { type: 'set'; value: unknown; expireIn?: number }\n    | { type: 'delete' }\n    | { type: 'sum'; value: KvU64 }\n    | { type: 'max'; value: KvU64 }\n    | { type: 'min'; value: KvU64 }\n  );\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * An iterator over a range of data entries in a {@linkcode Deno.Kv}.\n   *\n   * The cursor getter returns the cursor that can be used to resume the\n   * iteration from the current position in the future.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export class KvListIterator<T> implements AsyncIterableIterator<KvEntry<T>> {\n    /**\n     * Returns the cursor of the current position in the iteration. This cursor\n     * can be used to resume the iteration from the current position in the\n     * future by passing it to the `cursor` option of the `list` method.\n     */\n    get cursor(): string;\n\n    next(): Promise<IteratorResult<KvEntry<T>, undefined>>;\n    [Symbol.asyncIterator](): AsyncIterableIterator<KvEntry<T>>;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A versioned pair of key and value in a {@linkcode Deno.Kv}.\n   *\n   * The `versionstamp` is a string that represents the current version of the\n   * key-value pair. It can be used to perform atomic operations on the KV store\n   * by passing it to the `check` method of a {@linkcode Deno.AtomicOperation}.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export interface KvEntry<T> {\n    key: KvKey;\n    value: T;\n    versionstamp: string;\n  }\n\n  /**\n   * **UNSTABLE**: New API, yet to be vetted.\n   *\n   * An optional versioned pair of key and value in a {@linkcode Deno.Kv}.\n   *\n   * This is the same as a {@linkcode KvEntry}, but the `value` and `versionstamp`\n   * fields may be `null` if no value exists for the given key in the KV store.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export type KvEntryMaybe<T> =\n    | KvEntry<T>\n    | {\n        key: KvKey;\n        value: null;\n        versionstamp: null;\n      };\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Options for listing key-value pairs in a {@linkcode Deno.Kv}.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export interface KvListOptions {\n    /**\n     * The maximum number of key-value pairs to return. If not specified, all\n     * matching key-value pairs will be returned.\n     */\n    limit?: number;\n    /**\n     * The cursor to resume the iteration from. If not specified, the iteration\n     * will start from the beginning.\n     */\n    cursor?: string;\n    /**\n     * Whether to reverse the order of the returned key-value pairs. If not\n     * specified, the order will be ascending from the start of the range as per\n     * the lexicographical ordering of the keys. If `true`, the order will be\n     * descending from the end of the range.\n     *\n     * The default value is `false`.\n     */\n    reverse?: boolean;\n    /**\n     * The consistency level of the list operation. The default consistency\n     * level is \"strong\". Some use cases can benefit from using a weaker\n     * consistency level. For more information on consistency levels, see the\n     * documentation for {@linkcode Deno.KvConsistencyLevel}.\n     *\n     * List operations are performed in batches (in sizes specified by the\n     * `batchSize` option). The consistency level of the list operation is\n     * applied to each batch individually. This means that while each batch is\n     * guaranteed to be consistent within itself, the entire list operation may\n     * not be consistent across batches because a mutation may be applied to a\n     * key-value pair between batches, in a batch that has already been returned\n     * by the list operation.\n     */\n    consistency?: KvConsistencyLevel;\n    /**\n     * The size of the batches in which the list operation is performed. Larger\n     * or smaller batch sizes may positively or negatively affect the\n     * performance of a list operation depending on the specific use case and\n     * iteration behavior. Slow iterating queries may benefit from using a\n     * smaller batch size for increased overall consistency, while fast\n     * iterating queries may benefit from using a larger batch size for better\n     * performance.\n     *\n     * The default batch size is equal to the `limit` option, or 100 if this is\n     * unset. The maximum value for this option is 500. Larger values will be\n     * clamped.\n     */\n    batchSize?: number;\n  }\n\n  /**\n   * @category Cloud\n   * @experimental\n   */\n  export interface KvCommitResult {\n    ok: true;\n    /** The versionstamp of the value committed to KV. */\n    versionstamp: string;\n  }\n\n  /**\n   * @category Cloud\n   * @experimental\n   */\n  export interface KvCommitError {\n    ok: false;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A check to perform as part of a {@linkcode Deno.AtomicOperation}. The check\n   * will fail if the versionstamp for the key-value pair in the KV store does\n   * not match the given versionstamp. A check with a `null` versionstamp checks\n   * that the key-value pair does not currently exist in the KV store.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export interface AtomicCheck {\n    key: KvKey;\n    versionstamp: string | null;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * An operation on a {@linkcode Deno.Kv} that can be performed\n   * atomically. Atomic operations do not auto-commit, and must be committed\n   * explicitly by calling the `commit` method.\n   *\n   * Atomic operations can be used to perform multiple mutations on the KV store\n   * in a single atomic transaction. They can also be used to perform\n   * conditional mutations by specifying one or more\n   * {@linkcode Deno.AtomicCheck}s that ensure that a mutation is only performed\n   * if the key-value pair in the KV has a specific versionstamp. If any of the\n   * checks fail, the entire operation will fail and no mutations will be made.\n   *\n   * The ordering of mutations is guaranteed to be the same as the ordering of\n   * the mutations specified in the operation. Checks are performed before any\n   * mutations are performed. The ordering of checks is unobservable.\n   *\n   * Atomic operations can be used to implement optimistic locking, where a\n   * mutation is only performed if the key-value pair in the KV store has not\n   * been modified since the last read. This can be done by specifying a check\n   * that ensures that the versionstamp of the key-value pair matches the\n   * versionstamp that was read. If the check fails, the mutation will not be\n   * performed and the operation will fail. One can then retry the read-modify-\n   * write operation in a loop until it succeeds.\n   *\n   * The `commit` method of an atomic operation returns a value indicating\n   * whether checks passed and mutations were performed. If the operation failed\n   * because of a failed check, the return value will be a\n   * {@linkcode Deno.KvCommitError} with an `ok: false` property. If the\n   * operation failed for any other reason (storage error, invalid value, etc.),\n   * an exception will be thrown. If the operation succeeded, the return value\n   * will be a {@linkcode Deno.KvCommitResult} object with a `ok: true` property\n   * and the versionstamp of the value committed to KV.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export class AtomicOperation {\n    /**\n     * Add to the operation a check that ensures that the versionstamp of the\n     * key-value pair in the KV store matches the given versionstamp. If the\n     * check fails, the entire operation will fail and no mutations will be\n     * performed during the commit.\n     */\n    check(...checks: AtomicCheck[]): this;\n    /**\n     * Add to the operation a mutation that performs the specified mutation on\n     * the specified key if all checks pass during the commit. The types and\n     * semantics of all available mutations are described in the documentation\n     * for {@linkcode Deno.KvMutation}.\n     */\n    mutate(...mutations: KvMutation[]): this;\n    /**\n     * Shortcut for creating a `sum` mutation. This method wraps `n` in a\n     * {@linkcode Deno.KvU64}, so the value of `n` must be in the range\n     * `[0, 2^64-1]`.\n     */\n    sum(key: KvKey, n: bigint): this;\n    /**\n     * Shortcut for creating a `min` mutation. This method wraps `n` in a\n     * {@linkcode Deno.KvU64}, so the value of `n` must be in the range\n     * `[0, 2^64-1]`.\n     */\n    min(key: KvKey, n: bigint): this;\n    /**\n     * Shortcut for creating a `max` mutation. This method wraps `n` in a\n     * {@linkcode Deno.KvU64}, so the value of `n` must be in the range\n     * `[0, 2^64-1]`.\n     */\n    max(key: KvKey, n: bigint): this;\n    /**\n     * Add to the operation a mutation that sets the value of the specified key\n     * to the specified value if all checks pass during the commit.\n     *\n     * Optionally an `expireIn` option can be specified to set a time-to-live\n     * (TTL) for the key. The TTL is specified in milliseconds, and the key will\n     * be deleted from the database at earliest after the specified number of\n     * milliseconds have elapsed. Once the specified duration has passed, the\n     * key may still be visible for some additional time. If the `expireIn`\n     * option is not specified, the key will not expire.\n     */\n    set(key: KvKey, value: unknown, options?: { expireIn?: number }): this;\n    /**\n     * Add to the operation a mutation that deletes the specified key if all\n     * checks pass during the commit.\n     */\n    delete(key: KvKey): this;\n    /**\n     * Add to the operation a mutation that enqueues a value into the queue\n     * if all checks pass during the commit.\n     */\n    enqueue(\n      value: unknown,\n      options?: {\n        delay?: number;\n        keysIfUndelivered?: KvKey[];\n        backoffSchedule?: number[];\n      },\n    ): this;\n    /**\n     * Commit the operation to the KV store. Returns a value indicating whether\n     * checks passed and mutations were performed. If the operation failed\n     * because of a failed check, the return value will be a {@linkcode\n     * Deno.KvCommitError} with an `ok: false` property. If the operation failed\n     * for any other reason (storage error, invalid value, etc.), an exception\n     * will be thrown. If the operation succeeded, the return value will be a\n     * {@linkcode Deno.KvCommitResult} object with a `ok: true` property and the\n     * versionstamp of the value committed to KV.\n     *\n     * If the commit returns `ok: false`, one may create a new atomic operation\n     * with updated checks and mutations and attempt to commit it again. See the\n     * note on optimistic locking in the documentation for\n     * {@linkcode Deno.AtomicOperation}.\n     */\n    commit(): Promise<KvCommitResult | KvCommitError>;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * A key-value database that can be used to store and retrieve data.\n   *\n   * Data is stored as key-value pairs, where the key is a {@linkcode Deno.KvKey}\n   * and the value is an arbitrary structured-serializable JavaScript value.\n   * Keys are ordered lexicographically as described in the documentation for\n   * {@linkcode Deno.KvKey}. Keys are unique within a database, and the last\n   * value set for a given key is the one that is returned when reading the\n   * key. Keys can be deleted from the database, in which case they will no\n   * longer be returned when reading keys.\n   *\n   * Values can be any structured-serializable JavaScript value (objects,\n   * arrays, strings, numbers, etc.). The special value {@linkcode Deno.KvU64}\n   * can be used to store 64-bit unsigned integers in the database. This special\n   * value can not be nested within other objects or arrays. In addition to the\n   * regular database mutation operations, the unsigned 64-bit integer value\n   * also supports `sum`, `max`, and `min` mutations.\n   *\n   * Keys are versioned on write by assigning the key an ever-increasing\n   * \"versionstamp\". The versionstamp represents the version of a key-value pair\n   * in the database at some point in time, and can be used to perform\n   * transactional operations on the database without requiring any locking.\n   * This is enabled by atomic operations, which can have conditions that ensure\n   * that the operation only succeeds if the versionstamp of the key-value pair\n   * matches an expected versionstamp.\n   *\n   * Keys have a maximum length of 2048 bytes after serialization. Values have a\n   * maximum length of 64 KiB after serialization. Serialization of both keys\n   * and values is somewhat opaque, but one can usually assume that the\n   * serialization of any value is about the same length as the resulting string\n   * of a JSON serialization of that same value. If theses limits are exceeded,\n   * an exception will be thrown.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export class Kv implements Disposable {\n    /**\n     * Retrieve the value and versionstamp for the given key from the database\n     * in the form of a {@linkcode Deno.KvEntryMaybe}. If no value exists for\n     * the key, the returned entry will have a `null` value and versionstamp.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * const result = await db.get([\"foo\"]);\n     * result.key; // [\"foo\"]\n     * result.value; // \"bar\"\n     * result.versionstamp; // \"00000000000000010000\"\n     * ```\n     *\n     * The `consistency` option can be used to specify the consistency level\n     * for the read operation. The default consistency level is \"strong\". Some\n     * use cases can benefit from using a weaker consistency level. For more\n     * information on consistency levels, see the documentation for\n     * {@linkcode Deno.KvConsistencyLevel}.\n     */\n    get<T = unknown>(\n      key: KvKey,\n      options?: { consistency?: KvConsistencyLevel },\n    ): Promise<KvEntryMaybe<T>>;\n\n    /**\n     * Retrieve multiple values and versionstamps from the database in the form\n     * of an array of {@linkcode Deno.KvEntryMaybe} objects. The returned array\n     * will have the same length as the `keys` array, and the entries will be in\n     * the same order as the keys. If no value exists for a given key, the\n     * returned entry will have a `null` value and versionstamp.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * const result = await db.getMany([[\"foo\"], [\"baz\"]]);\n     * result[0].key; // [\"foo\"]\n     * result[0].value; // \"bar\"\n     * result[0].versionstamp; // \"00000000000000010000\"\n     * result[1].key; // [\"baz\"]\n     * result[1].value; // null\n     * result[1].versionstamp; // null\n     * ```\n     *\n     * The `consistency` option can be used to specify the consistency level\n     * for the read operation. The default consistency level is \"strong\". Some\n     * use cases can benefit from using a weaker consistency level. For more\n     * information on consistency levels, see the documentation for\n     * {@linkcode Deno.KvConsistencyLevel}.\n     */\n    getMany<T extends readonly unknown[]>(\n      keys: readonly [...{ [K in keyof T]: KvKey }],\n      options?: { consistency?: KvConsistencyLevel },\n    ): Promise<{ [K in keyof T]: KvEntryMaybe<T[K]> }>;\n    /**\n     * Set the value for the given key in the database. If a value already\n     * exists for the key, it will be overwritten.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * await db.set([\"foo\"], \"bar\");\n     * ```\n     *\n     * Optionally an `expireIn` option can be specified to set a time-to-live\n     * (TTL) for the key. The TTL is specified in milliseconds, and the key will\n     * be deleted from the database at earliest after the specified number of\n     * milliseconds have elapsed. Once the specified duration has passed, the\n     * key may still be visible for some additional time. If the `expireIn`\n     * option is not specified, the key will not expire.\n     */\n    set(\n      key: KvKey,\n      value: unknown,\n      options?: { expireIn?: number },\n    ): Promise<KvCommitResult>;\n\n    /**\n     * Delete the value for the given key from the database. If no value exists\n     * for the key, this operation is a no-op.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * await db.delete([\"foo\"]);\n     * ```\n     */\n    delete(key: KvKey): Promise<void>;\n\n    /**\n     * Retrieve a list of keys in the database. The returned list is an\n     * {@linkcode Deno.KvListIterator} which can be used to iterate over the\n     * entries in the database.\n     *\n     * Each list operation must specify a selector which is used to specify the\n     * range of keys to return. The selector can either be a prefix selector, or\n     * a range selector:\n     *\n     * - A prefix selector selects all keys that start with the given prefix of\n     *   key parts. For example, the selector `[\"users\"]` will select all keys\n     *   that start with the prefix `[\"users\"]`, such as `[\"users\", \"alice\"]`\n     *   and `[\"users\", \"bob\"]`. Note that you can not partially match a key\n     *   part, so the selector `[\"users\", \"a\"]` will not match the key\n     *   `[\"users\", \"alice\"]`. A prefix selector may specify a `start` key that\n     *   is used to skip over keys that are lexicographically less than the\n     *   start key.\n     * - A range selector selects all keys that are lexicographically between\n     *   the given start and end keys (including the start, and excluding the\n     *   end). For example, the selector `[\"users\", \"a\"], [\"users\", \"n\"]` will\n     *   select all keys that start with the prefix `[\"users\"]` and have a\n     *   second key part that is lexicographically between `a` and `n`, such as\n     *   `[\"users\", \"alice\"]`, `[\"users\", \"bob\"]`, and `[\"users\", \"mike\"]`, but\n     *   not `[\"users\", \"noa\"]` or `[\"users\", \"zoe\"]`.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * const entries = db.list({ prefix: [\"users\"] });\n     * for await (const entry of entries) {\n     *   entry.key; // [\"users\", \"alice\"]\n     *   entry.value; // { name: \"Alice\" }\n     *   entry.versionstamp; // \"00000000000000010000\"\n     * }\n     * ```\n     *\n     * The `options` argument can be used to specify additional options for the\n     * list operation. See the documentation for {@linkcode Deno.KvListOptions}\n     * for more information.\n     */\n    list<T = unknown>(\n      selector: KvListSelector,\n      options?: KvListOptions,\n    ): KvListIterator<T>;\n\n    /**\n     * Add a value into the database queue to be delivered to the queue\n     * listener via {@linkcode Deno.Kv.listenQueue}.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * await db.enqueue(\"bar\");\n     * ```\n     *\n     * The `delay` option can be used to specify the delay (in milliseconds)\n     * of the value delivery. The default delay is 0, which means immediate\n     * delivery.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * await db.enqueue(\"bar\", { delay: 60000 });\n     * ```\n     *\n     * The `keysIfUndelivered` option can be used to specify the keys to\n     * be set if the value is not successfully delivered to the queue\n     * listener after several attempts. The values are set to the value of\n     * the queued message.\n     *\n     * The `backoffSchedule` option can be used to specify the retry policy for\n     * failed message delivery. Each element in the array represents the number of\n     * milliseconds to wait before retrying the delivery. For example,\n     * `[1000, 5000, 10000]` means that a failed delivery will be retried\n     * at most 3 times, with 1 second, 5 seconds, and 10 seconds delay\n     * between each retry.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * await db.enqueue(\"bar\", {\n     *   keysIfUndelivered: [[\"foo\", \"bar\"]],\n     *   backoffSchedule: [1000, 5000, 10000],\n     * });\n     * ```\n     */\n    enqueue(\n      value: unknown,\n      options?: {\n        delay?: number;\n        keysIfUndelivered?: KvKey[];\n        backoffSchedule?: number[];\n      },\n    ): Promise<KvCommitResult>;\n\n    /**\n     * Listen for queue values to be delivered from the database queue, which\n     * were enqueued with {@linkcode Deno.Kv.enqueue}. The provided handler\n     * callback is invoked on every dequeued value. A failed callback\n     * invocation is automatically retried multiple times until it succeeds\n     * or until the maximum number of retries is reached.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     * db.listenQueue(async (msg: unknown) => {\n     *   await db.set([\"foo\"], msg);\n     * });\n     * ```\n     */\n    // deno-lint-ignore no-explicit-any\n    listenQueue(handler: (value: any) => Promise<void> | void): Promise<void>;\n\n    /**\n     * Create a new {@linkcode Deno.AtomicOperation} object which can be used to\n     * perform an atomic transaction on the database. This does not perform any\n     * operations on the database - the atomic transaction must be committed\n     * explicitly using the {@linkcode Deno.AtomicOperation.commit} method once\n     * all checks and mutations have been added to the operation.\n     */\n    atomic(): AtomicOperation;\n\n    /**\n     * Watch for changes to the given keys in the database. The returned stream\n     * is a {@linkcode ReadableStream} that emits a new value whenever any of\n     * the watched keys change their versionstamp. The emitted value is an array\n     * of {@linkcode Deno.KvEntryMaybe} objects, with the same length and order\n     * as the `keys` array. If no value exists for a given key, the returned\n     * entry will have a `null` value and versionstamp.\n     *\n     * The returned stream does not return every single intermediate state of\n     * the watched keys, but rather only keeps you up to date with the latest\n     * state of the keys. This means that if a key is modified multiple times\n     * quickly, you may not receive a notification for every single change, but\n     * rather only the latest state of the key.\n     *\n     * ```ts\n     * const db = await Deno.openKv();\n     *\n     * const stream = db.watch([[\"foo\"], [\"bar\"]]);\n     * for await (const entries of stream) {\n     *   entries[0].key; // [\"foo\"]\n     *   entries[0].value; // \"bar\"\n     *   entries[0].versionstamp; // \"00000000000000010000\"\n     *   entries[1].key; // [\"bar\"]\n     *   entries[1].value; // null\n     *   entries[1].versionstamp; // null\n     * }\n     * ```\n     *\n     * The `options` argument can be used to specify additional options for the\n     * watch operation. The `raw` option can be used to specify whether a new\n     * value should be emitted whenever a mutation occurs on any of the watched\n     * keys (even if the value of the key does not change, such as deleting a\n     * deleted key), or only when entries have observably changed in some way.\n     * When `raw: true` is used, it is possible for the stream to occasionally\n     * emit values even if no mutations have occurred on any of the watched\n     * keys. The default value for this option is `false`.\n     */\n    watch<T extends readonly unknown[]>(\n      keys: readonly [...{ [K in keyof T]: KvKey }],\n      options?: { raw?: boolean },\n    ): ReadableStream<{ [K in keyof T]: KvEntryMaybe<T[K]> }>;\n\n    /**\n     * Close the database connection. This will prevent any further operations\n     * from being performed on the database, and interrupt any in-flight\n     * operations immediately.\n     */\n    close(): void;\n\n    /**\n     * Get a symbol that represents the versionstamp of the current atomic\n     * operation. This symbol can be used as the last part of a key in\n     * `.set()`, both directly on the `Kv` object and on an `AtomicOperation`\n     * object created from this `Kv` instance.\n     */\n    commitVersionstamp(): symbol;\n\n    [Symbol.dispose](): void;\n  }\n\n  /** **UNSTABLE**: New API, yet to be vetted.\n   *\n   * Wrapper type for 64-bit unsigned integers for use as values in a\n   * {@linkcode Deno.Kv}.\n   *\n   * @category Cloud\n   * @experimental\n   */\n  export class KvU64 {\n    /** Create a new `KvU64` instance from the given bigint value. If the value\n     * is signed or greater than 64-bits, an error will be thrown. */\n    constructor(value: bigint);\n    /** The value of this unsigned 64-bit integer, represented as a bigint. */\n    readonly value: bigint;\n  }\n\n  /**\n   * A namespace containing runtime APIs available in Jupyter notebooks.\n   *\n   * When accessed outside of Jupyter notebook context an error will be thrown.\n   *\n   * @category Jupyter\n   * @experimental\n   */\n  export namespace jupyter {\n    /**\n     * @category Jupyter\n     * @experimental\n     */\n    export interface DisplayOptions {\n      raw?: boolean;\n      update?: boolean;\n      display_id?: string;\n    }\n\n    /**\n     * @category Jupyter\n     * @experimental\n     */\n    export interface VegaObject {\n      $schema: string;\n      [key: string]: unknown;\n    }\n\n    /**\n     * A collection of supported media types and data for Jupyter frontends.\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export interface MediaBundle {\n      'text/plain'?: string;\n      'text/html'?: string;\n      'image/svg+xml'?: string;\n      'text/markdown'?: string;\n      'application/javascript'?: string;\n\n      // Images (per Jupyter spec) must be base64 encoded. We could _allow_\n      // accepting Uint8Array or ArrayBuffer within `display` calls, however we still\n      // must encode them for jupyter.\n      'image/png'?: string; // WISH: Uint8Array | ArrayBuffer\n      'image/jpeg'?: string; // WISH: Uint8Array | ArrayBuffer\n      'image/gif'?: string; // WISH: Uint8Array | ArrayBuffer\n      'application/pdf'?: string; // WISH: Uint8Array | ArrayBuffer\n\n      // NOTE: all JSON types must be objects at the top level (no arrays, strings, or other primitives)\n      'application/json'?: object;\n      'application/geo+json'?: object;\n      'application/vdom.v1+json'?: object;\n      'application/vnd.plotly.v1+json'?: object;\n      'application/vnd.vega.v5+json'?: VegaObject;\n      'application/vnd.vegalite.v4+json'?: VegaObject;\n      'application/vnd.vegalite.v5+json'?: VegaObject;\n\n      // Must support a catch all for custom media types / mimetypes\n      [key: string]: string | object | undefined;\n    }\n\n    /**\n     * @category Jupyter\n     * @experimental\n     */\n    export const $display: unique symbol;\n\n    /**\n     * @category Jupyter\n     * @experimental\n     */\n    export interface Displayable {\n      [$display]: () => MediaBundle | Promise<MediaBundle>;\n    }\n\n    /**\n     * Display function for Jupyter Deno Kernel.\n     * Mimics the behavior of IPython's `display(obj, raw=True)` function to allow\n     * asynchronous displaying of objects in Jupyter.\n     *\n     * @param obj - The object to be displayed\n     * @param options - Display options with a default { raw: true }\n     * @category Jupyter\n     * @experimental\n     */\n    export function display(\n      obj: unknown,\n      options?: DisplayOptions,\n    ): Promise<void>;\n\n    /**\n     * Show Markdown in Jupyter frontends with a tagged template function.\n     *\n     * Takes a template string and returns a displayable object for Jupyter frontends.\n     *\n     * @example\n     * Create a Markdown view.\n     *\n     * ```typescript\n     * const { md } = Deno.jupyter;\n     * md`# Notebooks in TypeScript via Deno ![Deno logo](https://github.com/denoland.png?size=32)\n     *\n     * * TypeScript ${Deno.version.typescript}\n     * * V8 ${Deno.version.v8}\n     * * Deno ${Deno.version.deno}\n     *\n     * Interactive compute with Jupyter _built into Deno_!\n     * `\n     * ```\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function md(\n      strings: TemplateStringsArray,\n      ...values: unknown[]\n    ): Displayable;\n\n    /**\n     * Show HTML in Jupyter frontends with a tagged template function.\n     *\n     * Takes a template string and returns a displayable object for Jupyter frontends.\n     *\n     * @example\n     * Create an HTML view.\n     * ```typescript\n     * const { html } = Deno.jupyter;\n     * html`<h1>Hello, world!</h1>`\n     * ```\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function html(\n      strings: TemplateStringsArray,\n      ...values: unknown[]\n    ): Displayable;\n\n    /**\n     * SVG Tagged Template Function.\n     *\n     * Takes a template string and returns a displayable object for Jupyter frontends.\n     *\n     * Example usage:\n     *\n     * svg`<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\">\n     *      <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" />\n     *    </svg>`\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function svg(\n      strings: TemplateStringsArray,\n      ...values: unknown[]\n    ): Displayable;\n\n    /**\n     * Display a JPG or PNG image.\n     *\n     * ```\n     * Deno.jupyter.image(\"./cat.jpg\");\n     * Deno.jupyter.image(\"./dog.png\");\n     * ```\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function image(path: string): Displayable;\n\n    /**\n     * Display a JPG or PNG image.\n     *\n     * ```\n     * const img = Deno.readFileSync(\"./cat.jpg\");\n     * Deno.jupyter.image(img);\n     * ```\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function image(data: Uint8Array): Displayable;\n\n    /**\n     * Format an object for displaying in Deno\n     *\n     * @param obj - The object to be displayed\n     * @returns Promise<MediaBundle>\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function format(obj: unknown): Promise<MediaBundle>;\n\n    /**\n     * Broadcast a message on IO pub channel.\n     *\n     * ```\n     * await Deno.jupyter.broadcast(\"display_data\", {\n     *   data: { \"text/html\": \"<b>Processing.</b>\" },\n     *   metadata: {},\n     *   transient: { display_id: \"progress\" }\n     * });\n     *\n     * await new Promise((resolve) => setTimeout(resolve, 500));\n     *\n     * await Deno.jupyter.broadcast(\"update_display_data\", {\n     *   data: { \"text/html\": \"<b>Processing..</b>\" },\n     *   metadata: {},\n     *   transient: { display_id: \"progress\" }\n     * });\n     * ```\n     *\n     * @category Jupyter\n     * @experimental\n     */\n    export function broadcast(\n      msgType: string,\n      content: Record<string, unknown>,\n      extra?: {\n        metadata?: Record<string, unknown>;\n        buffers?: Uint8Array[];\n      },\n    ): Promise<void>;\n\n    export {}; // only export exports\n  }\n\n  /**\n   * @category Linter\n   * @experimental\n   */\n  export namespace lint {\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export type Range = [number, number];\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface Fix {\n      range: Range;\n      text?: string;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface Fixer {\n      insertTextAfter(node: Node, text: string): Fix;\n      insertTextAfterRange(range: Range, text: string): Fix;\n      insertTextBefore(node: Node, text: string): Fix;\n      insertTextBeforeRange(range: Range, text: string): Fix;\n      remove(node: Node): Fix;\n      removeRange(range: Range): Fix;\n      replaceText(node: Node, text: string): Fix;\n      replaceTextRange(range: Range, text: string): Fix;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ReportData {\n      node?: Node;\n      range?: Range;\n      message: string;\n      hint?: string;\n      fix?(fixer: Fixer): Fix | Iterable<Fix>;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface SourceCode {\n      /**\n       * Get the source test of a node. Omit `node` to get the\n       * full source code.\n       */\n      getText(node?: Node): string;\n      /**\n       * Returns array of ancestors of the current node, excluding the\n       * current node.\n       */\n      getAncestors(node: Node): Node[];\n\n      /**\n       * Get all comments inside the source.\n       */\n      getAllComments(): Array<LineComment | BlockComment>;\n\n      /**\n       * Get leading comments before a node.\n       */\n      getCommentsBefore(node: Node): Array<LineComment | BlockComment>;\n\n      /**\n       * Get trailing comments after a node.\n       */\n      getCommentsAfter(node: Node): Array<LineComment | BlockComment>;\n\n      /**\n       * Get comments inside a node.\n       */\n      getCommentsInside(node: Node): Array<LineComment | BlockComment>;\n\n      /**\n       * Get the full source code.\n       */\n      text: string;\n      /**\n       * Get the root node of the file. It's always the `Program` node.\n       */\n      ast: Program;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface RuleContext {\n      /**\n       * The running rule id: `<plugin-name>/<rule-name>`\n       */\n      id: string;\n      /**\n       * Name of the file that's currently being linted.\n       */\n      filename: string;\n      /**\n       * Helper methods for working with the raw source code.\n       */\n      sourceCode: SourceCode;\n      /**\n       * Report a lint error.\n       */\n      report(data: ReportData): void;\n      /**\n       * @deprecated Use `ctx.filename` instead.\n       */\n      getFilename(): string;\n      /**\n       * @deprecated Use `ctx.sourceCode` instead.\n       */\n      getSourceCode(): SourceCode;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export type LintVisitor = {\n      [P in Node['type']]?: (node: Extract<Node, { type: P }>) => void;\n    } & {\n      [P in Node['type'] as `${P}:exit`]?: (\n        node: Extract<Node, { type: P }>,\n      ) => void;\n    } & // Custom selectors which cannot be typed by us\n      // deno-lint-ignore no-explicit-any\n      Partial<{ [key: string]: (node: any) => void }>;\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface Rule {\n      create(ctx: RuleContext): LintVisitor;\n      destroy?(ctx: RuleContext): void;\n    }\n\n    /**\n     * In your plugins file do something like\n     *\n     * ```ts\n     * export default {\n     *   name: \"my-plugin\",\n     *   rules: {\n     *     \"no-foo\": {\n     *        create(ctx) {\n     *          return {\n     *             VariableDeclaration(node) {}\n     *          }\n     *        }\n     *     }\n     *   }\n     * } satisfies Deno.lint.Plugin\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface Plugin {\n      name: string;\n      rules: Record<string, Rule>;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface Diagnostic {\n      id: string;\n      message: string;\n      hint?: string;\n      range: Range;\n      fix?: Fix[];\n    }\n\n    /**\n     * This API is useful for testing lint plugins.\n     *\n     * It throws an error if it's not used in `deno test` subcommand.\n     * @category Linter\n     * @experimental\n     */\n    export function runPlugin(\n      plugin: Plugin,\n      fileName: string,\n      source: string,\n    ): Diagnostic[];\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface Program {\n      type: 'Program';\n      range: Range;\n      sourceType: 'module' | 'script';\n      body: Statement[];\n      comments: Array<LineComment | BlockComment>;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ImportSpecifier {\n      type: 'ImportSpecifier';\n      range: Range;\n      imported: Identifier | StringLiteral;\n      local: Identifier;\n      importKind: 'type' | 'value';\n      parent: ExportAllDeclaration | ExportNamedDeclaration | ImportDeclaration;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ImportDefaultSpecifier {\n      type: 'ImportDefaultSpecifier';\n      range: Range;\n      local: Identifier;\n      parent: ImportDeclaration;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ImportNamespaceSpecifier {\n      type: 'ImportNamespaceSpecifier';\n      range: Range;\n      local: Identifier;\n      parent: ImportDeclaration;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ImportAttribute {\n      type: 'ImportAttribute';\n      range: Range;\n      key: Identifier | Literal;\n      value: Literal;\n      parent:\n        | ExportAllDeclaration\n        | ExportNamedDeclaration\n        | ImportDeclaration\n        | TSImportType;\n    }\n\n    /**\n     * An import declaration, examples:\n     * @category Linter\n     * @experimental\n     */\n    export interface ImportDeclaration {\n      type: 'ImportDeclaration';\n      range: Range;\n      importKind: 'type' | 'value';\n      source: StringLiteral;\n      specifiers: Array<\n        ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier\n      >;\n      attributes: ImportAttribute[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ExportDefaultDeclaration {\n      type: 'ExportDefaultDeclaration';\n      range: Range;\n      declaration:\n        | ClassDeclaration\n        | Expression\n        | FunctionDeclaration\n        | TSDeclareFunction\n        | TSEnumDeclaration\n        | TSInterfaceDeclaration\n        | TSModuleDeclaration\n        | TSTypeAliasDeclaration\n        | VariableDeclaration;\n      exportKind: 'type' | 'value';\n      parent: BlockStatement | Program | TSModuleBlock;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ExportNamedDeclaration {\n      type: 'ExportNamedDeclaration';\n      range: Range;\n      exportKind: 'type' | 'value';\n      specifiers: ExportSpecifier[];\n      declaration:\n        | ClassDeclaration\n        | FunctionDeclaration\n        | TSDeclareFunction\n        | TSEnumDeclaration\n        | TSImportEqualsDeclaration\n        | TSInterfaceDeclaration\n        | TSModuleDeclaration\n        | TSTypeAliasDeclaration\n        | VariableDeclaration\n        | null;\n      source: StringLiteral | null;\n      attributes: ImportAttribute[];\n      parent: BlockStatement | Program | TSModuleBlock;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ExportAllDeclaration {\n      type: 'ExportAllDeclaration';\n      range: Range;\n      exportKind: 'type' | 'value';\n      exported: Identifier | null;\n      source: StringLiteral;\n      attributes: ImportAttribute[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSNamespaceExportDeclaration {\n      type: 'TSNamespaceExportDeclaration';\n      range: Range;\n      id: Identifier;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSImportEqualsDeclaration {\n      type: 'TSImportEqualsDeclaration';\n      range: Range;\n      importKind: 'type' | 'value';\n      id: Identifier;\n      moduleReference: Identifier | TSExternalModuleReference | TSQualifiedName;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSExternalModuleReference {\n      type: 'TSExternalModuleReference';\n      range: Range;\n      expression: StringLiteral;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface ExportSpecifier {\n      type: 'ExportSpecifier';\n      range: Range;\n      exportKind: 'type' | 'value';\n      exported: Identifier | StringLiteral;\n      local: Identifier | StringLiteral;\n      parent: ExportNamedDeclaration;\n    }\n\n    /**\n     * Variable declaration.\n     * @category Linter\n     * @experimental\n     */\n    export interface VariableDeclaration {\n      type: 'VariableDeclaration';\n      range: Range;\n      declare: boolean;\n      kind: 'let' | 'var' | 'const' | 'await using' | 'using';\n      declarations: VariableDeclarator[];\n      parent: Node;\n    }\n\n    /**\n     * A VariableDeclaration can declare multiple variables. This node\n     * represents a single declaration out of that.\n     * @category Linter\n     * @experimental\n     */\n    export interface VariableDeclarator {\n      type: 'VariableDeclarator';\n      range: Range;\n      id: ArrayPattern | ObjectPattern | Identifier;\n      init: Expression | null;\n      definite: boolean;\n      parent: VariableDeclaration;\n    }\n\n    /**\n     * Function/Method parameter\n     * @category Linter\n     * @experimental\n     */\n    export type Parameter =\n      | ArrayPattern\n      | AssignmentPattern\n      | Identifier\n      | ObjectPattern\n      | RestElement\n      | TSParameterProperty;\n\n    /**\n     * TypeScript accessibility modifiers used in classes\n     * @category Linter\n     * @experimental\n     */\n    export type Accessibility = 'private' | 'protected' | 'public';\n\n    /**\n     * Declares a function in the current scope\n     * @category Linter\n     * @experimental\n     */\n    export interface FunctionDeclaration {\n      type: 'FunctionDeclaration';\n      range: Range;\n      declare: boolean;\n      async: boolean;\n      generator: boolean;\n      id: Identifier | null;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      returnType: TSTypeAnnotation | undefined;\n      body: BlockStatement | null;\n      params: Parameter[];\n      parent:\n        | BlockStatement\n        | ExportDefaultDeclaration\n        | ExportNamedDeclaration\n        | Program;\n    }\n\n    /**\n     * Experimental: Decorators\n     * @category Linter\n     * @experimental\n     */\n    export interface Decorator {\n      type: 'Decorator';\n      range: Range;\n      expression:\n        | ArrayExpression\n        | ArrayPattern\n        | ArrowFunctionExpression\n        | CallExpression\n        | ClassExpression\n        | FunctionExpression\n        | Identifier\n        | JSXElement\n        | JSXFragment\n        | Literal\n        | TemplateLiteral\n        | MemberExpression\n        | MetaProperty\n        | ObjectExpression\n        | ObjectPattern\n        | SequenceExpression\n        | Super\n        | TaggedTemplateExpression\n        | ThisExpression\n        | TSAsExpression\n        | TSNonNullExpression\n        | TSTypeAssertion;\n      parent: Node;\n    }\n\n    /**\n     * Declares a class in the current scope\n     * @category Linter\n     * @experimental\n     */\n    export interface ClassDeclaration {\n      type: 'ClassDeclaration';\n      range: Range;\n      declare: boolean;\n      abstract: boolean;\n      id: Identifier | null;\n      superClass:\n        | ArrayExpression\n        | ArrayPattern\n        | ArrowFunctionExpression\n        | CallExpression\n        | ClassExpression\n        | FunctionExpression\n        | Identifier\n        | JSXElement\n        | JSXFragment\n        | Literal\n        | TemplateLiteral\n        | MemberExpression\n        | MetaProperty\n        | ObjectExpression\n        | ObjectPattern\n        | SequenceExpression\n        | Super\n        | TaggedTemplateExpression\n        | ThisExpression\n        | TSAsExpression\n        | TSNonNullExpression\n        | TSTypeAssertion\n        | null;\n      implements: TSClassImplements[];\n      body: ClassBody;\n      parent: Node;\n    }\n\n    /**\n     * Similar to ClassDeclaration but for declaring a class as an\n     * expression. The main difference is that the class name(=id) can\n     * be omitted.\n     * @category Linter\n     * @experimental\n     */\n    export interface ClassExpression {\n      type: 'ClassExpression';\n      range: Range;\n      declare: boolean;\n      abstract: boolean;\n      id: Identifier | null;\n      superClass:\n        | ArrayExpression\n        | ArrayPattern\n        | ArrowFunctionExpression\n        | CallExpression\n        | ClassExpression\n        | FunctionExpression\n        | Identifier\n        | JSXElement\n        | JSXFragment\n        | Literal\n        | TemplateLiteral\n        | MemberExpression\n        | MetaProperty\n        | ObjectExpression\n        | ObjectPattern\n        | SequenceExpression\n        | Super\n        | TaggedTemplateExpression\n        | ThisExpression\n        | TSAsExpression\n        | TSNonNullExpression\n        | TSTypeAssertion\n        | null;\n      superTypeArguments: TSTypeParameterInstantiation | undefined;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      implements: TSClassImplements[];\n      body: ClassBody;\n      parent: Node;\n    }\n\n    /**\n     * Represents the body of a class and contains all members\n     * @category Linter\n     * @experimental\n     */\n    export interface ClassBody {\n      type: 'ClassBody';\n      range: Range;\n      body: Array<\n        | AccessorProperty\n        | MethodDefinition\n        | PropertyDefinition\n        | StaticBlock\n        // Stage 1 Proposal:\n        // https://github.com/tc39/proposal-grouped-and-auto-accessors\n        // | TSAbstractAccessorProperty\n        | TSAbstractMethodDefinition\n        | TSAbstractPropertyDefinition\n        | TSIndexSignature\n      >;\n      parent: ClassDeclaration | ClassExpression;\n    }\n\n    /**\n     * Static class initializiation block.\n     * @category Linter\n     * @experimental\n     */\n    export interface StaticBlock {\n      type: 'StaticBlock';\n      range: Range;\n      body: Statement[];\n      parent: ClassBody;\n    }\n\n    // Stage 1 Proposal:\n    // https://github.com/tc39/proposal-grouped-and-auto-accessors\n    // | TSAbstractAccessorProperty\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface AccessorProperty {\n      type: 'AccessorProperty';\n      range: Range;\n      declare: boolean;\n      computed: boolean;\n      optional: boolean;\n      override: boolean;\n      readonly: boolean;\n      static: boolean;\n      accessibility: Accessibility | undefined;\n      decorators: Decorator[];\n      key: Expression | Identifier | NumberLiteral | StringLiteral;\n      value: Expression | null;\n      parent: ClassBody;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface PropertyDefinition {\n      type: 'PropertyDefinition';\n      range: Range;\n      declare: boolean;\n      computed: boolean;\n      optional: boolean;\n      override: boolean;\n      readonly: boolean;\n      static: boolean;\n      accessibility: Accessibility | undefined;\n      decorators: Decorator[];\n      key:\n        | Expression\n        | Identifier\n        | NumberLiteral\n        | StringLiteral\n        | PrivateIdentifier;\n      value: Expression | null;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      parent: ClassBody;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface MethodDefinition {\n      type: 'MethodDefinition';\n      range: Range;\n      declare: boolean;\n      computed: boolean;\n      optional: boolean;\n      override: boolean;\n      readonly: boolean;\n      static: boolean;\n      kind: 'constructor' | 'get' | 'method' | 'set';\n      accessibility: Accessibility | undefined;\n      decorators: Decorator[];\n      key:\n        | PrivateIdentifier\n        | Identifier\n        | NumberLiteral\n        | StringLiteral\n        | Expression;\n      value: FunctionExpression | TSEmptyBodyFunctionExpression;\n      parent: ClassBody;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface BlockStatement {\n      type: 'BlockStatement';\n      range: Range;\n      body: Statement[];\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * The `debugger;` statement.\n     * @category Linter\n     * @experimental\n     */\n    export interface DebuggerStatement {\n      type: 'DebuggerStatement';\n      range: Range;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Legacy JavaScript feature, that's discouraged from being used today.\n     * @deprecated\n     * @category Linter\n     * @experimental\n     */\n    export interface WithStatement {\n      type: 'WithStatement';\n      range: Range;\n      object: Expression;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Returns a value from a function.\n     * @category Linter\n     * @experimental\n     */\n    export interface ReturnStatement {\n      type: 'ReturnStatement';\n      range: Range;\n      argument: Expression | null;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Custom control flow based on labels.\n     * @category Linter\n     * @experimental\n     */\n    export interface LabeledStatement {\n      type: 'LabeledStatement';\n      range: Range;\n      label: Identifier;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Break any loop or labeled statement, example:\n     *\n     * ```ts\n     * while (true) {\n     *   break;\n     * }\n     *\n     * for (let i = 0; i < 10; i++) {\n     *   if (i > 5) break;\n     * }\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface BreakStatement {\n      type: 'BreakStatement';\n      range: Range;\n      label: Identifier | null;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Terminates the current loop and continues with the next iteration.\n     * @category Linter\n     * @experimental\n     */\n    export interface ContinueStatement {\n      type: 'ContinueStatement';\n      range: Range;\n      label: Identifier | null;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Execute a statement the test passes, otherwise the alternate\n     * statement, if it was defined.\n     * @category Linter\n     * @experimental\n     */\n    export interface IfStatement {\n      type: 'IfStatement';\n      range: Range;\n      test: Expression;\n      consequent: Statement;\n      alternate: Statement | null;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Match an expression against a series of cases.\n     * @category Linter\n     * @experimental\n     */\n    export interface SwitchStatement {\n      type: 'SwitchStatement';\n      range: Range;\n      discriminant: Expression;\n      cases: SwitchCase[];\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * A single case of a SwitchStatement.\n     * @category Linter\n     * @experimental\n     */\n    export interface SwitchCase {\n      type: 'SwitchCase';\n      range: Range;\n      test: Expression | null;\n      consequent: Statement[];\n      parent: SwitchStatement;\n    }\n\n    /**\n     * Throw a user defined exception. Stops execution\n     * of the current function.\n     * @category Linter\n     * @experimental\n     */\n    export interface ThrowStatement {\n      type: 'ThrowStatement';\n      range: Range;\n      argument: Expression;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Run a loop while the test expression is truthy.\n     * @category Linter\n     * @experimental\n     */\n    export interface WhileStatement {\n      type: 'WhileStatement';\n      range: Range;\n      test: Expression;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Re-run loop for as long as test expression is truthy.\n     * @category Linter\n     * @experimental\n     */\n    export interface DoWhileStatement {\n      type: 'DoWhileStatement';\n      range: Range;\n      test: Expression;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Classic for-loop.\n     * @category Linter\n     * @experimental\n     */\n    export interface ForStatement {\n      type: 'ForStatement';\n      range: Range;\n      init: Expression | VariableDeclaration | null;\n      test: Expression | null;\n      update: Expression | null;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Enumerate over all enumerable string properties of an object.\n     * @category Linter\n     * @experimental\n     */\n    export interface ForInStatement {\n      type: 'ForInStatement';\n      range: Range;\n      left: Expression | VariableDeclaration;\n      right: Expression;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Iterate over sequence of values from an iterator.\n     * @category Linter\n     * @experimental\n     */\n    export interface ForOfStatement {\n      type: 'ForOfStatement';\n      range: Range;\n      await: boolean;\n      left: Expression | VariableDeclaration;\n      right: Expression;\n      body: Statement;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Statement that holds an expression.\n     * @category Linter\n     * @experimental\n     */\n    export interface ExpressionStatement {\n      type: 'ExpressionStatement';\n      range: Range;\n      expression: Expression;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Try/catch statement\n     * @category Linter\n     * @experimental\n     */\n    export interface TryStatement {\n      type: 'TryStatement';\n      range: Range;\n      block: BlockStatement;\n      handler: CatchClause | null;\n      finalizer: BlockStatement | null;\n      parent:\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * The catch clause of a try/catch statement\n     * @category Linter\n     * @experimental\n     */\n    export interface CatchClause {\n      type: 'CatchClause';\n      range: Range;\n      param: ArrayPattern | ObjectPattern | Identifier | null;\n      body: BlockStatement;\n      parent: TryStatement;\n    }\n\n    /**\n     * An array literal\n     * @category Linter\n     * @experimental\n     */\n    export interface ArrayExpression {\n      type: 'ArrayExpression';\n      range: Range;\n      elements: Array<Expression | SpreadElement>;\n      parent: Node;\n    }\n\n    /**\n     * An object literal.\n     * @category Linter\n     * @experimental\n     */\n    export interface ObjectExpression {\n      type: 'ObjectExpression';\n      range: Range;\n      properties: Array<Property | SpreadElement>;\n      parent: Node;\n    }\n\n    /**\n     * Compare left and right value with the specifier operator.\n     * @category Linter\n     * @experimental\n     */\n    export interface BinaryExpression {\n      type: 'BinaryExpression';\n      range: Range;\n      operator:\n        | '&'\n        | '**'\n        | '*'\n        | '||'\n        | '|'\n        | '^'\n        | '==='\n        | '=='\n        | '!=='\n        | '!='\n        | '>='\n        | '>>>'\n        | '>>'\n        | '>'\n        | 'in'\n        | 'instanceof'\n        | '<='\n        | '<<'\n        | '<'\n        | '-'\n        | '%'\n        | '+'\n        | '/';\n      left: Expression | PrivateIdentifier;\n      right: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Chain expressions based on the operator specified\n     * @category Linter\n     * @experimental\n     */\n    export interface LogicalExpression {\n      type: 'LogicalExpression';\n      range: Range;\n      operator: '&&' | '??' | '||';\n      left: Expression;\n      right: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Declare a function as an expression. Similar to `FunctionDeclaration`,\n     * with an optional name (=id).\n     * @category Linter\n     * @experimental\n     */\n    export interface FunctionExpression {\n      type: 'FunctionExpression';\n      range: Range;\n      async: boolean;\n      generator: boolean;\n      id: Identifier | null;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      params: Parameter[];\n      returnType: TSTypeAnnotation | undefined;\n      body: BlockStatement;\n      parent: Node;\n    }\n\n    /**\n     * Arrow function expression\n     * @category Linter\n     * @experimental\n     */\n    export interface ArrowFunctionExpression {\n      type: 'ArrowFunctionExpression';\n      range: Range;\n      async: boolean;\n      generator: boolean;\n      id: null;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      params: Parameter[];\n      returnType: TSTypeAnnotation | undefined;\n      body: BlockStatement | Expression;\n      parent: Node;\n    }\n\n    /**\n     * The `this` keyword used in classes.\n     * @category Linter\n     * @experimental\n     */\n    export interface ThisExpression {\n      type: 'ThisExpression';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * The `super` keyword used in classes.\n     * @category Linter\n     * @experimental\n     */\n    export interface Super {\n      type: 'Super';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * Apply operand on value based on the specified operator.\n     * @category Linter\n     * @experimental\n     */\n    export interface UnaryExpression {\n      type: 'UnaryExpression';\n      range: Range;\n      operator: '!' | '+' | '~' | '-' | 'delete' | 'typeof' | 'void';\n      argument: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Create a new instance of a class.\n     * @category Linter\n     * @experimental\n     */\n    export interface NewExpression {\n      type: 'NewExpression';\n      range: Range;\n      callee: Expression;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      arguments: Array<Expression | SpreadElement>;\n      parent: Node;\n    }\n\n    /**\n     * Dynamically import a module.\n     * @category Linter\n     * @experimental\n     */\n    export interface ImportExpression {\n      type: 'ImportExpression';\n      range: Range;\n      source: Expression;\n      options: Expression | null;\n      parent: Node;\n    }\n\n    /**\n     * A function call.\n     * @category Linter\n     * @experimental\n     */\n    export interface CallExpression {\n      type: 'CallExpression';\n      range: Range;\n      optional: boolean;\n      callee: Expression;\n      typeArguments: TSTypeParameterInstantiation | null;\n      arguments: Array<Expression | SpreadElement>;\n      parent: Node;\n    }\n\n    /**\n     * Syntactic sugar to increment or decrement a value.\n     * @category Linter\n     * @experimental\n     */\n    export interface UpdateExpression {\n      type: 'UpdateExpression';\n      range: Range;\n      prefix: boolean;\n      operator: '++' | '--';\n      argument: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Updaate a variable or property.\n     * @category Linter\n     * @experimental\n     */\n    export interface AssignmentExpression {\n      type: 'AssignmentExpression';\n      range: Range;\n      operator:\n        | '&&='\n        | '&='\n        | '**='\n        | '*='\n        | '||='\n        | '|='\n        | '^='\n        | '='\n        | '>>='\n        | '>>>='\n        | '<<='\n        | '-='\n        | '%='\n        | '+='\n        | '??='\n        | '/=';\n      left: Expression;\n      right: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Inline if-statement.\n     * @category Linter\n     * @experimental\n     */\n    export interface ConditionalExpression {\n      type: 'ConditionalExpression';\n      range: Range;\n      test: Expression;\n      consequent: Expression;\n      alternate: Expression;\n      parent: Node;\n    }\n\n    /**\n     * MemberExpression\n     * @category Linter\n     * @experimental\n     */\n    export interface MemberExpression {\n      type: 'MemberExpression';\n      range: Range;\n      optional: boolean;\n      computed: boolean;\n      object: Expression;\n      property: Expression | Identifier | PrivateIdentifier;\n      parent: Node;\n    }\n\n    /**\n     * ChainExpression\n     * @category Linter\n     * @experimental\n     */\n    export interface ChainExpression {\n      type: 'ChainExpression';\n      range: Range;\n      expression: CallExpression | MemberExpression | TSNonNullExpression;\n      parent: Node;\n    }\n\n    /**\n     * Execute multiple expressions in sequence.\n     * @category Linter\n     * @experimental\n     */\n    export interface SequenceExpression {\n      type: 'SequenceExpression';\n      range: Range;\n      expressions: Expression[];\n      parent: Node;\n    }\n\n    /**\n     * A template literal string.\n     * @category Linter\n     * @experimental\n     */\n    export interface TemplateLiteral {\n      type: 'TemplateLiteral';\n      range: Range;\n      quasis: TemplateElement[];\n      expressions: Expression[];\n      parent: Node;\n    }\n\n    /**\n     * The static portion of a template literal.\n     * @category Linter\n     * @experimental\n     */\n    export interface TemplateElement {\n      type: 'TemplateElement';\n      range: Range;\n      tail: boolean;\n      raw: string;\n      cooked: string;\n      parent: TemplateLiteral | TSTemplateLiteralType;\n    }\n\n    /**\n     * Tagged template expression.\n     * @category Linter\n     * @experimental\n     */\n    export interface TaggedTemplateExpression {\n      type: 'TaggedTemplateExpression';\n      range: Range;\n      tag: Expression;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      quasi: TemplateLiteral;\n      parent: Node;\n    }\n\n    /**\n     * Pause or resume a generator function.\n     * @category Linter\n     * @experimental\n     */\n    export interface YieldExpression {\n      type: 'YieldExpression';\n      range: Range;\n      delegate: boolean;\n      argument: Expression | null;\n      parent: Node;\n    }\n\n    /**\n     * Await a `Promise` and get its fulfilled value.\n     * @category Linter\n     * @experimental\n     */\n    export interface AwaitExpression {\n      type: 'AwaitExpression';\n      range: Range;\n      argument: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Can either be `import.meta` or `new.target`.\n     * @category Linter\n     * @experimental\n     */\n    export interface MetaProperty {\n      type: 'MetaProperty';\n      range: Range;\n      meta: Identifier;\n      property: Identifier;\n      parent: Node;\n    }\n\n    /**\n     * Custom named node by the developer. Can be a variable name,\n     * a function name, parameter, etc.\n     * @category Linter\n     * @experimental\n     */\n    export interface Identifier {\n      type: 'Identifier';\n      range: Range;\n      name: string;\n      optional: boolean;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      parent: Node;\n    }\n\n    /**\n     * Private members inside of classes, must start with `#`.\n     * @category Linter\n     * @experimental\n     */\n    export interface PrivateIdentifier {\n      type: 'PrivateIdentifier';\n      range: Range;\n      name: string;\n      parent:\n        | TSAbstractPropertyDefinition\n        | TSPropertySignature\n        | PropertyDefinition\n        | MethodDefinition\n        | BinaryExpression\n        | MemberExpression;\n    }\n\n    /**\n     * Assign default values in parameters.\n     * @category Linter\n     * @experimental\n     */\n    export interface AssignmentPattern {\n      type: 'AssignmentPattern';\n      range: Range;\n      left: ArrayPattern | ObjectPattern | Identifier;\n      right: Expression;\n      parent: Node;\n    }\n\n    /**\n     * Destructure an array.\n     * @category Linter\n     * @experimental\n     */\n    export interface ArrayPattern {\n      type: 'ArrayPattern';\n      range: Range;\n      optional: boolean;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      elements: Array<\n        | ArrayPattern\n        | AssignmentPattern\n        | Identifier\n        | MemberExpression\n        | ObjectPattern\n        | RestElement\n        | null\n      >;\n      parent: Node;\n    }\n\n    /**\n     * Destructure an object.\n     * @category Linter\n     * @experimental\n     */\n    export interface ObjectPattern {\n      type: 'ObjectPattern';\n      range: Range;\n      optional: boolean;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      properties: Array<Property | RestElement>;\n      parent: Node;\n    }\n\n    /**\n     * The rest of function parameters.\n     * @category Linter\n     * @experimental\n     */\n    export interface RestElement {\n      type: 'RestElement';\n      range: Range;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      argument:\n        | ArrayPattern\n        | AssignmentPattern\n        | Identifier\n        | MemberExpression\n        | ObjectPattern\n        | RestElement;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface SpreadElement {\n      type: 'SpreadElement';\n      range: Range;\n      argument: Expression;\n      parent:\n        | ArrayExpression\n        | CallExpression\n        | NewExpression\n        | ObjectExpression;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface Property {\n      type: 'Property';\n      range: Range;\n      shorthand: boolean;\n      computed: boolean;\n      method: boolean;\n      kind: 'get' | 'init' | 'set';\n      key: Expression | Identifier | NumberLiteral | StringLiteral;\n      value:\n        | AssignmentPattern\n        | ArrayPattern\n        | ObjectPattern\n        | Identifier\n        | Expression\n        | TSEmptyBodyFunctionExpression;\n      parent: ObjectExpression | ObjectPattern;\n    }\n\n    /**\n     * Represents numbers that are too high or too low to be represented\n     * by the `number` type.\n     *\n     * ```ts\n     * const a = 9007199254740991n;\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface BigIntLiteral {\n      type: 'Literal';\n      range: Range;\n      raw: string;\n      bigint: string;\n      value: bigint;\n      parent: Node;\n    }\n\n    /**\n     * Either `true` or `false`\n     * @category Linter\n     * @experimental\n     */\n    export interface BooleanLiteral {\n      type: 'Literal';\n      range: Range;\n      raw: 'false' | 'true';\n      value: boolean;\n      parent: Node;\n    }\n\n    /**\n     * A number literal\n     *\n     * ```ts\n     * 1;\n     * 1.2;\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface NumberLiteral {\n      type: 'Literal';\n      range: Range;\n      raw: string;\n      value: number;\n      parent: Node;\n    }\n\n    /**\n     * The `null` literal\n     * @category Linter\n     * @experimental\n     */\n    export interface NullLiteral {\n      type: 'Literal';\n      range: Range;\n      raw: 'null';\n      value: null;\n      parent: Node;\n    }\n\n    /**\n     * A string literal\n     *\n     * ```ts\n     * \"foo\";\n     * 'foo \"bar\"';\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface StringLiteral {\n      type: 'Literal';\n      range: Range;\n      raw: string;\n      value: string;\n      parent: Node;\n    }\n\n    /**\n     * A regex literal:\n     *\n     * ```ts\n     * /foo(bar|baz)$/g\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface RegExpLiteral {\n      type: 'Literal';\n      range: Range;\n      raw: string;\n      regex: {\n        flags: string;\n        pattern: string;\n      };\n      value: RegExp | null;\n      parent: Node;\n    }\n\n    /**\n     * Union type of all Literals\n     * @category Linter\n     * @experimental\n     */\n    export type Literal =\n      | BigIntLiteral\n      | BooleanLiteral\n      | NullLiteral\n      | NumberLiteral\n      | RegExpLiteral\n      | StringLiteral;\n\n    /**\n     * User named identifier inside JSX.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXIdentifier {\n      type: 'JSXIdentifier';\n      range: Range;\n      name: string;\n      parent:\n        | JSXNamespacedName\n        | JSXOpeningElement\n        | JSXAttribute\n        | JSXClosingElement\n        | JSXMemberExpression;\n    }\n\n    /**\n     * Namespaced name in JSX\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXNamespacedName {\n      type: 'JSXNamespacedName';\n      range: Range;\n      namespace: JSXIdentifier;\n      name: JSXIdentifier;\n      parent:\n        | JSXOpeningElement\n        | JSXAttribute\n        | JSXClosingElement\n        | JSXMemberExpression;\n    }\n\n    /**\n     * Empty JSX expression.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXEmptyExpression {\n      type: 'JSXEmptyExpression';\n      range: Range;\n      parent: JSXAttribute | JSXElement | JSXFragment;\n    }\n\n    /**\n     * A JSX element.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXElement {\n      type: 'JSXElement';\n      range: Range;\n      openingElement: JSXOpeningElement;\n      closingElement: JSXClosingElement | null;\n      children: JSXChild[];\n      parent: Node;\n    }\n\n    /**\n     * The opening tag of a JSXElement\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXOpeningElement {\n      type: 'JSXOpeningElement';\n      range: Range;\n      selfClosing: boolean;\n      name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;\n      attributes: Array<JSXAttribute | JSXSpreadAttribute>;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      parent: JSXElement;\n    }\n\n    /**\n     * A JSX attribute\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXAttribute {\n      type: 'JSXAttribute';\n      range: Range;\n      name: JSXIdentifier | JSXNamespacedName;\n      value: JSXElement | JSXExpressionContainer | Literal | null;\n      parent: JSXOpeningElement;\n    }\n\n    /**\n     * Spreads an object as JSX attributes.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXSpreadAttribute {\n      type: 'JSXSpreadAttribute';\n      range: Range;\n      argument: Expression;\n      parent: JSXOpeningElement;\n    }\n\n    /**\n     * The closing tag of a JSXElement. Only used when the element\n     * is not self-closing.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXClosingElement {\n      type: 'JSXClosingElement';\n      range: Range;\n      name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;\n      parent: JSXElement;\n    }\n\n    /**\n     * Usually a passthrough node to pass multiple sibling elements as\n     * the JSX syntax requires one root element.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXFragment {\n      type: 'JSXFragment';\n      range: Range;\n      openingFragment: JSXOpeningFragment;\n      closingFragment: JSXClosingFragment;\n      children: JSXChild[];\n      parent: Node;\n    }\n\n    /**\n     * The opening tag of a JSXFragment.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXOpeningFragment {\n      type: 'JSXOpeningFragment';\n      range: Range;\n      parent: JSXFragment;\n    }\n\n    /**\n     * The closing tag of a JSXFragment.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXClosingFragment {\n      type: 'JSXClosingFragment';\n      range: Range;\n      parent: JSXFragment;\n    }\n\n    /**\n     * Inserts a normal JS expression into JSX.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXExpressionContainer {\n      type: 'JSXExpressionContainer';\n      range: Range;\n      expression: Expression | JSXEmptyExpression;\n      parent: JSXAttribute | JSXElement | JSXFragment;\n    }\n\n    /**\n     * Plain text in JSX.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXText {\n      type: 'JSXText';\n      range: Range;\n      raw: string;\n      value: string;\n      parent: JSXElement | JSXFragment;\n    }\n\n    /**\n     * JSX member expression.\n     * @category Linter\n     * @experimental\n     */\n    export interface JSXMemberExpression {\n      type: 'JSXMemberExpression';\n      range: Range;\n      object: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;\n      property: JSXIdentifier;\n      parent: JSXOpeningElement | JSXClosingElement;\n    }\n\n    /**\n     * Union type of all possible child nodes in JSX\n     * @category Linter\n     * @experimental\n     */\n    export type JSXChild =\n      | JSXElement\n      | JSXExpressionContainer\n      | JSXFragment\n      | JSXText;\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSModuleDeclaration {\n      type: 'TSModuleDeclaration';\n      range: Range;\n      declare: boolean;\n      kind: 'global' | 'module' | 'namespace';\n      id: Identifier | Literal | TSQualifiedName;\n      body: TSModuleBlock | undefined;\n      parent:\n        | ExportDefaultDeclaration\n        | ExportNamedDeclaration\n        | Program\n        | StaticBlock\n        | BlockStatement\n        | WithStatement\n        | LabeledStatement\n        | IfStatement\n        | SwitchCase\n        | WhileStatement\n        | DoWhileStatement\n        | ForStatement\n        | ForInStatement\n        | ForOfStatement\n        | TSModuleBlock;\n    }\n\n    /**\n     * Body of a `TSModuleDeclaration`\n     * @category Linter\n     * @experimental\n     */\n    export interface TSModuleBlock {\n      type: 'TSModuleBlock';\n      range: Range;\n      body: Array<\n        | ExportAllDeclaration\n        | ExportDefaultDeclaration\n        | ExportNamedDeclaration\n        | ImportDeclaration\n        | Statement\n        | TSImportEqualsDeclaration\n        | TSNamespaceExportDeclaration\n      >;\n      parent: TSModuleDeclaration;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSClassImplements {\n      type: 'TSClassImplements';\n      range: Range;\n      expression: Expression;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      parent: ClassDeclaration | ClassExpression;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSAbstractMethodDefinition {\n      type: 'TSAbstractMethodDefinition';\n      range: Range;\n      computed: boolean;\n      optional: boolean;\n      override: boolean;\n      static: boolean;\n      accessibility: Accessibility | undefined;\n      kind: 'method';\n      key: Expression | Identifier | NumberLiteral | StringLiteral;\n      value: FunctionExpression | TSEmptyBodyFunctionExpression;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSAbstractPropertyDefinition {\n      type: 'TSAbstractPropertyDefinition';\n      range: Range;\n      computed: boolean;\n      optional: boolean;\n      override: boolean;\n      static: boolean;\n      definite: boolean;\n      declare: boolean;\n      readonly: boolean;\n      accessibility: Accessibility | undefined;\n      decorators: Decorator[];\n      key:\n        | Expression\n        | PrivateIdentifier\n        | Identifier\n        | NumberLiteral\n        | StringLiteral;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      value: Expression | null;\n      parent: ClassBody;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSEmptyBodyFunctionExpression {\n      type: 'TSEmptyBodyFunctionExpression';\n      range: Range;\n      declare: boolean;\n      expression: boolean;\n      async: boolean;\n      generator: boolean;\n      id: null;\n      body: null;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      params: Parameter[];\n      returnType: TSTypeAnnotation | undefined;\n      parent:\n        | MethodDefinition\n        | Property\n        | TSAbstractMethodDefinition\n        | TSParameterProperty;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSParameterProperty {\n      type: 'TSParameterProperty';\n      range: Range;\n      override: boolean;\n      readonly: boolean;\n      static: boolean;\n      accessibility: Accessibility | undefined;\n      decorators: Decorator[];\n      parameter:\n        | AssignmentPattern\n        | ArrayPattern\n        | ObjectPattern\n        | Identifier\n        | RestElement;\n      parent:\n        | ArrowFunctionExpression\n        | FunctionDeclaration\n        | FunctionExpression\n        | TSDeclareFunction\n        | TSEmptyBodyFunctionExpression;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSCallSignatureDeclaration {\n      type: 'TSCallSignatureDeclaration';\n      range: Range;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      params: Parameter[];\n      returnType: TSTypeAnnotation | undefined;\n      parent: TSInterfaceBody | TSTypeLiteral;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSPropertySignature {\n      type: 'TSPropertySignature';\n      range: Range;\n      computed: boolean;\n      optional: boolean;\n      readonly: boolean;\n      static: boolean;\n      key:\n        | PrivateIdentifier\n        | Expression\n        | Identifier\n        | NumberLiteral\n        | StringLiteral;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      parent: TSInterfaceBody | TSTypeLiteral;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSDeclareFunction {\n      type: 'TSDeclareFunction';\n      range: Range;\n      async: boolean;\n      declare: boolean;\n      generator: boolean;\n      body: undefined;\n      id: Identifier | null;\n      params: Parameter[];\n      returnType: TSTypeAnnotation | undefined;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      parent: Node;\n    }\n\n    /**\n     * ```ts\n     * enum Foo { A, B };\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface TSEnumDeclaration {\n      type: 'TSEnumDeclaration';\n      range: Range;\n      declare: boolean;\n      const: boolean;\n      id: Identifier;\n      body: TSEnumBody;\n      parent: Node;\n    }\n\n    /**\n     * The body of a `TSEnumDeclaration`\n     * @category Linter\n     * @experimental\n     */\n    export interface TSEnumBody {\n      type: 'TSEnumBody';\n      range: Range;\n      members: TSEnumMember[];\n      parent: TSEnumDeclaration;\n    }\n\n    /**\n     * A member of a `TSEnumDeclaration`\n     * @category Linter\n     * @experimental\n     */\n    export interface TSEnumMember {\n      type: 'TSEnumMember';\n      range: Range;\n      id: Identifier | NumberLiteral | StringLiteral;\n      initializer: Expression | undefined;\n      parent: TSEnumBody;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeAssertion {\n      type: 'TSTypeAssertion';\n      range: Range;\n      expression: Expression;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeParameterInstantiation {\n      type: 'TSTypeParameterInstantiation';\n      range: Range;\n      params: TypeNode[];\n      parent:\n        | ClassExpression\n        | NewExpression\n        | CallExpression\n        | TaggedTemplateExpression\n        | JSXOpeningElement\n        | TSClassImplements\n        | TSInstantiationExpression\n        | TSInterfaceHeritage\n        | TSTypeQuery\n        | TSTypeReference\n        | TSImportType;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeAliasDeclaration {\n      type: 'TSTypeAliasDeclaration';\n      range: Range;\n      declare: boolean;\n      id: Identifier;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSSatisfiesExpression {\n      type: 'TSSatisfiesExpression';\n      range: Range;\n      expression: Expression;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSAsExpression {\n      type: 'TSAsExpression';\n      range: Range;\n      expression: Expression;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSInstantiationExpression {\n      type: 'TSInstantiationExpression';\n      range: Range;\n      expression: Expression;\n      typeArguments: TSTypeParameterInstantiation;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSNonNullExpression {\n      type: 'TSNonNullExpression';\n      range: Range;\n      expression: Expression;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSThisType {\n      type: 'TSThisType';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSInterfaceDeclaration {\n      type: 'TSInterfaceDeclaration';\n      range: Range;\n      declare: boolean;\n      id: Identifier;\n      extends: TSInterfaceHeritage[];\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      body: TSInterfaceBody;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSInterfaceBody {\n      type: 'TSInterfaceBody';\n      range: Range;\n      body: Array<\n        | TSCallSignatureDeclaration\n        | TSConstructSignatureDeclaration\n        | TSIndexSignature\n        | TSMethodSignature\n        | TSPropertySignature\n      >;\n      parent: TSInterfaceDeclaration;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSConstructSignatureDeclaration {\n      type: 'TSConstructSignatureDeclaration';\n      range: Range;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      params: Parameter[];\n      returnType: TSTypeAnnotation;\n      parent: TSInterfaceBody | TSTypeLiteral;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSMethodSignature {\n      type: 'TSMethodSignature';\n      range: Range;\n      computed: boolean;\n      optional: boolean;\n      readonly: boolean;\n      static: boolean;\n      kind: 'get' | 'set' | 'method';\n      key: Expression | Identifier | NumberLiteral | StringLiteral;\n      returnType: TSTypeAnnotation | undefined;\n      params: Parameter[];\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      parent: TSInterfaceBody | TSTypeLiteral;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSInterfaceHeritage {\n      type: 'TSInterfaceHeritage';\n      range: Range;\n      expression: Expression;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      parent: TSInterfaceBody;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSIndexSignature {\n      type: 'TSIndexSignature';\n      range: Range;\n      readonly: boolean;\n      static: boolean;\n      parameters: Parameter[];\n      typeAnnotation: TSTypeAnnotation | undefined;\n      parent: ClassBody | TSInterfaceBody | TSTypeLiteral;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSUnionType {\n      type: 'TSUnionType';\n      range: Range;\n      types: TypeNode[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSIntersectionType {\n      type: 'TSIntersectionType';\n      range: Range;\n      types: TypeNode[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSInferType {\n      type: 'TSInferType';\n      range: Range;\n      typeParameter: TSTypeParameter;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeOperator {\n      type: 'TSTypeOperator';\n      range: Range;\n      operator: 'keyof' | 'readonly' | 'unique';\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSIndexedAccessType {\n      type: 'TSIndexedAccessType';\n      range: Range;\n      indexType: TypeNode;\n      objectType: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * ```ts\n     * const a: any = null;\n     * ```\n     * @category Linter\n     * @experimental\n     */\n    export interface TSAnyKeyword {\n      type: 'TSAnyKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSUnknownKeyword {\n      type: 'TSUnknownKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSNumberKeyword {\n      type: 'TSNumberKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSObjectKeyword {\n      type: 'TSObjectKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSBooleanKeyword {\n      type: 'TSBooleanKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSBigIntKeyword {\n      type: 'TSBigIntKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSStringKeyword {\n      type: 'TSStringKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSSymbolKeyword {\n      type: 'TSSymbolKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSVoidKeyword {\n      type: 'TSVoidKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSUndefinedKeyword {\n      type: 'TSUndefinedKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSNullKeyword {\n      type: 'TSNullKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSNeverKeyword {\n      type: 'TSNeverKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSIntrinsicKeyword {\n      type: 'TSIntrinsicKeyword';\n      range: Range;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSRestType {\n      type: 'TSRestType';\n      range: Range;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSConditionalType {\n      type: 'TSConditionalType';\n      range: Range;\n      checkType: TypeNode;\n      extendsType: TypeNode;\n      trueType: TypeNode;\n      falseType: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSMappedType {\n      type: 'TSMappedType';\n      range: Range;\n      readonly: boolean;\n      optional: boolean;\n      nameType: TypeNode | null;\n      typeAnnotation: TypeNode | undefined;\n      constraint: TypeNode;\n      key: Identifier;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSLiteralType {\n      type: 'TSLiteralType';\n      range: Range;\n      literal: Literal | TemplateLiteral | UnaryExpression | UpdateExpression;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTemplateLiteralType {\n      type: 'TSTemplateLiteralType';\n      range: Range;\n      quasis: TemplateElement[];\n      types: TypeNode[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeLiteral {\n      type: 'TSTypeLiteral';\n      range: Range;\n      members: Array<\n        | TSCallSignatureDeclaration\n        | TSConstructSignatureDeclaration\n        | TSIndexSignature\n        | TSMethodSignature\n        | TSPropertySignature\n      >;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSOptionalType {\n      type: 'TSOptionalType';\n      range: Range;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeAnnotation {\n      type: 'TSTypeAnnotation';\n      range: Range;\n      typeAnnotation: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSArrayType {\n      type: 'TSArrayType';\n      range: Range;\n      elementType: TypeNode;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeQuery {\n      type: 'TSTypeQuery';\n      range: Range;\n      exprName: Identifier | ThisExpression | TSQualifiedName | TSImportType;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeReference {\n      type: 'TSTypeReference';\n      range: Range;\n      typeName: Identifier | ThisExpression | TSQualifiedName;\n      typeArguments: TSTypeParameterInstantiation | undefined;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypePredicate {\n      type: 'TSTypePredicate';\n      range: Range;\n      asserts: boolean;\n      parameterName: Identifier | TSThisType;\n      typeAnnotation: TSTypeAnnotation | undefined;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTupleType {\n      type: 'TSTupleType';\n      range: Range;\n      elementTypes: TypeNode[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSNamedTupleMember {\n      type: 'TSNamedTupleMember';\n      range: Range;\n      label: Identifier;\n      elementType: TypeNode;\n      optional: boolean;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeParameterDeclaration {\n      type: 'TSTypeParameterDeclaration';\n      range: Range;\n      params: TSTypeParameter[];\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSTypeParameter {\n      type: 'TSTypeParameter';\n      range: Range;\n      in: boolean;\n      out: boolean;\n      const: boolean;\n      name: Identifier;\n      constraint: TypeNode | null;\n      default: TypeNode | null;\n      parent: TSInferType | TSMappedType | TSTypeParameterDeclaration;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSImportType {\n      type: 'TSImportType';\n      range: Range;\n      argument: TypeNode;\n      qualifier: Identifier | ThisExpression | TSQualifiedName | null;\n      typeArguments: TSTypeParameterInstantiation | null;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSExportAssignment {\n      type: 'TSExportAssignment';\n      range: Range;\n      expression: Expression;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSFunctionType {\n      type: 'TSFunctionType';\n      range: Range;\n      params: Parameter[];\n      returnType: TSTypeAnnotation | undefined;\n      typeParameters: TSTypeParameterDeclaration | undefined;\n      parent: Node;\n    }\n\n    /**\n     * @category Linter\n     * @experimental\n     */\n    export interface TSQualifiedName {\n      type: 'TSQualifiedName';\n      range: Range;\n      left: Identifier | ThisExpression | TSQualifiedName;\n      right: Identifier;\n      parent: Node;\n    }\n\n    /**\n     * Union type of all possible statement nodes\n     * @category Linter\n     * @experimental\n     */\n    export type Statement =\n      | BlockStatement\n      | BreakStatement\n      | ClassDeclaration\n      | ContinueStatement\n      | DebuggerStatement\n      | DoWhileStatement\n      | ExportAllDeclaration\n      | ExportDefaultDeclaration\n      | ExportNamedDeclaration\n      | ExpressionStatement\n      | ForInStatement\n      | ForOfStatement\n      | ForStatement\n      | FunctionDeclaration\n      | IfStatement\n      | ImportDeclaration\n      | LabeledStatement\n      | ReturnStatement\n      | SwitchStatement\n      | ThrowStatement\n      | TryStatement\n      | TSDeclareFunction\n      | TSEnumDeclaration\n      | TSExportAssignment\n      | TSImportEqualsDeclaration\n      | TSInterfaceDeclaration\n      | TSModuleDeclaration\n      | TSNamespaceExportDeclaration\n      | TSTypeAliasDeclaration\n      | VariableDeclaration\n      | WhileStatement\n      | WithStatement;\n\n    /**\n     * Union type of all possible expression nodes\n     * @category Linter\n     * @experimental\n     */\n    export type Expression =\n      | ArrayExpression\n      | ArrayPattern\n      | ArrowFunctionExpression\n      | AssignmentExpression\n      | AwaitExpression\n      | BinaryExpression\n      | CallExpression\n      | ChainExpression\n      | ClassExpression\n      | ConditionalExpression\n      | FunctionExpression\n      | Identifier\n      | ImportExpression\n      | JSXElement\n      | JSXFragment\n      | Literal\n      | TemplateLiteral\n      | LogicalExpression\n      | MemberExpression\n      | MetaProperty\n      | NewExpression\n      | ObjectExpression\n      | ObjectPattern\n      | SequenceExpression\n      | Super\n      | TaggedTemplateExpression\n      | TemplateLiteral\n      | ThisExpression\n      | TSAsExpression\n      | TSInstantiationExpression\n      | TSNonNullExpression\n      | TSSatisfiesExpression\n      | TSTypeAssertion\n      | UnaryExpression\n      | UpdateExpression\n      | YieldExpression;\n\n    /**\n     * Union type of all possible type nodes in TypeScript\n     * @category Linter\n     * @experimental\n     */\n    export type TypeNode =\n      | TSAnyKeyword\n      | TSArrayType\n      | TSBigIntKeyword\n      | TSBooleanKeyword\n      | TSConditionalType\n      | TSFunctionType\n      | TSImportType\n      | TSIndexedAccessType\n      | TSInferType\n      | TSIntersectionType\n      | TSIntrinsicKeyword\n      | TSLiteralType\n      | TSMappedType\n      | TSNamedTupleMember\n      | TSNeverKeyword\n      | TSNullKeyword\n      | TSNumberKeyword\n      | TSObjectKeyword\n      | TSOptionalType\n      | TSQualifiedName\n      | TSRestType\n      | TSStringKeyword\n      | TSSymbolKeyword\n      | TSTemplateLiteralType\n      | TSThisType\n      | TSTupleType\n      | TSTypeLiteral\n      | TSTypeOperator\n      | TSTypePredicate\n      | TSTypeQuery\n      | TSTypeReference\n      | TSUndefinedKeyword\n      | TSUnionType\n      | TSUnknownKeyword\n      | TSVoidKeyword;\n\n    /**\n     * A single line comment\n     * @category Linter\n     * @experimental\n     */\n    export interface LineComment {\n      type: 'Line';\n      range: Range;\n      value: string;\n    }\n\n    /**\n     * A potentially multi-line block comment\n     * @category Linter\n     * @experimental\n     */\n    export interface BlockComment {\n      type: 'Block';\n      range: Range;\n      value: string;\n    }\n\n    /**\n     * Union type of all possible AST nodes\n     * @category Linter\n     * @experimental\n     */\n    export type Node =\n      | Program\n      | Expression\n      | Statement\n      | TypeNode\n      | ImportSpecifier\n      | ImportDefaultSpecifier\n      | ImportNamespaceSpecifier\n      | ImportAttribute\n      | TSExternalModuleReference\n      | ExportSpecifier\n      | VariableDeclarator\n      | Decorator\n      | ClassBody\n      | StaticBlock\n      | PropertyDefinition\n      | MethodDefinition\n      | SwitchCase\n      | CatchClause\n      | TemplateElement\n      | PrivateIdentifier\n      | AssignmentPattern\n      | RestElement\n      | SpreadElement\n      | Property\n      | JSXIdentifier\n      | JSXNamespacedName\n      | JSXEmptyExpression\n      | JSXOpeningElement\n      | JSXAttribute\n      | JSXSpreadAttribute\n      | JSXClosingElement\n      | JSXOpeningFragment\n      | JSXClosingFragment\n      | JSXExpressionContainer\n      | JSXText\n      | JSXMemberExpression\n      | TSModuleBlock\n      | TSClassImplements\n      | TSAbstractMethodDefinition\n      | TSAbstractPropertyDefinition\n      | TSEmptyBodyFunctionExpression\n      | TSCallSignatureDeclaration\n      | TSPropertySignature\n      | TSEnumBody\n      | TSEnumMember\n      | TSTypeParameterInstantiation\n      | TSInterfaceBody\n      | TSConstructSignatureDeclaration\n      | TSMethodSignature\n      | TSInterfaceHeritage\n      | TSIndexSignature\n      | TSTypeAnnotation\n      | TSTypeParameterDeclaration\n      | TSTypeParameter\n      | LineComment\n      | BlockComment;\n\n    export {}; // only export exports\n  }\n\n  /**\n   * The webgpu namespace provides additional APIs that the WebGPU specification\n   * does not specify.\n   *\n   * @category GPU\n   * @experimental\n   */\n  export namespace webgpu {\n    /**\n     * Starts a frame capture.\n     *\n     * This API is useful for debugging issues related to graphics, and makes\n     * the captured data available to RenderDoc or XCode\n     * (or other software for debugging frames)\n     *\n     * @category GPU\n     * @experimental\n     */\n    export function deviceStartCapture(device: GPUDevice): void;\n    /**\n     * Stops a frame capture.\n     *\n     * This API is useful for debugging issues related to graphics, and makes\n     * the captured data available to RenderDoc or XCode\n     * (or other software for debugging frames)\n     *\n     * @category GPU\n     * @experimental\n     */\n    export function deviceStopCapture(device: GPUDevice): void;\n\n    export {}; // only export exports\n  }\n\n  export {}; // only export exports\n}\n",
    filePath: 'ts:deno/globals.d.ts',
  }
];
